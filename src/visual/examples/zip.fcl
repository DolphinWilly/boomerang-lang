let mapName p l = fork p (map l) id

let pullUpM1 = 
  hoist_nonunique m1 {*h *t};
  rename *h x;
  hoist_nonunique *t {*h *t};
  xfork {*h *t} {m1} (plunge m1) (rename x *h)

let pullUpM2 = 
  hoist_nonunique m2 {*h *t};
  rename *h y;
  hoist_nonunique *t {*h *t};
  xfork {*h *t} {m2} (plunge m2) (rename y *h)

let rec zip =
  cond m1m2Empty isEmpty

    (* base case, both empty *)
    (prune m1 {m1={}}; prune m2 {m2={}})

    (* if list under m1 is longer *)
    (cond m1Longer empty2Hd
      (pullUpM1;
       add *t {*h={} *t={}};
       xfork {*h *t} {*h} (plunge *h) (zip; plunge *t)
      )
  
      (* else if list under m2 is longer *)
      (cond m2Longer empty1Hd
         (pullUpM2;
           fork {*h}
           (add *t {};
            plunge *t;
            add *h {};
            plunge *h)
           (zip; plunge *t)
         )

         (* else, lists under m1 and m2 are non-empty, same length *)
         (pullUpM2;
          xfork {y} {*t}
            (add *t {};
             plunge *t)
            (pullUpM1);
          xfork {*h *t} {*h} (plunge *h) (zip; plunge *t)
         )
      )
    )

do zip

