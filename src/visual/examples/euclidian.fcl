let plunge_nonunique n p = xfork p {n} (plunge n) id
let map_head l = fork {*h} (map l) id

let act p = 
 acond isEmptyList isEmptyList
  id
   (acond (child *t (child *h (child *h p))) (child *h (child *t (minus all isEmptyList)))
     (filter {*h *t} [];
        rename *h *x;
        hoist_nonunique *t {*h *t *};
        xfork {*x *h} {*h} (rename *h *t;rename *x *h;add * {};plunge *h) id )
     (map_head (plunge *h;add * {};add *t [])))

let structured_text p = 
  let rec aux = wmap < *t -> aux > ; act (not p) in
  aux

let rec rotate_inv =
 acond (union (child *t (equalDom {*})) isEmptyList) (union (child *t (equalDom {*})) 
isEmptyList)
  id
  (wmap <*t -> rotate_inv>;
   rename *h *x;
   hoist_nonunique * {};
   hoist_nonunique *t {*h * *t};
   xfork {*x *t *} {*t}
    (rename *x *h;
     plunge *t)
    (add * {}))

let rec rotate =
  acond (union (child *t (equalDom {*})) isEmptyList) (union (child *t (equalDom {*}))
 isEmptyList)
   id
   (rename *h *x;
    hoist_nonunique * {};
    hoist_nonunique *t {*h * *t};
    xfork {*x *t *} {*t}
     (rename *x *h;
      rotate;
      plunge *t)
     (add * {}))

let rec list_reverse =
 wmap < *t -> list_reverse >;rotate

let q = q

let euclidian =
let rec divide =
 acond (isEmptyList) (isEmptyList)
  (id)
 (
 acond (child *n isEmptyList) (child *h (hasChild *p))
  (hoist_nonunique *n {*};
   plunge_nonunique *h {*q};
   add *t [];
   plunge_nonunique *t {*h * *t};
   plunge_nonunique *h {*p};
   add * {};
   wmap < *t -> (wmap < *t ->  divide>) > )
  (acond (child *p isEmptyList) (child *h (hasChild q))
    (add *h {q *};
     hoist_nonunique *p {*};
     copy *q *p;
     plunge_nonunique *t {*n *p *q};
     wmap < *t -> divide >)
    (hoist_nonunique *p {* *h *t};
     hoist_nonunique * {};
     hoist_nonunique *h {q *};
     hoist_nonunique q {};
     hoist_nonunique * {};
     rename *t *p;
     hoist_nonunique *n {* *h *t};
     rename *t *n;
     plunge_nonunique *t {*n *p *q};
     wmap < *t -> divide >))
 ) in
 add *p [];
 divide;
 rotate_inv;
 rotate_inv;
 hoist_nonunique *h {*p};
 hoist_nonunique * {};
 hoist_nonunique *t {* *h *t};
 hoist_nonunique * {};
 hoist_nonunique *h {*q};
 rename *p *r';
 rename *t *p;
 wmap <*p -> (	structured_text (hasChild q);
		rotate_inv;
		rename *h *r;
		wmap < *r -> tl {q *} >;
		hoist_nonunique * {};
		rename *t *p;
		wmap < *p -> (list_map (tl {q *})) >
		) >;
 hoist_nonunique *p {*p *r}

do euclidian