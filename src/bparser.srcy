#{#}
%{ 
(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007 J. Nathan Foster and Benjamin C. Pierce                  *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/src/parser.mly                                                   *)
(* Boomerang parser                                                            *)
(* $Id$ *)
(*******************************************************************************)

(* imports and abbreviations *)
open Bsyntax
open Bident
module L = Blenses 
let sprintf = Printf.sprintf
let (@) = Safelist.append

(* helpers for merging parsing info *)
let m = Info.merge_inc 
let me1 e1 i2 = m (info_of_exp e1) i2
let me2 i1 e2 = m i1 (info_of_exp e2)
let me e1 e2 = m (info_of_exp e1) (info_of_exp e2) 
let mp2 i1 p2 = m i1 (info_of_pat p2)
let mp p1 p2 = m (info_of_pat p1) (info_of_pat p2)

(* helpers for building ASTs *)
let mk_qid_var x = EVar(Qid.info_of_t x,x)
let mk_var x = mk_qid_var (Qid.t_of_id x)
let mk_native_prelude_var x = mk_qid_var (Qid.mk_native_prelude_t x)
let mk_core_var x = mk_qid_var (Qid.mk_core_t x)
let mk_list_var x = mk_qid_var (Qid.mk_list_t x)
let mk_over i op el = EOver(i,op,el)
let mk_app i e1 e2 = EApp(i,e1,e2)
let mk_bin_op i o e1 e2 = mk_app i (mk_app i o e1) e2
let mk_tern_op i o e1 e2 e3 = mk_app i (mk_bin_op i o e1 e2) e3
let mk_cat i e1 e2 = mk_over i ODot [e1;e2]
let mk_iter i min max e1 = mk_over i (OIter(min,max)) [e1]
let mk_acond i e1 e2 = mk_over i OBar [e1;e2]
let mk_cond i e1 e2 = mk_over i OBar [e1;e2]
let mk_swap i e1 e2 = mk_over i OTilde [e1;e2]
let mk_diff i e1 e2 = mk_bin_op i (mk_core_var "diff") e1 e2
let mk_inter i e1 e2 = mk_bin_op i (mk_core_var "inter") e1 e2
let mk_compose i e1 e2 = mk_bin_op i (mk_core_var "compose") e1 e2
let mk_set i e1 e2 = mk_bin_op i (mk_qid_var (Qid.mk_core_t "set")) e1 e2
let mk_match i x q =   
  mk_bin_op i 
    (mk_core_var "dmatch")
    (EString(i,x)) 
    (mk_qid_var q)
let mk_sim_match i e t q = 
  mk_tern_op i 
    (mk_core_var "smatch")
    (EString(i,string_of_float e))
    (EString(i,t))
    (mk_qid_var q)
let mk_rx i e = mk_app i (mk_core_var "str") e

(* error *)
let syntax_error i msg = 
  raise 
    (Error.Harmony_error
        (fun () -> Util.format "@[%s: Syntax error: %s @\n@]" 
          (Info.string_of_t i)
          msg))

(* helper for parsing csets *)
let parse_cset s = 
  let err () = raise (Parsing.Parse_error) in 
  let i = ref 0 in
  let l = String.length s in
  let eos () = !i = l in
  let test c = not (eos ()) && s.[!i] = c in
  let accept c = let r = test c in if r then incr i; r in
  let num = function 
  | '0' -> 0
  | '1' -> 1
  | '2' -> 2
  | '3' -> 3
  | '4' -> 4
  | '5' -> 5
  | '6' -> 6
  | '7' -> 7
  | '8' -> 8
  | '9' -> 9 
  | _ -> err () in
  let get () = 
    let do_get () = let r = s.[!i] in incr i; r in 
      if accept '\\' then 
        match do_get () with
          | '^' -> '^'
          | '-' -> '-'
          | 'b' -> '\008'
          | 'n' -> '\010'
          | 'r' -> '\013'
          | 't' -> '\009'
          | '\\' -> '\\'
          | c   -> 
          let n1 = num c in 
          let n2 = num (do_get ()) in 
          let n3 = num (do_get ()) in 
          Char.chr (100 * n1 + 10 * n2 + n3) 
      else (do_get ()) in 
  let next () = if eos () then err () else get () in 
  let rec go acc = 
    if eos () then Safelist.rev acc
    else 
      let acc' = 
        if accept '-' then err ()
        else
          let c1 = next () in 
            if accept '-' then 
              (c1,next ())::acc 
            else (c1,c1)::acc in 
        go acc' in 
    go []

(* helper for parsing qids *)
let parse_qid i qstr = 
  let err () = raise (Parsing.Parse_error) in 
  let j = ref 0 in
  let l = String.length qstr in
  let eos () = !j = l in
  let get () = let r = qstr.[!j] in incr j; r in 
  let next () = if eos () then err () else get () in 
  let rec go (acc,x) = 
    if eos () then (Safelist.rev acc,(i,x))
    else 
      let c1 = next () in 
      if c1 = '.' then go ((i,x)::acc,"")
      else go (acc,x ^ (String.make 1 c1)) in 
  go ([],"")

(* helper for building functions *)
let build_fun i param_alts body sort = 
  let f,_,f_sort = 
    Safelist.fold_right
      (fun pa (f,so,s) -> match pa with 
         | Misc.Left(p) -> 
             let f' = EFun(i,p,so,f) in 
             let s' = SFunction(Id.wild,sort_of_param p,[],s) in
             (f',None,s')
         | Misc.Right(a) -> 
             let f' = ETyFun(i,a,f) in 
             let s' = SForall(a,s) in 
             (f',None,s'))
      param_alts (body,Some sort,sort) in 
  (f,f_sort)

(* helper for building un-sorted functions *)
let build_bare_fun i param_alts body = 
  Safelist.fold_right
    (fun pa f -> 
       match pa with 
         | Misc.Left(p) -> 
             EFun(i,p,None,f)
         | Misc.Right(a) -> 
             ETyFun(i,a,f))
    param_alts body

let rec mk_tree op l = match l with
  | [] -> syntax_error (Info.M "mk_tree") "empty tree"
  | [e1] -> e1
  | _ -> 
      let n = Safelist.length l in 
      let rec take i l acc = match i,l with
        | 0,_ | _,[] -> (Safelist.rev acc,l)
        | _,h::t -> take (pred i) t (h::acc) in
      let l1,l2 = take (n/2) l [] in
      let e1 = mk_tree op l1 in
      let e2 = mk_tree op l2 in 
      let res = mk_over (me e1 e2) op [e1;e2] in 
      res

let rec fixup_pat i p0 = match p0 with 
  | PVnt(_,x,Some _) -> syntax_error i "illegal pattern"
  | PVnt(i,x,None)   -> PVar(i,Qid.id_of_t x,None)
  | PPar(i,p1,p2)    -> PPar(i,fixup_pat i p1,fixup_pat i p2)
  | _ -> p0

%}

%token <Info.t> EOF
%token <Info.t> MODULE OPEN OF TYPE 
%token <Info.t> UNIT BOOL INT CHAR STRING REGEXP LENS CANONIZER FORALL WHERE
%token <Bident.Id.t> STR RXSTR UIDENT LIDENT QUALIDENT TYVARIDENT CSET NSET
%token <Info.t * char> CHARACTER
%token <Info.t * int> INTEGER
%token <Info.t * bool> BOOLEAN
%token <Info.t * float> FLOAT
%token <Info.t> HASH LBRACE RBRACE LLIST LBRACK RBRACK LPAREN RPAREN LANGLE RANGLE   
%token <Info.t> ARROW DARROW DEQARROW EQARROW
%token <Info.t> BEGIN END FUN LET IN TEST MATCH WITH
%token <Info.t> SEMI COMMA DOT EQUAL COLON BACKSLASH SLASH
%token <Info.t> STAR RLUS BANG BAR PLUS MINUS UNDERLINE HAT TILDE AMPERSAND QMARK 
%token <Info.t> LT GT LEQ GEQ  
%token <Info.t> CTYPE ATYPE BIJ GET PUT CREATE CANONIZE CHOOSE INTO
%token <Info.t> ERROR

%start modl uid qid
%type <Bsyntax.modl> modl
%type <Bident.Qid.t> uid
%type <Bident.Qid.t> qid
%%

#{@}

\section{Parsing}

\renewcommand{\lit}[1]{\char96{}#1\char39{}}
\def\ltsym{@<@}
\def\gtsym{@>@}

This section gives a formal definition of Boomerang syntax as an
EBNF grammar. The productions for each syntactic category are followed
by a brief explanation. In grammar rules we adopt the following
conventions:
\begin{itemize}
    
\item Literals are written in a typewriter font and enclosed in 
  quotes: e.g., \lit{@module@};

\item Non-terminals and tokens are enclosed in angle brackets: e.g.,
  \synt{Exp};

\item Optional elements are enclosed in square brackets:
e.g., \syntax{[\lit{@:@} <Sort>]};

\item Terms are grouped using parentheses;

\item Optional and repeated terms are specified using \syntax{?} (optional), \syntax{*} (0 or
  more), and \syntax{+} (1 or more).

\end{itemize}
#{#}

/* --------- MODULES ---------- */

#{@}
\subsection{Modules and Declarations}

\begin{grammar}
<CompilationUnit> ::= \lit{@module@} <UIdent> \lit{@=@} (\lit{@open@} <Qid>)* <Decl>*

#{#}

modl: 
  | MODULE UIDENT EQUAL opens decls EOF
      { Mod(m $1 $6,$2,$4,$5) }

opens:
  | OPEN qid opens  
      { $2::$3 }
  | { [] }

/* --------- DECLARATIONS ---------- */
#{@}
<Decl> ::= \lit{@module@} <LIdent> \lit{@=@} <Decl>* \lit{@end@}
      \alt \lit{@type@} <TyVarList> <LIdent> \lit{@=@} <DTSortList>
      \alt \lit{@let@} <Id> (<Param>)+ (\lit{@:@} <Sort>)? \lit{@=@} <Exp>
      \alt \lit{@let@} <PairPat> (<Param>)+ (\lit{@:@} <Sort>)? \lit{@=@} <Exp>
      \alt \lit{@test@} <InfixExp> \lit{@=@} <TestResExp>
      \alt \lit{@test@} <InfixExp> \lit{@:@} <TestResSort>
\end{grammar}

\noindent A Boomerang compilation unit contains a single module
declaration, such as @module Foo@, which must appear in a file named
@foo.src@ (for ``literate'' sources) or @foo.boom@ (for plain sources).
Boomerang modules are only used to group declarations into a
common namespace (in particular, Boomerang does not support module
signatures or sealing. A module consists of a sequence of @open@ 
declarations, which import all the declarations from another module into 
the namespace, followed by a sequence of declarations. A declaration is 
either a nested @module@, a @type@, a @let@, or a unit test. 

\subsubsection{Unit Tests} \label{sec:unittests}

Boomerang supports inline unit tests, which are executed when
the system is run in testing mode (see Section~\ref{sec:cmdlineargs}). 

#{@}
\begin{grammar}
<TestResExp> ::= \lit{@?@} 
            \alt \lit{@error@}
            \alt <AppExp>

<TestRestSort> ::= \lit{@?@}
             \alt <Sort>
\end{grammar}

\noindent Unit tests have one of the following forms:
%
\begin{progeg}
test (copy [A-Z]*).get "ABC" = "ABC"
test (copy [A-Z]*).get "ABC" = ?
test (copy [A-Z]*).get "123" = error
test (copy [A-Z]*).get "ABC" : string
test (copy [A-Z]*).get "ABC" : ?
\end{progeg}
%
The first form, @test@~$e_1$~@=@~$e_2$, checks that $e_1$ and $e_2$ 
evaluate to identical values. The two expressions must have compatible 
sorts with a defined equality operation. We often use this kind of test 
to print and check the behavior of the $\GET$, $\PUT$, and $\CREATE$ 
components of lenses. A unit test of the form @test@~$e$~@= ?@ evaluates 
$e$ and prints the result. The third form of unit test, @test@~$e$~@= error@, 
checks that an exception is raised during evaluation of $e$. This kind 
of test is used to check that a lens correctly checks the side conditions 
on its inputs. 
%
Finally, unit tests of the form @test@~$e$~@:@~$s$ and @test@~$e$~@: ?@ test 
the sort of $e$ rather than its value.
%
\finish{Say what these do with full refinement sorts!}
#{#}

decls:      
  | TYPE tyvar_list LIDENT EQUAL dtsort_list decls
      { let i = m $1 $4 in 
        DType(i,$2,Qid.t_of_id $3,$5)::$6 }

  | LET id param_list COLON sort EQUAL exp decls
      { let i = me2 $1 $7 in 
        let f,f_sort = build_fun i $3 $7 $5 in 
        let i2,_ = $2 in 
        let b = Bind(i,PVar(i2,$2,None),None,f) in 
        DLet(i,b)::$8 }

  | LET id param_list EQUAL exp decls
      { let i = me2 $1 $5 in 
        let f = build_bare_fun i $3 $5 in 
        let i2,_ = $2 in 
        let b =  Bind(i,PVar(i2,$2,None),None,f) in 
        DLet(i,b)::$6 }

  | LET pairpat COLON sort EQUAL exp decls
      { let i = me2 $1 $6 in 
        let b = Bind(i,fixup_pat i $2,Some $4,$6) in 
        DLet(i,b)::$7 }

  | LET pairpat EQUAL exp decls
      { let i = me2 $1 $4 in 
        let b =  Bind(i,fixup_pat i $2,None,$4) in 
        DLet(i,b)::$5 }

  | MODULE UIDENT EQUAL decls END decls 
      { let i = m $1 $5 in 
        DMod(i,$2,$4)::$6 }

  | TEST infixexp EQUAL test_res_exp decls
      { let i4,tr = $4 in 
        let i = m $1 i4 in 
        DTest(i,$2,tr)::$5 }

  | TEST infixexp COLON test_res_sort decls
      { let i = m $1 $3 in 
        DTest(i,$2,$4)::$5 }

  | TEST infixexp COLON ERROR decls 
      { let i = m $1 $4 in 
        DTest(i,$2,TestError)::$5 }
      
  | { [] }


/* --------- TEST RESULTS --------- */      
test_res_exp:
  | QMARK
      { ($1,TestPrint) }
  | ERROR
      { ($1,TestError) }
  | appexp 
      { (info_of_exp $1, TestEqual $1) }

test_res_sort:
  | QMARK
      { TestSortPrint None}

  | sort      
      { TestSortEqual $1 }

/* --------- EXPRESSIONS ---------- */      
#{@}
\subsection{Expressions} \label{sec:parser:expressions}

\begin{grammar}
<Exp> ::= \lit{@let@} <Id> (<Param>)+ (\lit{@:@} <Sort>)? \lit{@=@} <Exp> \lit{@in@} <Exp>
     \alt \lit{@let@} <PairPat> (\lit{@:@} <Sort>)? \lit{@=@} <Exp> \lit{@in@} <Exp>
     \alt \lit{@fun@} (<Param>)+ (\lit{@:@} <Sort>)? \lit{@->@} <Exp>
     \alt <CaseExp>

#{#}
exp:
  | LET id param_list COLON sort EQUAL exp IN exp 
      { let i = me2 $1 $9 in 
        let f,f_sort = build_fun i $3 $7 $5 in 
        let i2,_ = $2 in 
        let b = Bind(i,PVar(i2,$2,None),None,f) in 
        ELet(i,b,$9) }

  | LET id param_list EQUAL exp IN exp 
      { let i = me2 $1 $7 in 
        let f = build_bare_fun i $3 $5 in 
        let i2,_ = $2 in 
        let b = Bind(i,PVar(i2,$2,None),None,f) in 
        ELet(i,b,$7) }

  | LET pairpat COLON sort EQUAL exp IN exp 
      { let i = me2 $1 $8 in 
        let b = Bind(i,fixup_pat i $2,Some $4,$6) in 
        ELet(i,b,$8) }

  | LET pairpat EQUAL exp IN exp 
      { let i = me2 $1 $6 in 
        let b = Bind(i,fixup_pat i $2,None,$4) in 
        ELet(i,b,$6) }

  | FUN param_list ARROW exp
      { let i = me2 $1 $4 in 
        build_bare_fun i $2 $4 }

  | FUN param_list COLON asort ARROW exp
      { let i = me2 $1 $6 in 
        let f,_ = build_fun i $2 $6 $4 in 
        f }
      
  | cexp                               
      { $1 }


/* case expressions */

#{@}
<CaseExp> ::= \lit{@match@} <Exp> \lit{@with@} <BranchList> \lit{@:@} <Sort>
         \alt \lit{@(@} \lit{@match@} <Exp> \lit{@with@} <BranchList> \lit{@)@} \lit{@:@} <Sort>
         \alt \lit{@begin@} \lit{@match@} <Exp> \lit{@with@} <BranchList> \lit{@end@} \lit{@:@} <Sort>
         \alt <ComposeExp>
\end{grammar}
#{#}

cexp:
  | MATCH composeexp WITH branch_list COLON sort
      { let i4,pl = $4 in 
        ECase(m $1 i4,$2,pl,$6) }

  | LPAREN MATCH composeexp WITH branch_list RPAREN COLON sort
      { let _,pl = $5 in 
        ECase(m $1 $6,$3,pl,$8) }

  | BEGIN MATCH composeexp WITH branch_list END COLON sort
      { let _,pl = $5 in 
        ECase(m $1 $6,$3,pl,$8) }

  | composeexp
      { $1 }

/* --------- PARAMETERS ---------- */
#{@}
\subsubsection{Parameters}
\begin{grammar}
<Param> ::= \lit{@(@} <Id> \lit{@:@} <Sort> \lit{@)@}
       \alt \lit{@(@} <TyVarIdent> \lit{@)@}
       \alt <TyVarIdent> 
\end{grammar}
#{#}

param_list:
  | param param_list2
      { $1 :: $2 }
param_list2:
  | param param_list2
      { $1 :: $2 }
  |
      { [] }

param: 
  | LPAREN id COLON sort RPAREN
      { let i = m $1 $5 in 
        Misc.Left (Param(i,$2,$4)) }

  | LPAREN TYVARIDENT RPAREN
      { Misc.Right ($2) }

  | TYVARIDENT 
      { Misc.Right ($1) }

/* --------- BRANCHES ---------- */
#{@}
\subsubsection{Branches}

\begin{grammar}
<Branch> ::= <Pat> \lit{@-@\gtsym} <InfixExp>

<BranchList> ::= (\lit{@|@})? <Branch> (\lit{@|@} <Branch>)*
\end{grammar}
#{#}
branch: 
  | pat ARROW infixexp 
      { let i = m (info_of_pat $1) (info_of_exp $3) in 
        (i,$1,$3) }

branch_list:
  | branch branch_list2
      { let (i1,p,e) = $1 in 
        let (i2,l) = $2 i1 in 
        (m i1 i2, (p,e)::l) }

  | BAR branch branch_list2
      { let (i1,p,e) = $2 in 
        let (i2,l) = $3 i1 in 
        (m $1 i2, (p,e)::l) }

branch_list2:
  | 
      { (fun i -> (i,[])) }
        
  | BAR branch branch_list2
      { let (i1,p,e) = $2 in 
        let (i2,l) = $3 i1 in 
        (fun _ -> (m $1 i2, (p,e)::l)) }

/* compose expressions */
#{@}
\begin{grammar}
<ComposeExp> ::= <ComposeExp> \lit{@;@} <BarExp>
            \alt <BarExp>

#{#}

composeexp:
  | composeexp SEMI barexp
      { mk_compose (me $1 $3) $1 $3 }
      
  | barexp
      { $1 }

/* bar expressions */
#{@}
<BarExp> ::= <OBarExp> 
        \alt <DBarExp> 
        \alt <EqualExp>

#{#}
barexp:
  | obarexp 
      { mk_tree OBar (Safelist.rev $1) }

  | dbarexp 
      { mk_tree OBarBar (Safelist.rev $1) }

  | equalexp
      { $1 }

#{@}
<OBarExp> ::= <OBarExp> \lit{@|@} <EqualExp>
         \alt <EqualExp> \lit{@|@} <EqualExp>

#{#}
obarexp: 
  | obarexp BAR equalexp
      { $3 :: $1 }
  | equalexp BAR equalexp
      { [$3; $1 ] }

#{@}
<DBarExp> ::= <DBarExp> \lit{@||@} <EqualExp>
         \alt <EqualExp> \lit{@||@} <EqualExp>

#{#}
dbarexp:
  | dbarexp BAR BAR equalexp
      { $4 :: $1 }
  | equalexp BAR BAR equalexp 
      { [$4; $1] }

#{@}
<EqualExp> ::= <AppExp> \lit{@=@} <AppExp>
          \alt <CommaExp>

#{#}
equalexp:
  | appexp EQUAL appexp 
      { mk_over (me $1 $3) OEqual [$1; $3] }
  | commaexp
      { $1 }

#{@}
<CommaExp> ::= <CommaExp> \lit{@,@} <InfixExp>
          \alt <InfixExp>

#{#}
commaexp:
  | commaexp COMMA infixexp
      { EPair(me $1 $3, $1, $3) }
  | infixexp
      { $1 }

#{@}
<InfixExp> ::= <DotExp> 
      \alt <TildeExp> 
      \alt <AmpExp> 
      \alt <LensComponentExp> 
      \alt <AppExp> \lit{@-@} <AppExp> 
      \alt <AppExp> \lit{@&&@} <AppExp> 
      \alt <AppExp> \lit{\ltsym@-@\gtsym} <AppExp> 
      \alt <AppExp> \lit{\ltsym@=@\gtsym} <AppExp> 
      \alt <AppExp> \lit{\ltsym} <AppExp> 
      \alt <AppExp> \lit{\ltsym@=@} <AppExp> 
      \alt <AppExp> \lit{\gtsym} <AppExp> 
      \alt <AppExp> \lit{\gtsym@=@} <AppExp>       
      \alt <AppExp>

#{#}      
infixexp:
  | dotexp 
      { $1 }
  | tildeexp
      { $1 }
  | minusexp
      { $1 }
  | ampexp 
      { $1 }
  | ampampexp 
      { $1 }
  | darrowexp
      { $1 }
  | deqarrowexp
      { $1 }
  | ltexp 
      { $1 }
  | leqexp 
      { $1 }
  | gtexp 
      { $1 }
  | geqexp
      { $1 }
  | lenscomponentexp
      { $1 }
  | appexp
      { $1 }

#{@}
<DotExp> ::= <DotExp> \lit{@.@} <AppExp> 
      \alt <AppExp> \lit{@.@} <AppExp>

#{#}      
dotexp:
  | dotexp DOT appexp
      { mk_over (me $1 $3) ODot [$1; $3] }
  | appexp DOT appexp
      { mk_over (me $1 $3) ODot [$1; $3] }

#{@}
<TildeExp> ::= <TildeExp> \lit{@~@} <AppExp> 
      \alt <AppExp> \lit{@~@} <AppExp>

#{#}      
tildeexp:
  | tildeexp TILDE appexp
      { mk_over (me $1 $3) OTilde [$1; $3] }
  | appexp TILDE appexp
      { mk_over (me $1 $3) OTilde [$1; $3] }

#{@}
<AmpExp> ::= <AmpExp> \lit{@&@} <AppExp> 
        \alt <AppExp> \lit{@&@} <AppExp> 

#{#}      
ampexp:
  | ampexp AMPERSAND appexp 
      { mk_over (me $1 $3) OAmp [$1; $3] }
  | appexp AMPERSAND appexp 
      { mk_over (me $1 $3) OAmp [$1; $3] }

#{@}
<LensComponentExp> ::= <AppExp> (\lit{@.get@} <AppExp>
       \alt <AppExp> (\lit{@.put@} <AppExp> \lit{@into@} <AppExp>
       \alt <AppExp> (\lit{@.create@} <AppExp>       
       \alt <AppExp> (\lit{@.canonize@} <AppExp> 
       \alt <AppExp> (\lit{@.choose@} <AppExp>
       \alt <AppExp> (\lit{@.ctype@}
       \alt <AppExp> (\lit{@.atype@}
       \alt <AppExp> (\lit{@.domain_type@}
       \alt <AppExp> (\lit{@.codomain_type@}
       \alt <AppExp> (\lit{@.bij@}

#{#}
lenscomponentexp: 
  | appexp GET appexp
      { let i = me $1 $3 in 
        mk_bin_op i (mk_core_var "get") $1 $3 }
  | appexp PUT appexp INTO appexp
      { let i = me $1 $3 in
        mk_tern_op i (mk_core_var "put") $1 $3 $5 }
  | appexp CREATE appexp
      { let i = me $1 $3 in
        mk_bin_op i (mk_core_var "create") $1 $3 }
  | appexp CANONIZE appexp
      { let i = me $1 $3 in
        mk_bin_op i (mk_core_var "canonize") $1 $3 }
  | appexp CHOOSE appexp
      { let i = me $1 $3 in
        mk_bin_op i (mk_core_var "choose") $1 $3 }
  | appexp CTYPE
      { let i = me1 $1 $2 in 
        mk_app i (mk_core_var "ctype") $1 }
  | appexp ATYPE
      { let i = me1 $1 $2 in 
        mk_app i (mk_core_var "atype") $1 }
  | appexp BIJ 
      { let i = me1 $1 $2 in 
        mk_app i (mk_core_var "bij") $1 }

minusexp:
  | appexp MINUS appexp
      { mk_over (me $1 $3) OMinus [$1; $3] }

ampampexp:
  | appexp AMPERSAND AMPERSAND appexp 
      { mk_over (me $1 $4) OAmpAmp [$1; $4] }

darrowexp:
  | appexp DARROW appexp 
      { mk_over (me $1 $3) ODarrow [$1; $3] }

deqarrowexp:
  | appexp DEQARROW appexp
      { mk_over (me $1 $3) ODeqarrow [$1; $3] }

ltexp:
  | appexp LT appexp 
      { mk_over (me $1 $3) OLt [$1; $3] }

leqexp:
  | appexp LEQ appexp 
      { mk_over (me $1 $3) OLeq [$1; $3] }

gtexp:
  | appexp GT appexp 
      { mk_over (me $1 $3) OGt [$1; $3] }

geqexp:
  | appexp GEQ appexp 
      { mk_over (me $1 $3) OGeq [$1; $3] }

/* application expressions */
#{@}
<AppExp> ::= <AppExp> <RepExp>
       \alt <RepExp>

#{#}
appexp:
  | appexp repexp                         
      { mk_app (me $1 $2) $1 $2 }

  | repexp
      { $1 }
      
/* repeated expressions */
#{@}
<RepExp> ::= <TyExp> <Rep>
       \alt <TyExp>

#{#}
repexp:
  | tyexp rep                            
      { let i2,(min,max) = $2 in 
        let i = me1 $1 i2 in 
        mk_iter i min max $1 }

  | tyexp                                
      { $1 }


#{@}
<TyExp> ::= <TyExp> \lit{@{@} <Sort> \lit{@}@} 
       \alt <TyExp>

#{#}
tyexp:
  | tyexp LBRACE sort RBRACE
      { let i = me1 $1 $4 in 
        ETyApp(i,$1,$3) }

  | aexp 
      { $1 }


/* atomic expressions */
#{@}
<AExp> ::= \lit{@(@} <Exp> \lit{@)@}
      \alt \lit{@begin@} <Exp> \lit{@end@}
      \alt <Qid>
      \alt <MatchExp>
      \alt \lit{@#@} \lit{@{@} <SortList> \lit{@}@} <List>
      \alt <Character>
      \alt <Integer>
      \alt <Boolean>
      \alt <CharSet>
      \alt <NegCharSet>
      \alt <String>
      \alt <RegExpString>
      \alt \lit{@()@}

#{#}

aexp:
  | LPAREN exp RPAREN
      { $2 }

  | BEGIN exp END                       
      { $2 }

  | qid
      { mk_qid_var $1 }

  | matchexp
      { $1 }

  | HASH LBRACE sort LLIST list 
      { let i6,mk = $5 in 
        let i = m $1 i6 in 
        let l = mk i $3 in 
        l }

  | CHARACTER
      { let i,c = $1 in 
        EChar(i,c) }

  | INTEGER
      { let i,n = $1 in 
        EInteger(i,n) }

  | BOOLEAN
      { let i,b = $1 in 
        EBoolean(i,b) }

  | CSET                                
      { let i1,s1 = $1 in         
        ECSet(i1,true,parse_cset s1) }

  | NSET                                
      { let i1,s1 = $1 in 
        ECSet(i1,false,parse_cset s1) }

  | STR 
      { let i,s = $1 in 
        EString(i,s) }

  | RXSTR
      { let i,s = $1 in 
        mk_rx i (EString(i,s)) }

  | LPAREN RPAREN
      { EUnit(m $1 $2) }

matchexp:
#{@}
<MatchExp> ::= \ltsym <Qid> \gtsym
      \alt \ltsym <LIdent> \lit{@:@} <Qid> \gtsym
      \alt \ltsym \lit{@~@} <Qid> \gtsym
      \alt \ltsym \lit{@~@} <LIdent> \lit{@:@} <Qid> \gtsym
      \alt \ltsym \lit{@~@} \lit{@{@} <Float> \lit{@}@} <Qid> \gtsym
      \alt \ltsym \lit{@~@} \lit{@{@} <Float> \lit{@}@}  <LIdent> \lit{@:@} <Qid> \gtsym
\end{grammar}
#{#}

  | LANGLE qid RANGLE
      { mk_match (m $1 $3) "" $2 }

  | LANGLE LIDENT COLON qid RANGLE
      { mk_match (m $1 $5) (Id.string_of_t $2) $4 }

  | LANGLE TILDE qid RANGLE 
      { mk_sim_match (m $1 $4) 1.0 "" $3 }

  | LANGLE TILDE LIDENT COLON qid RANGLE 
      { mk_sim_match (m $1 $6) 1.0 (Id.string_of_t $3) $5 }

  | LANGLE TILDE LBRACE FLOAT RBRACE qid RANGLE 
      { let _,f = $4 in 
        mk_sim_match (m $1 $7) f "" $6 }

  | LANGLE TILDE LBRACE FLOAT RBRACE LIDENT COLON qid RANGLE 
      { let _,f = $4 in 
        mk_sim_match (m $1 $9) f (Id.string_of_t $6) $8 }

/* --------- REPETITIONS ---------- */
#{@}
\subsection{Repetitions}
\begin{grammar}
<Rep> ::= \lit{@*@}
     \alt \lit{@+@}
     \alt \lit{@?@}
     \alt \lit{@{@} <Integer> \lit{@}@}
     \alt \lit{@{@} <Integer> \lit{@,@} <Integer> \lit{@}@}
\end{grammar}
#{#}
rep: 
  | STAR                                
      { ($1, (0,-1)) }

  | PLUS                                
      { ($1, (1,-1)) }

  | QMARK                               
      { ($1, (0,1)) }

  | LBRACE INTEGER RBRACE
      { let i = m $1 $3 in let _,n = $2 in (i, (n,n)) }

  | LBRACE INTEGER COMMA RBRACE             
      { let i = m $1 $3 in let _,n = $2 in (i, (n,-1)) }

  | LBRACE INTEGER COMMA INTEGER RBRACE         
      { let i = m $1 $5 in let _,n2 = $2 in let _,n4 = $4 in (i, (n2, n4)) }

/* --------- LISTS ------------ */
#{@}
\subsection{Lists}
\begin{grammar}
<List> ::= \lit{@[]@}
      \alt \lit{@[@} <BarExp> (\lit{@;@} <BarExp>)* \lit{@]@}
\end{grammar}
#{#}
list:
  | RBRACK 
      { $1, (fun i s -> ETyApp(i,mk_list_var "Nil",s)) }

  | barexp RBRACK 
      { ($2, 
         (fun i s -> 
            mk_app i 
              (ETyApp(i,mk_list_var "Cons",s))
              (EPair(i,$1,ETyApp(i,mk_list_var "Nil",s))))) }

  | barexp SEMI list
    { let i3,mk = $3 in 
      (i3, 
       (fun i s -> 
          mk_app i
            (ETyApp(i,mk_list_var "Cons",s))
            (EPair(i,$1, mk i s)))) }

/* --------- PATTERNS ---------- */
#{@}
\subsection{Patterns}
\begin{grammar}
<Pat> ::= <UIdent> <PairPat>
     \alt <QualIdent> <PairPat>
     \alt <PairPat>

#{#}
pat:      
  | UIDENT pairpat
      { let i1,_ = $1 in 
        let i = mp2 i1 $2 in 
         PVnt(i,Qid.t_of_id $1,Some $2) }

  | QUALIDENT pairpat
      { let (i,qs) = $1 in 
        PVnt(i,parse_qid i qs,Some $2) }

  | pairpat
      { $1 }

#{@}
<PairPat> ::= <PairPat> \lit{@,@} <APat>
     \alt <APat>

#{#}
pairpat:
  | pairpat COMMA apat
      { let i = mp $1 $3 in 
        PPar(i,$1,$3) }

  | apat
      { $1 }

#{@}
<APat> ::= \lit{@_@}
     \alt <LIdent>
     \alt \lit{@()@}
     \alt <Integer>
     \alt <Boolean>
     \alt <String>
     \alt <UIdent>
     \alt <Qident>
     \alt \lit{@(@} <Pat> \lit{@)@}
\end{grammar}
#{#}
apat:
  | UNDERLINE 
    { PWld($1) }

  | LIDENT
      { let i,_ = $1 in 
        PVar(i,$1,None) }

  | LPAREN RPAREN
      { PUnt(m $1 $2) }

  | INTEGER
    { let i,n = $1 in 
       PInt(i,n) }

  | BOOLEAN
      { let i,b = $1 in 
        PBol(i,b) }

  | STR
      { let i,s = $1 in 
        PStr(i,s) }

  | UIDENT
      { let i,_ = $1 in 
        PVnt(i,Qid.t_of_id $1,None) }
      
  | QUALIDENT
      { let (i,qs) = $1 in 
        PVnt(i,parse_qid i qs,None) }

  | LPAREN pat RPAREN
      { $2 }

/* --------- SORTS ---------- */
#{@}
\subsection{Sorts}

\begin{grammar}
<Sort> ::= \lit{@forall@} <TyVarIdent> \lit{@=>@} <Sort>
     \alt <ArrowSort>

#{#}
sort:
  | FORALL TYVARIDENT EQARROW sort 
      { SForall($2,$4) }

  | arrowsort
      { $1 }

/* arrow sorts */
#{@}
<ArrowSort> ::= <ProductSort> \lit{@->@} <ArrowSort>
     \alt <ProductSort>

#{#}
arrowsort: 
  | productsort ARROW arrowsort 
      { SFunction(Id.wild,$1,[],$3) } 

  | productsort
      { $1 }

/* product sorts */
#{@}
<ProductSort> ::= <ProductSort> \lit{@->@} <DataTypeSort>
     \alt <DataTypeSort>

#{#}
productsort:
  | productsort STAR datatypesort
      { SProduct($1,$3) }

  | datatypesort
      { $1 }

/* data type sorts */
#{@}
<DataTypeSort> ::= <BSort> (<QVar>)?
     \alt \lit{@(@} <Sort> \lit{@,@} <SortList> \lit{@)@} <QVar>

#{#}
datatypesort:
  | bsort qvar
      { SData([$1],$2) }

  | LPAREN sort COMMA sort_list RPAREN qvar 
      { SData($2::$4, $6) }

  | bsort 
      { $1 }

#{@}
<BSort> ::= \lit{@(@} <Sort> \lit{@)@}
       \alt <ASort>

#{#}
bsort:
  | LPAREN sort RPAREN
      { $2 }

  | asort 
      { $1 }

/* atomic sorts */
#{@}
<BSort> ::= <QVar>
       \alt \lit{@char@}
       \alt \lit{@string@}
       \alt \lit{@regexp@}
       \alt \lit{@lens@}
       \alt \lit{@int@}
       \alt \lit{@bool@}
       \alt \lit{@canonizer@}
       \alt \lit{@unit@}
       \alt <TyVar>

#{#}
asort:
  | qvar
      { SData([], $1) }

  | CHAR
      { SChar }

  | STRING 
      { SString }

  | REGEXP 
      { SRegexp }

  | LENS  
      { SLens }

  | INT
      { SInteger }

  | BOOL
      { SBool }

  | CANONIZER
      { SCanonizer }

  | UNIT
      { SUnit }

  | tyvar
      { SVar $1 }  

#{@}
<TyVar> ::= <TyVarIdent>

<TyVarList> ::= <TyVar> 
          \alt \lit{@(@} <TyVar> (\lit{@,@} <TyVar>)* \lit{@)@}

#{#}

tyvar:
  | TYVARIDENT
      { $1 }

tyvar_list:
  | 
      { [] }

  | tyvar 
      { [$1] }

  | LPAREN tyvar_list2 RPAREN
      { $2 }

tyvar_list2:
  | tyvar
      { [$1] }

  | tyvar COMMA tyvar_list2
      { $1::$3 }

sort_list:
  | sort 
      { [$1] }

  | sort COMMA sort_list
      { $1 :: $3 }

/* data type sorts */
#{@}
<DTSort> ::= <UIdent>
        \alt <UIdent> \lit{@of@} <Sort>

<DTSortList> ::= <DTSort> (\lit{@|@} <DTSort>)*
\end{grammar}
#{#}

dtsort:
  | UIDENT
      { ($1,None) }

  | UIDENT OF sort
      { ($1,Some $3) }

dtsort_list:
  | dtsort dtsort_list2
      { $1 :: $2 }

dtsort_list2:
  | 
      { [] }
  
  | BAR dtsort dtsort_list2
      { $2 :: $3 }

/* --------- QUALIFIED IDENTIFIERS ---------- */
#{@}
\subsection{Identifiers}

\begin{grammar}
<Id> ::= <LIdent>
     \alt <UIdent>

<QId> ::= <LIdent>
     \alt <UIdent>
     \alt <QualIdent> 

<QVar> ::= <LIdent>
       \alt <QualIdent>
\end{grammar}
#{#}

id:
  | LIDENT
      { $1 }
  | UIDENT 
      { $1 }

qid:
  | LIDENT
      { Qid.t_of_id $1 }
  | UIDENT
      { Qid.t_of_id $1 }
  | QUALIDENT
      { let (i,qs) = $1 in parse_qid i qs }

qvar:
  | LIDENT
      { Qid.t_of_id $1 }

  | QUALIDENT
      { let (i,qs) = $1 in parse_qid i qs }

/* --------- MISC SYMBOLS ---------- */
uid:
  | UIDENT
      { Qid.t_of_id $1 }
