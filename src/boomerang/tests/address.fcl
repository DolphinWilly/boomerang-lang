(* Some notes about the Apple Address Book application:
     - \ characters do NOT round-trip: It will read a vCard containing
       \\Manchester and write it out as \Manchester
     - it trims blanks from the ends of fields
     - Unknown vCard fields get dumped into NOTEs.
     - It wants X-ABLabel fields to know how to display things, but it
       doesn't require them
     - It sometimes uses item1, item2, etc., instead of the EMAIL tag
*)

(* -------------------------------------------------------------------- *)
(* A useful derived lens *)

let filterwith (both: regexp) (l: klens) =
  filter (both - (ctype_klens l)) (ctype_klens l) ; l*

(* -------------------------------------------------------------------- *)

let Any = [^]*

let WS = [ \n\t]*
let ws = del WS

let StringNotContaining (r:regexp) : regexp = Any - (Any . r . Any)

(* -------------------------------------------------------------------- *)

let EscapedStr (R:regexp) : regexp =
  let Normal = StringNotContaining ([\n\\\r] | R) in
  let Esc = "\\" . ([\\n] | R) in
  Normal . (Esc . Normal)* 

let escchar (c:regexp) =
  (ins "\\" . (c | "\\")) | "\n" <-> "\\n" | ([^\\\n\r] - c)
let unescchar (c:regexp) = 
  (del "\\" . (c | "\\")) | "\\n" <-> "\n" | ([^\\\n\r] - c)

let escstr (c:regexp) =  (* BETTER : ? <-> (EscapedStr c) *)
  let r = EscapedStr c in
  let l = escchar c in
  let l' : ? <-> r =  (* FIX: ? <-> (EscapedStr c) *)
    l* in
  l'
let unescstr (c:regexp) = (unescchar c)*

let escNonEmptyStr (c:regexp) = (escchar c)+
let unescNonEmptyStr (c:regexp) = (unescchar c)+

test (unescchar empty)* get "\n" = error

test (unescchar empty)* get "abc" = "abc"
test (unescchar empty)* get "\\\\" = "\\"
test (unescchar empty)* get "\\n" = "\n"
test (unescchar [,])* get "\\," = ","

test (escchar empty)* get "a\nb\\c" = "a\\nb\\\\c"
test (escchar [,])* get "a,b" = "a\\,b"

(* -------------------------------------------------------------------- *)

let TelTags = [hwce] | "note"
let TelMarker = " (" . TelTags . ")"

let Name = (EscapedStr [,]) - ( Any . TelMarker )
let NonEmptyName = Name - ""
let Family = Name
let Given = Name
let GlobalName = Family . (", " . Given)?
  
let Tel = ", " . (EscapedStr [,]) . TelMarker

let AbsAddr = GlobalName . Tel* 

let NL = "\r"? . "\n"
let NonNL = StringNotContaining [\n\r]

let Names = Name . ("" | ", " . Name)

let formatname =
    escstr [,]
  ; Name . del TelMarker*

let name : ? <-> GlobalName =
  let escName = unescstr [,;:]; formatname in
  let escNonEmptyName : ? <-> Name =
      unescNonEmptyStr [,;:] 
    ; escNonEmptyStr [,] 
    ; ( del TelMarker+ | 
        NonEmptyName . del TelMarker*) in
  let familyname : ? <-> Name = 
     del "N:" . escName in
  familyname . (del ";" | ";" <-> ", " . escNonEmptyName ) . del ";;;" 

let formattel = escstr [,]

let tel' (w1:string) (w2:string) =
  "TEL;" <-> ", " . 
  del "type=" . del w1 .
  ("" | del ";type=pref") .
  del ":" . 
  (unescstr [;,:]; formattel) .
  ins " (" . ins w2 . ins ")" .
  del NL

let CTel = "TEL;type=" .
           ("WORK" | "HOME" | "CELL" | "EMAIL") . ";type=pref"? . ":" .
           (EscapedStr [,]) .
           NL

let tel =
    tel' "WORK" "w"
  | tel' "HOME" "h"
  | tel' "CELL" "c"
  | tel' "EMAIL" "e"

let formatnote = escstr [,]

let note =
  "NOTE:" <-> ", " .
  (unescstr [,:;]; formatnote) .
  ins " (note)" .
  del NL

let abemail =
  "item.EMAIL;type=INTERNET;type=pref:" <-> ", " .
  (unescstr [,:;]; escstr [,]) .
  del NL .
  del "item.X-ABLabel:E-mail" . del NL .
  ins " (e)" 

let entry = abemail | tel | note

let ItemLine = "item" . NonNL . NL
let Line = [^ ] . NonNL . NL . (" " . NonNL . NL)*

let Field =
      ((Line - ItemLine) | (ItemLine . ItemLine))
    - ("END:VCARD" . NL)

let NumberedItem (n:string) =
  "item" . n . "." . NonNL . NL . "item" . n . "." . NonNL . NL

let Field_unnumbered =
  Field - (NumberedItem "1" | NumberedItem "2" | NumberedItem "3")

let remove_item_numbers : ? <-> Field_unnumbered* =
  let delItemNumber (n:string) = "item" . del n . "." . NonNL . NL .
                                 "item" . del n . "." . NonNL . NL in
  let Stuff = Field - ("item" . NonNL . NL . "item" . NonNL . NL) in
    Stuff* . delItemNumber "1" .
    Stuff* . delItemNumber "2" .
    Stuff* . delItemNumber "3" .
    Field_unnumbered* 
  | Stuff* . delItemNumber "1" .
    Stuff* . delItemNumber "2" .
    Field_unnumbered* 
  | Stuff* . delItemNumber "1" .
    Field_unnumbered* 
  | Field_unnumbered* 

let chunk : ? <-> AbsAddr =
  del "BEGIN:VCARD" . del NL . del "VERSION:3.0" . del NL .  
  (key name) . del NL .
  (remove_item_numbers ;
   filterwith
     Field_unnumbered
     entry) .
  del "END:VCARD" . del NL

let vcard = <chunk>

let samplevcard = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    TEL;type=WORK;type=pref:6106236713
    FN:Andy Patroni
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    END:VCARD
  >>>

test vcard create "Foo, Jean-Paul, jean-paul.courbebaisse@education.gouv.fr (e), 1234567 (h), bar (e)" = ?

test vcard put "Foo, Jean-Paul, bar (e)" 
into
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:AAAAA TEST;Jean-Paul;;;
    item1.EMAIL;type=INTERNET;type=pref:jean-paul.courbebaisse@education.gouv.fr
    item1.X-ABLabel:E-mail
    TEL;type=WORK:1234567
    item2.EMAIL;type=INTERNET;type=pref:foo
    item2.X-ABLabel:E-mail
    END:VCARD
  >>> = ?

test vcard get samplevcard = "Andy Patroni, 6106236713 (w)"

test vcard put "Andy Patroni, 12345 (c), 67890 (h)" into samplevcard = 
  "BEGIN:VCARD
  |VERSION:3.0
  |N:Andy Patroni;;;;
  |TEL;type=CELL:12345
  |FN:Andy Patroni
  |X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\\:ABPerson
  |TEL;type=HOME:67890
  |END:VCARD
  |"

test vcard put "Andy Patroni, fubar (note)" into samplevcard =
<<<BEGIN:VCARD
VERSION:3.0
N:Andy Patroni;;;;
NOTE:fubar
FN:Andy Patroni
X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
END:VCARD
>>>

let vcards = (<chunk> . ins "\n") * . ws

let samplevcards = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Androuet;;;;
    FN:Androuet
    NOTE:(01) 42 89 95 00  41 rue d'Amsterdam  M. Liege  (cheese restaurant near St. Lazare\, Paris)  rather expensive and fancy and pungent (300FF/person)
    X-ABUID:A5695B7A-5931-4A63-8308-ANOTHERIDENT0\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:New York Restaurants;;;;
    FN:New York Restaurants
    NOTE:two best mexican in nyc (according to Scot\, IIRC)\n          rosa mexicana\n          zarela's
    X-ABUID:D40A8D20-F5E8-47E1-983E-D331E92C6F8B\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Pierce;Benjamin C.;;;
    FN:Benjamin C. Pierce
    TEL;type=HOME;type=pref:215 732-4684
    TEL;type=CELL:215 266-9001
    TEL;type=WORK:215 898-6222
    X-ABUID:87B85E7E-AB0F-4819-8647-0BD532019144\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    FN:Andy Patroni
    TEL;type=WORK;type=pref:6106236713
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Bistro de Vent;;;;
    FN:Bistro de Vent
    X-ABUID:F00ABF1D-8DC0-4C3C-98ED-2BC33FA8D90C\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Biswas;Goutam;;;
    FN:Goutam Biswas
    X-ABUID:5BEAD7E0-AFF8-42AB-BD38-9A741CD64E20\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Black;Andrew;;;
    FN:Andrew Black
    X-ABUID:A9BA5924-5A64-4D46-A40F-A0BC86073232\:ABPerson
    END:VCARD
  >>>
  
test vcards get samplevcards = 
  <<<
    Androuet, (01) 42 89 95 00  41 rue d'Amsterdam  M. Liege  (cheese restaurant near St. Lazare\, Paris)  rather expensive and fancy and pungent (300FF/person) (note)
    New York Restaurants, two best mexican in nyc (according to Scot\, IIRC)\n          rosa mexicana\n          zarela's (note)
    Pierce, Benjamin C., 215 732-4684 (h), 215 266-9001 (c), 215 898-6222 (w)
    Andy Patroni, 6106236713 (w)
    Bistro de Vent
    Biswas, Goutam
    Black, Andrew
  >>>

test vcards put 
  <<<
    Andy Patroni, 6106236713 (w), fubar (note)
    Pierce, Benjamin C., 215 898-6222 (w), 215 732-4684 (h), 215 266-9001 (c)
  >>>
into samplevcards = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    FN:Andy Patroni
    TEL;type=WORK;type=pref:6106236713
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    NOTE:fubar
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Pierce;Benjamin C.;;;
    FN:Benjamin C. Pierce
    TEL;type=WORK:215 898-6222
    TEL;type=HOME:215 732-4684
    TEL;type=CELL:215 266-9001
    X-ABUID:87B85E7E-AB0F-4819-8647-0BD532019144\:ABPerson
    END:VCARD
  >>>

(* test vcards get (read "/home/bcpierce/Desktop/vCards.vcf") = ? *)

(* -------------------------------------------------- *)
(* Generic XML stuff *)

let element (tag:string) (body:klens) =
  del "<" . del tag . del ">" . 
  body . 
  del "</" . del tag . del ">" . ws

let selement (tag:string) (body:slens) =
  del "<" . del tag . del ">" . 
  body . 
  del "</" . del tag . del ">" . ws

let special =
    "&lt;" <-> "<"
  | "&gt;" <-> ">"
  | "&amp;" <-> "&"

(* Parses and unquotes pcdata, including all whitespace *)
let pcdata =
  let Normal = StringNotContaining [&<>\r] in
  Normal . (special . Normal)*

let PCDATA = StringNotContaining [<>\r]

(* -------------------------------------------------- *)
(* BCP's strange personal variant of XCard *)

let name : ? <-> GlobalName =
  let n = pcdata ; formatname in
    n
  | (ws . element "family" n . ("" | ins ", " . element "given" n))

let tel' (full:string) (short:string) = 
  ins ", " . element full (pcdata; formattel . ins (" (" . short . ")"))

let tel = 
    tel' "tel-home" "h"
  | tel' "tel-work" "w"
  | tel' "tel-cell" "c"
  | tel' "email"    "e"
  | tel' "note"     "note"

let chunk = 
  element "vcard" 
    (ws .
     element "n" (key name) . 
     tel*)

let foo = 
  "<vcard>
      <n><family>foo</family><given>bar</given></n>
      <tel-home>12345</tel-home>
      <tel-cell>12345</tel-cell>
      <note>hello world</note>
   </vcard>"

let vcard = <chunk>

test vcard get foo = "foo, bar, 12345 (h), 12345 (c), hello world (note)"

let xcard = ws . selement "xcard" (ws . (vcard . ins "\n") * )

let samplexcards = 
     "<xcard>
     | <vcard>
     |   <n>Charles Addams</n>
     |   <note>goodbye world</note>
     | </vcard>
     | <vcard>
     |   <n><family>Doe</family><given>John</given></n>
     |   <note>hello world</note>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     | </vcard>
     | <vcard>
     |   <n><family>Doe</family><given>Sally</given></n>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     |   <note>hello, world ! Question : nice wheather ? (no ?)</note>
     | </vcard>
     |</xcard>
     |"

test xcard get samplexcards =
<<<Charles Addams, goodbye world (note)
Doe, John, hello world (note), 792-8134 (h), 732-4684 (h)
Doe, Sally, 792-8134 (h), 732-4684 (h), hello\, world ! Question : nice wheather ? (no ?) (note)
>>>             

(* test xcard get (read "/home/bcpierce/current/z/addresses.txt") = ? *)


(* TO DO:

   When processing a vCard, we might want to take *all* the fields we don't recognize
   (except, perhaps, some that we explicitly choose to delete) and put them in the note
   field in the abstract.  (This would mean that the lens is essentially a bijection.)

   To achieve this, it seems we'd need to...
      - use the order primitive to move the NOTE field to the end
      - then use order again to move all the recognized fields to the beginning
        and unrecognized fields to the end (before the NOTE)
      - then invent some convention for smashing them together with a separator, say $
      - escape $ everywhere it appears in the concrete vCard
      - In other formats (e.g. xCard), disallow $ in the concrete format of notes, except
        in situations where the whole note can be parsed as a real note plus some extra
        fields.  (I.e., basically the abstract and concrete note formats are the same.)

*)   

