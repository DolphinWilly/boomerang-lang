#{#}
/************************************************************/
/* The Harmony Project                                      */
/* harmony@lists.seas.upenn.edu                             */
/*                                                          */
/* parser.mly - Focal parser generator                      */
/************************************************************/
/* $Id$ */

%{

  open Error
  open Syntax
  open Info

  (* imports *)
  let ( @ ) = Safelist.append
  let debug = Trace.debug "parser"

  (* shorthands *)
  let m = merge_inc
  let me e1 e2 = m (info_of_exp e1) (info_of_exp e2)
  let me1 e1 i2 = m (info_of_exp e1) i2
  let me2 i1 e2 = m i1 (info_of_exp e2)
  let mie x1 e2 = m (info_of_id x1) (info_of_exp e2)
  let mis x1 s1 = m (info_of_id x1) (fst s1)
  let ms s1 s2 = m (fst s1) (fst s2)
  let mbs2 i1 bs2 = m i1 (info_of_bindings bs2)
  let mss2 i1 ss2 = m i1 (info_of_schema_bindings ss2)
%}

%token <Info.t> EOF 
%token <Syntax.id> IDENT STRING
%token <Info.t> LET IN FUN AND MODULE BEGIN END OPEN SCHEMA ASSERT CHECK PROTECT
%token <Info.t> LENS VIEW TYPE NAME ARROW FMAP BIJARROW VWBARROW WBARROW BACKTICK
%token <Info.t> LBRACE RBRACE LBRACK RBRACK LPAREN RPAREN
%token <Info.t> SEMI COMMA DOT EQUAL COLON BACKSLASH SLASH PRINT TEST SYNC WITH AT ERROR MISSING
%token <Info.t> STAR BANG BAR LT GT PLUS MINUS TILDE AMPERSAND QMARK
%token <Info.t> WHERE TRUE FALSE PRED FDS

%start modl sort qid 
%type <Syntax.modl> modl
%type <Info.t * Syntax.sort> sort
%type <Syntax.qid> qid

%%

#{@}

\renewcommand{\lit}[1]{\char96{}#1\char39{}}

\section{Syntactic Structure}

This section gives the formal definition of Focal syntax, using an
EBNF grammar. The productions for each syntactic category are followed
by a brief, informal discussion. In the rules we adopt the following
conventions:
\begin{itemize}

\item Literals are written in a typewriter font and enclosed in single 
  quotes, like this: \lit{@module@};

\item Non-terminals are enclosed in angle brackets, like this:
  \synt{Exp}. 

\item Optional elements are enclosed in square brackets:
  \syntax{[\lit{@:@} <Sort>]};

\item Terms may be grouped using parentheses;

\item Repeated elements are specified using \syntax{*} (0 or
  more) and \syntax{+} (1 or more).

\end{itemize}
#{#}

/* ---------------  modules & declarations --------------- */
#{@}
\subsection{Modules and Declarations}

\begin{grammar}

<CompilationUnit> ::= \lit{@module@} <Ident> \lit{@=@} (\lit{@open@} <Qid>)* <Decl>*

#{#}

modl:
| MODULE IDENT EQUAL opens decls EOF        { MDef(m $1 $6,$2,$4,$5) }

opens:
| OPEN qid opens                           { $2::$3 }
|                                          { [] }

#{@}

<Decl> ::= \lit{@let@} <BindingList> 
      \alt \lit{@schema@} <SchemaBindingList>
      \alt \lit{@module@} <Ident> \lit{@=@} <Decl>* \lit{@end@}
      \alt \lit{@test@} <Exp> \lit{@=@} <Exp>
      \alt \lit{@test@} <Exp> \lit{@=@} \lit{@error@}
      \alt \lit{@test@} <Exp> \lit{@=@} \lit{@?@}
      \alt \lit{@sync@} \lit{@with@} <AExp> \lit{@at@} <AExp> <AExp> \lit{@=@} <AExp>
      \alt \lit{@sync@} \lit{@with@} <AExp> <AExp> <AExp> \lit{@at@} <AExp> <AExp> \lit{@=@} <AExp>
\end{grammar}
\finish{Add @test schema@ alternatives}


\noindent A Focal compilation unit contains a single module
declaration, such as @module Foo@, that must appear in a file named
@foo.src@ (for ``literate'' sources) or @foo.fcl@ (for plain sources).
A module contains a sequence of @open@ declarations, which import all
the declarations from another module, followed by a sequence of
declarations. A declaration is either a @let@, a @schema@, a nested @module@, or a
unit test. Focal modules are currently only used to group declarations in a
common namespace. In particular, Focal does not yet support module
signatures or sealing.

\subsubsection{Unit Tests} \label{sec:unittests}

The syntax includes several forms of unit tests (which are only tested when
the system is run in testing mode; see Section~\ref{sec:cmdlineargs}).  
The first form, @test@~$t_1$~@=@~$t_2$, checks that $t_1$ and $t_2$, which 
must both be expressions of sort @view@, evaluate to equal values. This 
kind of test is often used to check the behavior of the \GET{} and \PUT{} 
components of lenses, as in the following snippet: @test id / {} = {}@. 
The second form, @ test@~$l_1$~@/\@~$t_1$~@=@~$t_3$, is shorthand for two tests
of a bijective lens: @ test@~$l_1$~@/@~$t_1$~@=@~$t_2$ and 
@test@~$l_1$~@\@~$t_2$~@missing =@~$t_1$. The third form, 
@test@~$t_1$~@= error@, checks that $t_1$ raises an exception when it
evaluates $t_1$. This kind of test is used to ensure that native
lenses, such @hoist@, check side conditions on their inputs correctly; for example,
%
@test hoist "n" {} = error@.  
The fourth form, @test@~$t_1$~@=?@, causes Harmony to run the unit test and
print out the result.
The final two forms are used to test the behavior of the synchronization algorithm: 
\begin{center}
@sync with@~$l$~@at@~$s$~@{O=@$o$@, A=@$a$@, B=@$b$@} = {O=@~$o'$~@, A=@~$a'$~@, B=@~$b'$@}@.
\end{center}
applies $l\lgetn$ to the trees $o$, $a$, and $b$, synchronizes those
trees at schema $s$, and then applies $l\lputn$ to the results,
yielding $o'$, $a'$ and $b'$. The unit test 
\begin{center}
@sync with@~$l_o$~$l_a$~$l_b$~@at@~$s$~@{O=@$o$@, A=@$a$@, B=@$b$@} = {O=@~$o'$~@, A=@~$a'$~@, B=@~$b'$@}@.
\end{center}
is similar, but applies a different lens to $o$, $a$, and $b$.

#{#}

decls:
  | LET binding_list decls                   { DLet(mbs2 $1 $2,$2)::$3 }
  | SCHEMA schema_binding_list decls         { DSchema(mss2 $1 $2, $2)::$3 }
  | MODULE IDENT EQUAL decls END decls       { DMod(m $1 $5,$2,$4)::$6 } 
  | TEST exp EQUAL test_res decls            { DTest(m $1 (fst $4), $2, snd $4)::$5 }
  | TEST composeexp SLASH BACKSLASH exp 
      EQUAL exp decls                        { let i = me2 $1 $7 in
                                               let get_test = DTest(i, mk_get_exp i $2 $5, (Result $7)) in
                                               let put_test = DTest(i, mk_put_exp i $2 $7 None, (Result $5)) in
                                                 get_test::put_test::$8 }

  | SYNC WITH aexp AT aexp aexp EQUAL 
      test_res decls                         { let i = m $1 (fst $8) in
                                               let sync_test = DTest(i, mk_sync_exp i $3 $3 $3 $5 $6, snd $8) in
                                                 sync_test::$9 } 
  | SYNC WITH aexp aexp aexp AT 
      aexp aexp EQUAL test_res decls         { let i = m $1 (fst $10) in
                                               let sync_test = DTest(i, mk_sync_exp i $3 $4 $5 $7 $8, snd $10) in
                                                 sync_test::$11 }
  |                                          { [] }

test_res:
  | exp                                      { (info_of_exp $1, Result $1) }
  | ERROR                                    { ($1, ErrorResult) }
  | QMARK                                    { ($1, PrintResult) }

/* ---------------  bindings --------------- */
#{@}
\subsection{Bindings}

\begin{grammar}
<Binding> ::= <Ident> (<Ident>\lit{@:@}<Sort>)+ \lit{@:@} <ASort> \lit{@=@} <Exp>
         \alt <Ident> (<Ident>\lit{@:@}<Sort>)+ \lit{@:@} <AExp> <LensArrow> <AExp> \lit{@=@} <Exp>

<BindingList> ::= <Binding> 
             \alt <Binding> \lit{and} <BindingList>


<SchemaBinding> ::= <Ident> \lit{@=@} <Exp>

<SchemaBindingList> ::= <SchemaBinding> 
             \alt <SchemaBinding> \lit{and} <SchemaBindingList>
\end{grammar}

\noindent Focal @let@-bindings are identical to OCaml @let@-bindings except that the 
@let@-bound variable and the expression must both be annotated with their sorts.

In a schema declaration, the bound variable may be used recursively,
as in the following declaration: @schema X = { "n" = X } | {}@, which
denotes the infinite set of trees containing the empty tree and every
tree with a single child @n@ whose subtree is also in the schema. For
more on schemas, see Sections~\ref{sec:parser:expressions} and
\ref{sec:lang:schemas}.

#{#}

binding_list:
  | binding AND binding_list                 { $1::$3 }
  | binding                                  { [$1] }

binding:    
  | IDENT param_list COLON asort EQUAL exp               { BDef(mie $1 $6,$1,$2,snd $4,$6) }
  | IDENT param_list COLON aexp lensarrow aexp EQUAL exp { let i : Info.t = mie $1 $8 in 
                                                           let c_info = info_of_exp $4 in
                                                           let a_info = info_of_exp $6 in
                                                           let c_id = id_of_string c_info (fresh "_CONCRETE") in
                                                           let a_id = id_of_string a_info (fresh "_ABSTRACT") in
                                                           let c_qid = qid_of_id c_id in
                                                           let a_qid = qid_of_id a_id in
                                                           let c_var = EVar(c_info, c_qid, false) in 
                                                           let a_var = EVar(a_info, a_qid, false) in 
                                                           let bs = [ BDef(c_info,c_id,[],SSchema,$4)
                                                                    ; BDef(a_info,a_id,[],SSchema,$6)] in
                                                           let e = ELet(i,bs,ECheckLens(i,c_var,$5,a_var,$8)) in
                                                           let s = SCheckedLens(c_qid,$5,a_qid) in 
                                                             BDef(mie $1 $8,$1,$2,s,e) }

schema_binding_list:
  | schema_binding AND schema_binding_list   { $1::$3 }
  | schema_binding                           { [$1] }

schema_binding:
  | IDENT EQUAL exp                          { SDef(mie $1 $3, $1, $3) }

/* ---------------  sorts & params --------------- */
#{@}
\subsection{Sorts}

% hacks to get arond grammar parsing; it gets confused on '<'.
\def\bijarrow{@<<~>@} 
\def\vwbarrow{@<<=>@} 
\def\wbarrow{@<<->@} 

\begin{grammar}
<Sort> ::= <ASort> \lit{@->@} <Sort>
      \alt <ASort>

<ASort> ::= \lit{@lens@}
       \alt \lit{@name@}
       \alt \lit{@view@}
       \alt \lit{@schema@}
       \alt \lit{@(@} <Sort> \lit{@)@}

<LensArrow> ::= \lit{\bijarrow} 
       \alt \lit{\vwbarrow} 
       \alt \lit{\wbarrow}
\end{grammar}

\noindent Focal does not yet have a full-blown lens type
system. However, the compiler performs rudimentary sort checking. The
sorts are @lens@, @name@, @view@, @schema@, and function sorts, of the
form $s_1$@->@$s_2$. The sort checker supports exactly one form of
subtyping: it automatically promotes an expressions with sort view to
the singleton schema containing that tree.

#{#}

sort:
  | asort ARROW sort                         { (ms $1 $3, SArrow(snd $1, snd $3)) }
  | asort                                    { $1 }

asort:
  | LENS                                     { ($1, SLens) }
  | NAME                                     { ($1, SName) } 
  | VIEW                                     { ($1, SView) }
  | SCHEMA                                   { ($1, SSchema) }
  | PRED                                     { ($1, SPred) }
  | FDS                                      { ($1, SFD) }
  | FMAP                                     { ($1, SMap) }
  | LPAREN sort RPAREN                       { $2 }

opt_sort:
  | COLON asort                              { Some (snd $2) }
  |                                          { None }

param_list:
  | param param_list                         { $1::$2 }
  |                                          { [] }

param:
  | LPAREN IDENT COLON sort RPAREN           { PDef(m $1 $5, $2, snd $4) }      

lensarrow: 
  | BIJARROW                                 { Bij }
  | VWBARROW                                 { Vwb }
  | WBARROW                                  { Wb }

/* ---------------  expressions --------------- */
#{@}
\subsection{Expressions} \label{sec:parser:expressions}

\begin{grammar}
<Exp> ::= \lit{@let@} <BindingList> \lit{@in@} <Exp>
     \alt \lit{@schema@} <SchemaBindingList> \lit{@in@} <Exp>
     \alt \lit{@fun@} ([\lit{(}]<Ident>\lit{@:@}<Sort>[\lit{)}])+ [\lit{@:@}<Sort>] \lit{@->@} <Exp>
     \alt <GetPutExp>

<ExpList> ::= <Exp>
         \alt <Exp> \lit{@,@} <ExpList>

#{#}
exp: 
  | LET binding_list IN exp                  { ELet(me2 $1 $4,$2,$4) }
  | SCHEMA schema_binding_list IN exp        { ESchema(me2 $1 $4,$2,$4) }
  | FUN param param_list opt_sort ARROW exp  { EFun(me2 $1 $6,$2::$3,$4,$6) }
  | getputexp                                { $1 }

#{@}

<GetPutExp> ::= <ComposeExp> \lit{@/@} <PlusExp>
           \alt <ComposeExp> \lit{@\@} <AExp> <AExp>
           \alt <ComposeExp> \lit{@\@} <AExp> \lit{@missing@}
           \alt <ComposeExp>

#{#}

getputexp:
  | composeexp SLASH plusexp                 { mk_get_exp (me $1 $3) $1 $3 }
  | composeexp BACKSLASH aexp aexp           { mk_put_exp (me $1 $4) $1 $3 (Some $4) }
  | composeexp BACKSLASH aexp MISSING        { mk_put_exp (me1 $1 $4) $1 $3 None }
  | composeexp                               { $1 }


#{@}

<ComposeExp> ::= <ComposeExp> \lit{@;@} <BarExp>
            \alt <BarExp>

#{#}

composeexp:
  | composeexp SEMI barexp                   { mk_compose2_exp (me $1 $3) $1 $3 }
  | barexp                                   { $1 } 

#{@}

<BarExp> ::= <BarExp> \lit{@|@} <AndExp>
        \alt <AndExp>

#{#}

barexp:
  | barexp BAR interexp                      { EUnion(me $1 $3,[$1;$3]) }
  | interexp                                 { $1 }

#{@}

<InterExp> ::= <InterExp> \lit{@&@} <MinusExp>
         \alt <MinusExp>
#{#}

interexp:
  | interexp AMPERSAND minusexp              { EInter(me $1 $3,[$1;$3]) }
  | minusexp                                 { $1 }

#{@}
<MinusExp> ::= <MinusExp> \lit{@+@} <PlusExp>
         \alt <PlusExp>

#{#}

minusexp:
  | minusexp MINUS plusexp                    { EMinus(me $1 $3, $1, $3) }
  | plusexp                                   { $1 }

#{@}
<PlusExp> ::= <PlusExp> \lit{@+@} <ConsExp>
         \alt <ConsExp>

#{#}

plusexp:
  | plusexp PLUS consexp                     { ECat(me $1 $3, [$1; $3]) }
  | consexp                                  { $1 }

#{@}

<ConsExp> ::= <AppExp> \lit{::} <ConsExp>
         \alt <AppExp> \lit{:|:} <ConsExp>
         \alt <AppExp>

#{#}
consexp:
  | appexp COLON COLON consexp               { ECons(me $1 $4, $1, $4) }
  | appexp                                   { $1 }

#{@}

<AppExp> ::= <AppExp> <AExp>
        \alt <AExp>

#{#}

appexp:
  | appexp aexp                              { EApp(me $1 $2,$1,$2) }
  | aexp                                     { $1 }

#{@}

<AExp> ::= <String>
      \alt <QId>
      \alt \lit{@~@} <AExp>
      \alt \lit{@{@} <MapList> \lit{@}@}
      \alt \lit{@{@} <TreeEltList> \lit{@}@}
      \alt \lit{@[@} <ExpList> \lit{@]@}
      \alt \lit{@[|@} <ExpList> \lit{@|]@}
      \alt \lit{@(@} <Exp> \lit{@)@}
      \alt \lit{@begin@} <Exp> \lit{@end@}
      \alt \lit{@protect@} <AExp>
      \alt \lit{@assert@} <AExp>

<Map> ::= <QuotedName> \lit{@->@} <Exp>

<MapList> ::= <Map>
         \alt <Map> \lit{@,@} <MapList>

#{#}

aexp:
  | STRING                                   { EName(info_of_id $1,$1) }
  | qid                                      { EVar(info_of_qid $1,$1,false) }
  | TILDE aexp                               { let i = me2 $1 $2 in EMinus(i,mk_any_exp i,$2) }
  | LPAREN exp RPAREN                        { $2 }
  | BEGIN exp END                            { $2 }
  | ASSERT aexp                              { EAssert(me2 $1 $2, $2) }
  | CHECK aexp COLON aexp lensarrow aexp     { ECheckLens(me2 $1 $6,$4,$5,$6,$2) }
  | PROTECT aexp                             { EProtect(me2 $1 $2, $2, None) }
  | WITH LBRACE fds RBRACE                   { EDBFD($1,$3) }
  | WHERE apred                              { EDBPred($1,$2) }
  | LBRACE map_list RBRACE                   { EMap(m $1 $3, $2) }
  | LBRACE treeelt_list RBRACE               { ECat(m $1 $3,$2) }
  | LBRACE LBRACE LBRACE db_contents
    RBRACE RBRACE RBRACE                     { EDB($1,$4) }
  | LBRACE LBRACE db_schema_contents
    RBRACE RBRACE                            { EDBSchema($1, $3) }
  | LBRACK exp_list RBRACK                   { Safelist.fold_right
                                                 (fun ti acc -> 
                                                    ECons(me ti acc,ti,acc))
                                                 $2
                                                 (ENil($3))}      

 map:
   | quoted_name ARROW exp                    { ($1,$3) }

 /* maps must be non-empty to avoid overlap with schemas and trees */
 map_list:
   | map                                      { [$1] }
   | map COMMA map_list                       { $1::$3 }
#{@}

<TreeElt> ::= <QuotedName>
         \alt [\lit{@?@}] <QuotedName> \lit{@=@} <Exp>
         \alt \lit{@*@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>
         \alt \lit{@!@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>
         \alt \lit{@?@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>
         \alt \lit{@+@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>

<TreeEltList> ::= <TreeElt>
             \alt <TreeElt> \lit{@,@} <TreeEltList>

#{#}
db_contents:
  |                                           { Db.empty }
  | IDENT LPAREN names RPAREN 
    EQUAL LBRACE tuples RBRACE 
    opt_comma db_contents                     { Db.extend (Syntax.name_of_id $1) 
                                                  (Safelist.fold_right 
                                                    Db.Relation.insert_tuple
                                                    $7
                                                    (Db.Relation.create $3))
                                                   $10 }

opt_comma:
  |                                           { () }
  | COMMA                                     { () }

names:
  |                                           { [] }
  | IDENT                                     { [ Syntax.name_of_id $1 ] }
  | IDENT COMMA names                         { (Syntax.name_of_id $1) :: $3 }

tuples:
  |                                           { [] }
  | LPAREN names RPAREN                       { [ $2 ] }
  | LPAREN names RPAREN opt_comma tuples      { $2 :: $5 } 

db_schema_contents: 
  |                                           { Dbschema.base }
  | IDENT LPAREN names RPAREN 
    pred_and_fds                              { Dbschema.extend 
                                                  (Syntax.name_of_id $1) 
                                                  (Dbschema.Relschema.set_fdset
                                                    (Dbschema.Relschema.set_pred 
                                                      (Dbschema.Relschema.create 
                                                         (Safelist.fold_right Name.Set.add $3 Name.Set.empty))
                                                      (fst $5))
                                                    (snd $5))
                                                   Dbschema.base }
  | IDENT LPAREN names RPAREN 
    pred_and_fds 
    COMMA db_schema_contents                  { Dbschema.extend 
                                                  (Syntax.name_of_id $1) 
                                                  (Dbschema.Relschema.set_fdset
                                                    (Dbschema.Relschema.set_pred 
                                                      (Dbschema.Relschema.create 
                                                         (Safelist.fold_right Name.Set.add $3 Name.Set.empty))
                                                      (fst $5))
                                                    (snd $5))
                                                   $7 }


pred_and_fds:
  |                                           { (Db.Relation.Pred.True, Dbschema.Relschema.Fd.Set.empty)  }
  | WHERE pred                                { ($2, Dbschema.Relschema.Fd.Set.empty) }
  | WITH LBRACE fds RBRACE                    { (Db.Relation.Pred.True, $3) }
  | WHERE pred                                
    WITH LBRACE fds RBRACE                    { ($2, $5) }
  | WITH LBRACE fds RBRACE                    
    WHERE pred                                { ($6, $3) }


pred: 
  | TILDE apred                               { Db.Relation.Pred.Not $2 }
  | apred SLASH BACKSLASH apred               { Db.Relation.Pred.Conj ($1,$4) }
  | apred BACKSLASH SLASH apred               { Db.Relation.Pred.Disj ($1,$4) }
  | apred ARROW apred                         { Db.Relation.Pred.Impl ($1,$3) }
  | apred                                     { $1 }

apred: 
  | TRUE                                      { Db.Relation.Pred.True }
  | FALSE                                     { Db.Relation.Pred.False }
  | IDENT EQUAL IDENT                         { Db.Relation.Pred.EqAttAtt 
                                                  ((Syntax.name_of_id $1), (Syntax.name_of_id $3)) }
  | IDENT LT GT IDENT                         { Db.Relation.Pred.Not (Db.Relation.Pred.EqAttAtt 
                                                  ((Syntax.name_of_id $1), (Syntax.name_of_id $4))) }
  | IDENT EQUAL STRING                        { Db.Relation.Pred.EqAttVal 
                                                  ((Syntax.name_of_id $1), (Syntax.name_of_id $3)) }
  | IDENT LT GT STRING                        { Db.Relation.Pred.Not (Db.Relation.Pred.EqAttVal
                                                  ((Syntax.name_of_id $1), (Syntax.name_of_id $4))) }
  | LPAREN pred RPAREN                        { $2 }

fds:
  |                                           { Dbschema.Relschema.Fd.Set.empty }
  | attribute_list ARROW attribute_list       { Dbschema.Relschema.Fd.Set.singleton ($1,$3) }
  | attribute_list ARROW attribute_list 
    COMMA fds                                 { Dbschema.Relschema.Fd.Set.add ($1,$3) $5 }

attribute_list: 
  | IDENT                                     { Name.Set.singleton (Syntax.name_of_id $1) }
  | LPAREN attribute_list_content RPAREN      { $2 }

attribute_list_content: 
  |                                           { Name.Set.empty }
  | IDENT                                     { Name.Set.singleton (Syntax.name_of_id $1) }
  | IDENT COMMA attribute_list_content        { Name.Set.add (Syntax.name_of_id $1) $3 }


#{@}
\end{grammar}
\finish{Add database concrete syntax to grammar table!}

Focal expressions are similar to OCaml expressions with only a few
special forms for composing and applying lenses, and for writing down
trees and schemas. The main forms, in decreasing order of precedence,
are:
\begin{itemize}
\item Fully annotated @let@-expressions,
\item Anonymous $\lambda$-expressions, written 
  @fun @$x_1$@:@$s_1$~$\dots$~$x_k$@:@$s_k$~@:@$s$@-> @$e$, where each
  $x_i$ is a plain identifier and $s_i$ a sort. The parameters and
  sorts may optionally be enclosed in parentheses, and the return sort
  may be omitted.
\item get and put expressions, which apply the $\lgetn$ and $\lputn$
  components of a lens respectively. A get expression is written
  $e_1$~@/@~$e_2$, where $e_1$ has sort @lens@ and $e_2$ has sort
  @view@. Put expressions are written $e_1$~@\@~$e_2\;e_3$ or $e_1$~@\@~$e_2$~@missing@, if the concrete argument is missing.
\item Lens composition, written $e_1$@;@$e_2$,
\item Schema unions, written $e_1$~@|@~$e_2$,
\item Tree and schema concatenations, written $e_1$~@+@~$e_2$,
\item Tree and schema cons cells, written $e_1$@::@$e_2$,
\item Application expressions, written $e_1$~$e_2$,
\item and ``atomic'' expressions
\begin{itemize}
\item Name literals, written @"n"@,
\item Qualified identifiers, written @M.N.x@, and described below,
\item Finite maps from names to lenses, written 
      @{@$n_1$@->L@~$e_1$@, @$\dots$@, @$n_k$@->L@~$e_k$@}@,      
      where each $n_i$ is a quoted name (see below) and $e_i$ is an
      expression with sort lens.
\item Trees and schemas, written @{@~$t_1$@, @$\dots$@, @$t_k$@}@, where
  each $t_i$ is a ``tree element''; i.e., either a:
\begin{itemize}

\item named atom of the form $n$@=@$e$, where $n$ is a quoted name
  (see below) and $e$ an expression,
\item or in schemas, a wildcard of the form @?=@$e$, @!=@$e$, @+=@$e$,
  @*=$e$@, or @*=@$e$, where @?@ matches trees with zero or one
  children, @!@ trees with exactly one child, @+@ trees with one or
  more children, and @*@ trees with any number of children. Each of
  these wildcards may also optionally be annotated with ``exception
  lists'' that exclude finite sets of names from the schema.  Exception
  lists are written @\(@$n_1$,\dots,$n_k$@)@; the parentheses
  enclosing the exception list may optionally be omitted. As an
  example, the schema @!\(n)=@$t$ denotes the set of trees with exactly
  one child \emph{not} named @n@ that has a subtree in $t$.

\end{itemize}
\item Trees representing lists and list schemas, written @[@$e_1$@, @$\dots$@, @$e_n$@]@,

\item Constant relational databases, written @{{ A_1(fields_1) = relation_1@,
    $\ldots$, @A_m(fields_m) = relation_m}}@, where each @fields_i@ has the
    form @x_1 ... x_k@, 
    each @relation_i@ has the form
    @{tuple_1,...,tuple_n}@, and @tuple_i@ has the form
    @(y_1 ... y_n)@.  \finish{Also relational schemas.}

\item Arbitrary expressions enclosed in parentheses (or equivalently,
  in @begin@ and @end@).

\item @protect@ expressions, which cause the enclosed expression to be
  evaluated using lazy (call-by-need) evaluation strategy instead of
  an eager strategy.

\item @assert@ expressions, which behave like the identity lens but
  performs some run-time type checking. If the \GET{} function of
  @assert T@ is invoked with a concrete argument not belonging to the
  schema @T@ or its \PUT{} direction is invoked with either argument
  not belonging to @T@, then it prints a message to this effect and
  halts the interpreter.

 @assert@ expressions take an argument with sort @schema@ and yield a lens. 
The lens checks the trees, in both directions, for membership in the schema. If the
membership test succeeds, then the entire expression behaves like the identity lens; 
otherwise the lens prints an error message and halts. 

\end{itemize}
\end{itemize}

#{#}
treeelt:
  | quoted_name                              { let i = info_of_exp $1 in 
                                                 EAtom(i, $1, mk_empty_tree i) }
  | quoted_name EQUAL exp                    { EAtom(me $1 $3,$1,$3) }
  | QMARK quoted_name EQUAL exp              { let i = me2 $1 $4 in 
                                                 EUnion(i, [ECat(i,[]); EAtom(i,$2,$4)]) }
  | bangs_opt STAR excepts_opt EQUAL exp     { EWild (me2 $2 $5,$3,$1,true,$5) }
  | PLUS excepts_opt EQUAL exp               { EWild(me2 $1 $4,$2,1,true,$4) }
  | BANG bangs_opt excepts_opt EQUAL exp     { EWild(me2 $1 $5,$3,($2 + 1),false,$5) }
  | QMARK excepts_opt EQUAL exp              { let i = me2 $1 $4 in EUnion(i,[EWild(i,$2,1,false,$4); ECat(i,[])]) }

bangs_opt:
  |                                          { 0 }
  | BANG bangs_opt                           { 1 + $2 }

/* --------------- schema helpers --------------- */
#{@} 
\subsection{Quoted Names}
\begin{grammar}
<QuotedName> ::= <Ident>
            \alt <String>
            \alt \lit{\char96} <AExp>

<QuotedNameList> ::= <QuotedName>
                \alt <QuotedName> \lit{@,@} <QuotedNameList>

\end{grammar}

\noindent Within a map, tree or schema expression, such as
@{a={},b=[]}@, the tokens appearing to the left of the ``@->@'' and
``@=@'' symbols (in maps and in trees and schemas respectively) symbols
are treated as names (string literals), not as variables. The
anti-quotation token, ``@`@'', allows one to refer to the expression
@a@, which will typically be a variable, rather than the name.

#{#}

quoted_name:
  | IDENT_or_STRING                          { EName(info_of_id $1,$1) }
  | BACKTICK aexp                            { $2 }


treeelt_list:
  | non_empty_treeelt_list                   { $1 }
  |                                          { [] }

non_empty_treeelt_list:
  | treeelt                                  { [$1] }
  | treeelt COMMA non_empty_treeelt_list     { $1::$3 }

exp_list:
  | non_empty_exp_list                       { $1 }
  |                                          { [] }

non_empty_exp_list:
  | exp                                      { [$1] }
  | exp COMMA non_empty_exp_list             { $1::$3 }

excepts_opt :
  | BACKSLASH LPAREN except_list RPAREN      { $3 }
  | BACKSLASH except_list                    { $2 }
  |                                          { [] }

except_list:
  | quoted_name                              { [$1] }
  | quoted_name COMMA except_list            { $1::$3 }

/* ---------------  identifiers --------------- */
#{@} 
\subsection{Qualified Identifiers}

\begin{grammar}
<QId> ::= <Ident>
     \alt <QId> \lit{@.@} <Ident>
\end{grammar}

\noindent An identifier may be qualified with an optional module
prefix. Thus, @M.N.x@ refers to @x@ from module @M.N@.

#{#}

qid:
  | IDENT                                    { qid_of_id ($1) }
  | qid DOT IDENT                            { dot $1 (qid_of_id $3) }

IDENT_or_STRING:
  | STRING                                  { $1 }
  | IDENT                                   { $1 }


