module Prelude = 

(* SCHEMAS *)
type Any = {*=Any}
type None = ~Any

(* re-exported native lenses *)
let probe : (name -> lens) = Native.probe
let trace : (name -> lens) = Native.trace
let assert : (type -> lens) = Native.assert
let invert : (lens -> lens) = Native.invert

let tracepoint : (name -> lens -> lens) = Native.tracepoint

let id : lens = Native.id

let const : (view -> view -> lens) = Native.const

let compose2 : (lens -> lens -> lens) = Native.compose2

let map : (lens -> lens) = Native.map

let wmap : ((name -> lens) -> lens) = Native.wmap

let xfork : (view -> view -> lens -> lens -> lens) = Native.xfork

let hoist : (name -> lens) = Native.hoist

let plunge : (name -> lens) = Native.plunge 

let copy : (name -> name -> lens) = Native.copy

let merge : (name -> name -> lens) = Native.merge

let cond_ff : (type -> type -> type -> lens -> lens -> lens -> lens -> lens) = Native.cond_ff

let cond : (type -> type -> type -> lens -> lens -> lens -> lens -> lens) = Native.cond_ff

let cond_ww : (type -> type -> type -> lens -> lens -> lens) = Native.cond_ww

let cond_fw : (type -> type -> type -> lens -> lens -> lens -> lens) = Native.cond_fw

let cond_wf : (type -> type -> type -> lens -> lens -> lens -> lens) = Native.cond_wf


let pivot : (name -> lens) = Native.pivot 

let join : (name -> name -> lens) = Native.join

let flatten : lens = Native.flatten

(* derived lenses *)
let fork (p:view) : (lens -> lens -> lens) = xfork p p

let mapp (p:view) (l:lens) : lens = fork p (map l) id 

let filter (p:view) (d:view) : lens = fork p id (const {} d)

let prune (n:name) (d:view) : lens = fork {n} (const {} {n=d}) id

let add (n:name) (v:view) : lens = xfork {} {n} (const v {} ; plunge n) id

let focus (n:name) (d:view) : lens = filter {n} d ; hoist n

let hoist_nonunique (n:name) (p:view) : lens = xfork {n} p (hoist n) id 

let acond (c:type) (a:type) (lt:lens) (lf:lens) : lens = cond_ww c <a> <~a> lt lf 

let ccond (c:type) (lt:lens) (lf:lens) : lens = cond c Any Any id id lt lf

let rename (m:name) (n:name) : lens = xfork {m} {n} (hoist m; plunge n) id

let rename_if_present (m:name) (n:name) : lens = 
  acond <{m=Any, *=Any}> <{n=Any, *=Any}>
    (rename m n)
    id



