module List = 

let hd_tag : name = Native.hd_tag
let tl_tag : name = Native.tl_tag
let nil_tag : name = Native.nil_tag

let list_tags = { hd_tag, tl_tag, nil_tag }

(* schemas *)
type Nil = Native.Nil
type Cons H T = Native.Cons H T
type List T = Nil | Cons T (List T)

let hd (d:view) : lens = 
  focus hd_tag { tl_tag = d }

let tl (d:view) : lens = 
  focus tl_tag { hd_tag = d }

let list_map (l:lens) : lens = 
  wmap { hd_tag -> l, tl_tag -> (list_map l) }

let groupby2 : lens =
  let tmp : name = "tmp" in
  let add_empty_tail : lens =
    add tl_tag {};
    wmap { tl_tag -> add nil_tag {} }
  in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename hd_tag tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique tl_tag list_tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond <{tmp=Any,nil_tag={}}> <[[Any]]>
	  ((* case (a) yeild [[tmp]] *)
	    xfork {nil_tag} {tl_tag} (plunge tl_tag) id;
            rename tmp hd_tag;
            plunge hd_tag;
	    add_empty_tail)	  
	  ((* case (b) produce [tmp,hd]::(groupby2 tl) *)
            xfork {tmp, hd_tag} {hd_tag}
              (rename hd_tag tl_tag;
	       wmap {tl_tag -> plunge hd_tag; add_empty_tail };
               rename tmp hd_tag;             
               plunge hd_tag)
              (wmap { tl_tag -> groupby2 })))
