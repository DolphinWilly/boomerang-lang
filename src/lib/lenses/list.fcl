module List = 

let HD : name = Native.hd_tag
let TL : name = Native.tl_tag
let NIL : name = Native.nil_tag

let tags = { HD, TL, NIL }

(* schemas *)
type Nil = Native.Nil
type Cons H T = Native.Cons H T
type List T = Nil | Cons T (List T)

let hd (d:view) : lens = focus HD { TL = d }

let tl (d:view) : lens = focus TL { HD = d }

let map (l:lens) : lens = wmap { HD -> l, TL -> (map l) }

let reverse : lens = 
  let tmp : name = "tmp" in
  let rotate : lens = 
    acond <[] | [Any]> <[] | [Any]>
      id
      (rename HD tmp;
       hoist_nonunique TL tags;
       xfork {tmp, TL} {TL}
	 (rename tmp HD;
	  plunge TL;
	  wmap { TL -> rotate })
	 id) 
  in
    wmap { TL -> reverse }; 
    rotate

(* FIXME? maybe change this name, it sounds like @ *)       
let append (v:view) : lens =
  acond <[]> <[Any]>
    (const v {})
    (wmap { TL -> append v })

let old_list_filter (E:type) : lens = 
  wmap { TL -> old_list_filter E };
  ccond < E :: Any >
    (tl {"error"})
    id    
    
(* filter:
 *    - v must NOT be an E
 *)
let filter (D:type) (E:type) (some_D:view) : lens =
  let filter_aux (D:type) (E:type) (some_D:view) : lens = 
    cond_ff <List E> < [] > < D::(List D) >
      (old_list_filter D)
      (append [some_D])
      (const [] [])
      (inner_filter)
  and inner_filter : lens =
    (* this Any used to be a List containing at least one D *)
    ccond < E::Any > 
      (wmap { TL -> inner_filter }; tl {"error"})
      (wmap { TL -> filter_aux D E some_D } )
  in
    filter_aux D E some_D
      
let test_filter : lens = filter < Any > < {"1"=Any} > {}

let groupby2 : lens =
  let tmp : name = "tmp" in
  let add_empty_tail : lens =
    add TL {};
    wmap { TL -> add NIL {} }
  in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename HD tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique TL tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond <{tmp=Any,NIL={}}> <[[Any]]>
	  ((* case (a) yeild [[tmp]] *)
	    xfork {NIL} {TL} (plunge TL) id;
            rename tmp HD;
            plunge HD;
	    add_empty_tail)	  
	  ((* case (b) produce [tmp,hd]::(groupby2 tl) *)
            xfork {tmp, HD} {HD}
              (rename HD TL;
	       wmap {TL -> plunge HD; add_empty_tail };
               rename tmp HD;             
               plunge HD)
              (wmap { TL -> groupby2 })))

let ungroupby2 : lens = 
  let tmp : name = "tmp" in
    acond < [] > < [] >
      id
      (acond <[[Any]]> <[Any]>
	 (focus HD {TL=[]})
	 (rename TL tmp;
	  hoist_nonunique HD tags;
	  xfork { tmp, TL } { TL }
	    (hoist_nonunique TL tags;
	     prune TL { TL=[] };
	     rename tmp TL;
	     wmap { TL -> ungroupby2 };
	     plunge TL)
	    id))
      
(* swap the first two elements of a list *)
let swap : lens = 
  let tmp = "tmp" in 
    acond < [Any] | [] > < [Any] | [] >
	id
	(rename HD tmp;
	 hoist_nonunique TL tags;
	 xfork { tmp, TL } { TL } (rename tmp HD; plunge TL) id)

let swap_all : lens = 
  swap; 
  acond < { * \ (HD,TL) = Any }::Any > < { * \ (HD,TL)=Any }::Any > 
    id 
    (wmap { HD -> swap_all, TL -> wmap { HD -> swap_all } })
       
let collapse : lens = 
  let tmp : name = "tmp" in
    ccond < [Any, Any] > 
      id
      (groupby2; plunge tmp; wmap { tmp -> collapse }; hoist tmp)

let expand : lens = 
  let tmp : name = "tmp" in
    ccond < {* \ (HD,TL) = Any }::Any > 
      id
      (ungroupby2; plunge tmp; wmap { tmp -> expand }; hoist tmp)

let fast_reverse : lens = 
  let x : name = "x" in
  let tmp : name = "tmp" in
    map (plunge x);
    collapse;
    swap_all;
    expand;
    map (hoist x)
