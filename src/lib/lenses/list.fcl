module List = 

(* names, views *)
let HD : name = Native.hd_tag
let TL : name = Native.tl_tag
let NIL : name = Native.nil_tag
let tags = { HD, TL, NIL }

(* schemas *)
type Nil = Native.Nil
type Cons H T = Native.Cons H T
type List T = Nil | Cons T (List T)

(* lenses *)
let hd (d:view) : lens = focus HD { TL = d }
let tl (d:view) : lens = focus TL { HD = d }
let map (l:lens) : lens = wmap { HD -> l, TL -> (map l) }
let reverse : lens = 
  let tmp : name = "tmp" in
  let rotate : lens = 
    acond <[] | [Any]> <[] | [Any]>
      id
      (rename HD tmp;
       hoist_nonunique TL tags;
       xfork {tmp, TL} {TL}
	 (rename tmp HD;
	  plunge TL;
	  wmap { TL -> rotate })
	 id) 
  in
    wmap { TL -> reverse }; 
    rotate

(* FIXME? maybe change this name, it sounds like the general @ *)       
let append (v:view) : lens =
  acond <[]> <[Any]>
    (const v {})
    (wmap { TL -> append v })

(* filter:
 *    - some_D must NOT be an E
 *)
let filter (D:type) (E:type) (some_D:view) : lens =
  let filter_aux (D:type) (E:type) (some_D:view) : lens = 
    cond_ff <List E> < [] > < D::(List D) >
      (plunge "_"; wmap { "_" -> filter E D {} }; hoist "_")
      (append [some_D])
      (const [] [])
      (inner_filter)
  and inner_filter : lens =
    (* this Any used to be a List containing at least one D *)
    ccond < E::Any > 
      (wmap { TL -> inner_filter }; tl {"error"})
      (wmap { TL -> filter_aux D E some_D } )
  in
    filter_aux D E some_D
      
let groupby2 : lens =
  let tmp : name = "tmp" in
  let add_empty_tail : lens =
    add TL {};
    wmap { TL -> add NIL {} }
  in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename HD tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique TL tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond <{tmp=Any,NIL={}}> <[[Any]]>
	  ((* case (a) yeild [[tmp]] *)
	    xfork {NIL} {TL} (plunge TL) id;
            rename tmp HD;
            plunge HD;
	    add_empty_tail)	  
	  ((* case (b) produce [tmp,hd]::(groupby2 tl) *)
            xfork {tmp, HD} {HD}
              (rename HD TL;
	       wmap {TL -> plunge HD; add_empty_tail };
               rename tmp HD;             
               plunge HD)
              (wmap { TL -> groupby2 })))

let ungroupby2 : lens = invert (groupby2)

(* swap the first two elements of a list *)
let swap : lens = 
  let tmp = "tmp" in 
  let tmp2 = "tmp2" in 
    acond < [Any] | [] > < [Any] | [] >
	id	   
	(rename HD tmp;
	 hoist_nonunique TL tags;
	 xfork { tmp, TL } { TL } (rename tmp HD; plunge TL) id)
	
let swap_all : lens = 
  swap; 
  acond < { * \ (HD,TL) = Any }::Any > < { * \ (HD,TL)=Any }::Any > 
    id 
    (wmap { HD -> swap_all, TL -> wmap { HD -> swap_all } })
       
let collapse : lens = 
  let tmp : name = "tmp" in
    acond < [Any, Any] > < [Any, Any] > (* WRONG *)
      id
      (groupby2; plunge tmp; wmap { tmp -> collapse }; hoist tmp)

let fast_reverse : lens = 
  let x : name = "x" in
  let tmp : name = "tmp" in
    map (plunge x);
    probe "(1)";
    collapse;
    probe "(2)";
    swap_all;
    probe "(3)"
(*
let move_odd_forward : lens = 
  let tmp : name = "tmp" in    
    xfork { HD } { HD, tmp } (hoist HD; prune TL []) id;	    
    probe "move odd forward #1";
    fork { HD } 
      ( (* make the first element a singleton list *)
      add TL []; plunge HD ) 
      ( (* make the next element a list containing tmp and TL *)
      hd [];
      rename tmp HD;
      plunge HD;
      add TL []; 
      plunge TL)

let merge_first_two : lens = 
  let elt1 = "elt1" in
  let elt2 = "elt2" in
    rename HD elt1;
    hoist_nonunique TL tags;
    rename HD elt2;
    xfork { elt1, elt2 } { HD }
      ( xfork { elt2 } { TL } ( rename elt2 HD; add TL []; plunge TL ) ( rename elt1 HD );
	plunge HD )
      id

let fixup : lens = 
  acond < [Any] > < [Any] >
    id    
    (acond < [Any]::[Any,Any]::Any > < [Any, Any]::[Any]::Any >
       move_odd_forward
       id;
     wmap { TL -> fixup })
*)
