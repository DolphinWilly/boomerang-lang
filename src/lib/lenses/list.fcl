module List = 

(* names, views *)
let HD : name = Native.hd_tag
let TL : name = Native.tl_tag
let NIL : name = Native.nil_tag
let tags = { HD, TL, NIL }

(* schemas *)
type Nil = Native.Nil
type Cons H T = Native.Cons H T
type List T = Nil | Cons T (List T)

(* lenses *)
let hd (d:view) : lens = focus HD { TL = d }
let tl (d:view) : lens = focus TL { HD = d }
let map (l:lens) : lens = wmap { HD -> l, TL -> (map l) }
let reverse : lens = 
  let tmp : name = "tmp" in
  let rotate : lens = 
    acond <[] | [Any]> <[] | [Any]>
      id
      (rename HD tmp;
       hoist_nonunique TL tags;
       xfork {tmp, TL} {TL}
	 (rename tmp HD;
	  plunge TL;
	  wmap { TL -> rotate })
	 id) 
  in
    wmap { TL -> reverse }; 
    rotate

(* FIXME? maybe change this name, it sounds like the general @ *)       
let append (v:view) : lens =
  acond <[]> <[Any]>
    (const v {})
    (wmap { TL -> append v })

(* filter:
 *    - some_D must NOT be an E
 *)
let filter (D:type) (E:type) (some_D:view) : lens =
  let filter_aux (D:type) (E:type) (some_D:view) : lens = 
    cond_ff <List E> < [] > < D::(List D) >
      (plunge "_"; wmap { "_" -> filter E D {} }; hoist "_")
      (append [some_D])
      (const [] [])
      (inner_filter)
  and inner_filter : lens =
    (* this Any used to be a List containing at least one D *)
    ccond < E::Any > 
      (wmap { TL -> inner_filter }; tl {"error"})
      (wmap { TL -> filter_aux D E some_D } )
  in
    filter_aux D E some_D
      
let groupby2 : lens = 
  let tmp : name = "tmp" in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename HD tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique TL tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond <{tmp=Any,NIL={}}> <[[Any]]>
	  ((* case (a) yeild [[tmp]] *)
	    xfork {NIL} {TL} (plunge TL) id;
            rename tmp HD;
            plunge HD;
	    add TL [])	  
	  ((* case (b) produce [tmp,hd]::(groupby2 tl) *)
            xfork {tmp, HD} {HD}
              (rename HD TL;
	       wmap {TL -> plunge HD; add TL [] };
               rename tmp HD;             
               plunge HD)
               (wmap { TL -> groupby2 })))

(*** FAST REVERSE *)
let pad : name = "pad"
  
let groupby2_w_pad : lens = 
  let tmp : name = "tmp" in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename HD tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique TL tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond < {tmp=Any,NIL={}} > < [[Any,{pad={}}]] >
	  ((* case (a) yeild [[tmp]] *)	    
	    xfork {NIL} {TL} (plunge TL) id;
            rename tmp HD;
            plunge HD;
	    add TL [{pad={}}])
	  ((* case (b) produce [tmp,hd]::(groupby2_w_pad tl) *)
            xfork {tmp, HD} {HD}
              (rename HD TL;
	       wmap {TL -> plunge HD; add TL [] };
               rename tmp HD;             
               plunge HD)
              (wmap { TL -> groupby2_w_pad })))

(* swap the first two elements of a list *)
let swap : lens = 
  let tmp = "tmp" in 
  let tmp2 = "tmp2" in 
    acond < [] | [Any] | [Any, {pad={}}] > < [] | [Any] | [Any, {pad={}}] >
	id	   
	(rename HD tmp;
	 hoist_nonunique TL tags;
	 xfork { tmp, TL } { TL } (rename tmp HD; plunge TL) id)
	
let swap_all : lens = 
  acond < { ! \ (HD,TL) = Any} > < { ! \ (HD,TL) = Any } > 
    id
    (swap; wmap { HD -> swap_all, TL -> wmap { HD -> swap_all }})
       
let collapse : lens = 
  let tmp : name = "tmp" in
    acond < [Any, Any] > < [Any, Any] > 
      id
      (groupby2_w_pad; plunge tmp; wmap { tmp -> collapse }; hoist tmp)

let fast_reverse : lens = 
  let cap = "x" in
  map (plunge cap);
  collapse;
  probe "COLLAPSED";
  swap_all;
  probe "SWAPPED";
  invert (groupby2_w_pad); 
  probe "UNCOLLAPSED"
    (*   map (hoist cap) *)
