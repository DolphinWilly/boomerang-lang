module List = 

let HD : name = Native.hd_tag
let TL : name = Native.tl_tag
let NIL : name = Native.nil_tag

let tags = { HD, TL, NIL }

(* schemas *)
type Nil = Native.Nil
type Cons H T = Native.Cons H T
type List T = Nil | Cons T (List T)

let hd (d:view) : lens = focus HD { TL = d }

let tl (d:view) : lens = focus TL { HD = d }

let map (l:lens) : lens = wmap { HD -> l, TL -> (map l) }

let groupby2 : lens =
  let tmp : name = "tmp" in
  let add_empty_tail : lens =
    add TL {};
    wmap { TL -> add NIL {} }
  in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename HD tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique TL tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond <{tmp=Any,NIL={}}> <[[Any]]>
	  ((* case (a) yeild [[tmp]] *)
	    xfork {NIL} {TL} (plunge TL) id;
            rename tmp HD;
            plunge HD;
	    add_empty_tail)	  
	  ((* case (b) produce [tmp,hd]::(groupby2 tl) *)
            xfork {tmp, HD} {HD}
              (rename HD TL;
	       wmap {TL -> plunge HD; add_empty_tail };
               rename tmp HD;             
               plunge HD)
              (wmap { TL -> groupby2 })))
