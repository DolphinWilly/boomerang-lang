#{#}
/************************************************************/
/* The Harmony Project                                      */
/* harmony@lists.seas.upenn.edu                             */
/*                                                          */
/* parser.mly - Focal parser generator                      */
/************************************************************/
/* $Id$ */

%{

open Error
open Syntax
open Info

(* imports *)
let ( @ ) = Safelist.append
let debug = Trace.debug "parser"

(* shorthands *)
let m = merge_inc
let me e1 e2 = m (info_of_exp e1) (info_of_exp e2)
let me1 e1 i2 = m (info_of_exp e1) i2
let me2 i1 e2 = m i1 (info_of_exp e2)
let mie x1 e2 = m (info_of_id x1) (info_of_exp e2)
let mis x1 s1 = m (info_of_id x1) (fst s1)
let ms s1 s2 = m (fst s1) (fst s2)
let mbs2 i1 bs2 = m i1 (info_of_bindings i1 bs2)
  
(* helpers for easy syntax tree construction *)

(* mk_compose2 exp *)
let mk_compose2_exp i e1 e2 = 
    EApp(i, EApp(i, EVar(i, compose2_qid i),e1),e2)
      
(* mk_get_exp *)
let mk_get_exp i l c = 
    EApp(i, EApp(i, EVar(i, get_qid i), l), c)

(* mk_put_exp *)
let mk_put_exp i l a co = 
  match co with 
      None -> EApp(i, EApp(i, EVar(i, create_qid i), l), a)
    | Some c -> EApp(i, EApp(i, EApp(i, EVar(i, put_qid i), l), a), c)
        
(* mk_sync_exp *)
let mk_sync_exp i lo la lb t v = 
    EApp(i,EApp(i,EApp(i,EApp(i,EApp(i,EVar(i,sync_qid i),lo),la),lb),t),v)
      
(* mk_empty_tree *)
let mk_empty_tree i = ECat(i,[])

%}

%token <Info.t> EOF 
%token <Syntax.id> IDENT STRING
%token <Info.t> LET IN FUN AND MODULE BEGIN END OPEN SCHEMA
%token <Info.t> LENS TREE TYPE NAME ARROW BACKTICK
%token <Info.t> LBRACE RBRACE LBRACK RBRACK LPAREN RPAREN
%token <Info.t> SEMI COMMA DOT EQUAL COLON BACKSLASH SLASH TEST SYNC WITH AT ERROR MISSING
%token <Info.t> STAR BANG BAR PLUS QMARK

%start modl sort qid 
%type <Syntax.modl> modl
%type <Info.t * Syntax.sort> sort
%type <Syntax.qid> qid

%%

#{@}
\renewcommand{\lit}[1]{\char96{}#1\char39{}}

\section{Syntactic Structure}

This section gives the formal definition of Focal syntax, using an
EBNF grammar. The productions for each syntactic category are followed
by a brief, informal discussion. In the rules we adopt the following
conventions:
\begin{itemize}
\item Literals are written in a typewriter font and
enclosed in single quotes, like this: \lit{@module@};

\item Non-terminals are enclosed in angle brackets, like this:
  \synt{Exp}. 

\item Optional elements are enclosed in square brackets:
  \syntax{[\lit{@:@} <Sort>]};
\item Terms may be grouped using parentheses;
\item Repeated repeated elements are specified using \syntax{*} (0 or
  more) and \syntax{+} (1 or more).
\end{itemize}
#{#}

/* ---------------  modules & declarations --------------- */
#{@}
\subsection{Modules and Declarations}

\begin{grammar}

<CompilationUnit> ::= \lit{@module@} <Ident> \lit{@=@} (\lit{@open@} <Qid>)* <Decl>*
 
#{#}

modl:
  | MODULE IDENT EQUAL opens decls EOF        { MDef(m $1 $6,$2,$4,$5) }
      
opens:
  | OPEN qid opens                           { $2::$3 }
  |                                          { [] }


#{@}

<Decl> ::= \lit{@let@} <BindingList> 
     \alt \lit{@module@} <Ident> \lit{@=@} <Decl>* \lit{@end@}
     \alt \lit{@test@} <Exp> \lit{@=@} <Exp>
     \alt \lit{@test@} <Exp> \lit{@=@} \lit{@error@}
     \alt \lit{@sync@} \lit{@with@} <AExp> \lit{@at@} <AExp> <AExp> \lit{@=@} <AExp>
     \alt \lit{@sync@} \lit{@with@} <AExp> <AExp> <AExp> \lit{@at@} <AExp> <AExp> \lit{@=@} <AExp>
\end{grammar}

\noindent A Focal compilation unit contains a single module
declaration, such as @module Foo@, that must appear in a file named @foo.fcl@.  A
module contains a sequence of @open@ declarations, which import all
the declarations from another module, followed by a sequence of
declarations. A declaration is either a @let@, a nested @module@, or a
unit test. Focal modules are currently only used to group code in a
common namespace. In particular, Focal does not yet support module
signatures or sealing.

\subsubsection{Unit Tests} \label{sec:unittests}

The syntax includes five forms of unit tests (which are only tested when
the system is run in testing mode; see
Section~\ref{sec:cmdlineargs}). The first form, @test@~$t_1$~@=@~$t_2$, 
checks that $t_1$ and $t_2$, which must both have sort @tree@, 
evaluate to equal values. This kind of test is often used to check the 
behavior of the \GET{} and \PUT{} components of
lenses, as in the following snippet: @ test id / {} = {}@. The second
form, @ test@~$l_1$~@/\@~$t_1$~@=@~$t_3$, is shorthand for two tests
of a bijective lens: @ test@~$l_1$~@/@~$t_1$~@=@~$t_2$ and 
@test@~$l_1$~@\@~$t_2$~@missing =@~$t_1$. The third form, 
@test@~$t_1$~@= error@, checks that $t_1$ raises an exception when it
evaluates $t_1$. This kind of test is uesd to ensure that native
lenses, such @hoist@, check side conditions on their inputs correctly; for example,
@ test hoist "n" {} = error@.  
The final two forms of unit tests are used to test the
behavior of the synchronization algorithm: 
\begin{center}
@sync with@~$l$~@at@~$s$~@{O=@$o$@, A=@$a$@, B=@$b$@} = {O=@~$o'$~@, A=@~$a'$~@, B=@~$b'$@}@.
\end{center}
applies $l\lgetn$ to the trees $o$, $a$, and $b$, synchronizes those
trees at schema $s$, and then applies $l\lputn$ to the results,
yielding $o'$, $a'$ and $b'$. The unit test 
\begin{center}
@sync with@~$l_o$~$l_a$~$l_b$~@at@~$s$~@{O=@$o$@, A=@$a$@, B=@$b$@} = {O=@~$o'$~@, A=@~$a'$~@, B=@~$b'$@}@.
\end{center}
is similar, but applies a different lens to $o$, $a$, and $b$.

#{#}

decls:
  | LET binding_list decls                   { DLet(mbs2 $1 $2,$2)::$3 }
  | MODULE IDENT EQUAL decls END decls       { DMod(m $1 $5,$2,$4)::$6 } 
  | TEST exp EQUAL test_res decls            { DTest(m $1 (fst $4), $2, snd $4)::$5 }
  | TEST composeexp SLASH BACKSLASH exp 
      EQUAL exp decls                        { let i = me2 $1 $7 in
                                               let get_test = DTest(i, mk_get_exp i $2 $5, (Some $7)) in
                                               let put_test = DTest(i, mk_put_exp i $2 $7 None, (Some $5)) in
                                                 get_test::put_test::$8 }
      
  | SYNC WITH aexp AT aexp aexp EQUAL 
      aexp decls                             { let i = me2 $1 $8 in
                                               let sync_test = DTest(i, mk_sync_exp i $3 $3 $3 $5 $6, Some $8) in
                                                 sync_test::$9 } 
  | SYNC WITH aexp aexp aexp AT 
      aexp aexp EQUAL aexp decls             { let i = me2 $1 $10 in
                                               let sync_test = DTest(i, mk_sync_exp i $3 $4 $5 $7 $8, Some $10) in
                                                 sync_test::$11 }
  |                                          { [] }
      
test_res:
  | exp                                      { (info_of_exp $1, Some $1) }
  | ERROR                                    { ($1, None) }

/* ---------------  bindings --------------- */
#{@}
\subsection{Bindings}

\begin{grammar}
<Binding> ::= <Ident> (<Ident>\lit{@:@}<Sort>)+ \lit{@:@} <ASort> \lit{@=@} <Exp>

<BindingList> ::= <Binding> 
             \alt <Binding> \lit{and} <BindingList>

\end{grammar}

\noindent Bindings in Focal are identical to OCaml bindings with one
additional requirement: the @let@-bound variable and the expression
must both be annotated with sorts.

#{#}

binding_list:
  | binding AND binding_list                 { $1::$3 }
  | binding                                  { [$1] }

binding:    
  | IDENT param_list COLON asort EQUAL exp   { BDef(mie $1 $6,$1,$2,Some (snd $4),$6) }
      
/* ---------------  sorts & params --------------- */
#{@}
\subsection{Sorts}

\begin{grammar}
<Sort> ::= <ASort> \lit{@->@} <Sort>
      \alt <ASort>

<ASort> ::= \lit{@lens@}
       \alt \lit{@name@}
       \alt \lit{@tree@}
       \alt \lit{@schema@}
       \alt \lit{@(@} <Sort> \lit{@)@}
\end{grammar}

\noindent Focal does not yet have a full-blown lens type
system. However, the compiler performs rudimentary sort checking. The
sorts are @lens@, @name@, @tree@, @schema@, and function sorts, of the
form $s_1$@->@$s_2$. The sort checker supports exactly one form of
subtyping: it automatically promotes trees to singleton schemas.

#{#}

sort:
  | asort ARROW sort                         { (ms $1 $3, SArrow(snd $1, snd $3)) }
  | asort                                    { $1 }

asort:
  | LENS                                     { ($1, SLens) }
  | NAME                                     { ($1, SName) } 
  | TREE                                     { ($1, STree) }
  | SCHEMA                                   { ($1, SSchema) }
  | LPAREN sort RPAREN                       { $2 }

opt_sort:
  | COLON asort                              { Some (snd $2) }
  |                                          { None }
      
param_list:
  | param param_list                         { $1::$2 }
  |                                          { [] }

param:
  | LPAREN IDENT COLON sort RPAREN           { PDef(m $1 $5, $2, snd $4) }
      
/* ---------------  expressions --------------- */
#{@}
\subsection{Expressions}

\begin{grammar}
<Exp> ::= \lit{@let@} <BindingList> \lit{@in@} <Exp>
     \alt \lit{@fun@} ([\lit{(}]<Ident>\lit{@:@}<Sort>[\lit{)}])+ [\lit{@:@}<Sort>] \lit{@->@} <Exp>
     \alt <GetPutExp>

<ExpList> ::= <Exp>
         \alt <Exp> \lit{@,@} <ExpList>

#{#}
exp: 
  | LET binding_list IN exp                  { ELet(m $1 $3,$2,$4) }
  | FUN param param_list opt_sort ARROW exp  { EFun(me2 $1 $6,$2::$3,$4,$6) }
  | getputexp                                { $1 }

#{@}

<GetPutExp> ::= <ComposeExp> \lit{@/@} <PlusExp>
           \alt <ComposeExp> \lit{@\@} <AExp> <AExp>
           \alt <ComposeExp> \lit{@\@} <AExp> \lit{@missing@}
           \alt <ComposeExp>
 
#{#}

getputexp:
  | composeexp SLASH plusexp              { mk_get_exp (me $1 $3) $1 $3 }
  | composeexp BACKSLASH aexp aexp           { mk_put_exp (me $1 $4) $1 $3 (Some $4) }
  | composeexp BACKSLASH aexp MISSING        { mk_put_exp (me1 $1 $4) $1 $3 None }
  | composeexp                               { $1 }


#{@}

<ComposeExp> ::= <ComposeExp> \lit{@;@} <BarExp>
            \alt <BarExp>

#{#}

composeexp:
  | composeexp SEMI barexp                   { mk_compose2_exp (me $1 $3) $1 $3 }
  | barexp                                   { $1 } 

#{@}

<BarExp> ::= <BarExp> \lit{@|@} <PlusExp>
        \alt <PlusExp>

#{#}

barexp:
  | barexp BAR plusexp                       { EUnion(me $1 $3,[$1;$3]) }
  | plusexp                                  { $1 }

#{@}
<PlusExp> ::= <PlusExp> \lit{@+@} <ConsExp>
         \alt <ConsExp>

#{#}

plusexp:
  | plusexp PLUS consexp                     { ECat(me $1 $3, [$1; $3]) }
  | consexp                                  { $1 }


#{@}

<ConsExp> ::= <AppExp> \lit{::} <ConsExp>
         \alt <AppExp>

#{#}
consexp:
  | appexp COLON COLON consexp               { ECons(me $1 $4, $1, $4) }
  | appexp                                   { $1 }

#{@}

<AppExp> ::= <AppExp> <AExp>
        \alt <AExp>

#{#}

appexp:
  | appexp aexp                              { EApp(me $1 $2,$1,$2) }
  | aexp                                     { $1 }

#{@}

<AExp> ::= <String>
      \alt <QId>
      \alt \lit{@{@} <MapList> \lit{@}@}
      \alt \lit{@{@} <TreeEltList> \lit{@}@}
      \alt \lit{@[@} <ExpList> \lit{@]@}
      \alt \lit{@(@} <Exp> \lit{@)@}
      \alt \lit{@begin@} <Exp> \lit{@end@}

<Map> ::= <QuotedName> \lit{@->@} <Exp>

<MapList> ::= <Map>
         \alt <Map> \lit{@,@} <MapList>

#{#}

aexp:
  | STRING                                   { EName(info_of_id $1,$1) }
  | qid                                      { EVar(info_of_qid $1,$1) }
  | LPAREN exp RPAREN                        { $2 }
  | BEGIN exp END                            { $2 }
  | LBRACE map_list RBRACE                   { EMap(m $1 $3, $2) }
  | LBRACE treeelt_list RBRACE               { ECat(m $1 $3,$2) }
  | LBRACK exp_list RBRACK                   { Safelist.fold_right
                                                 (fun ti acc -> 
                                                    ECons(me ti acc,ti,acc))
                                                 $2
                                                 (ENil($3))}      

map:
  | quoted_name ARROW exp                    { ($1,$3) }

/* maps must be non-empty to avoid overlap with schemas and trees */
map_list:
  | map                                      { [$1] }
  | map COMMA map_list                       { $1::$3 }
      

#{@}

<TreeElt> ::= <QuotedName>
         \alt [\lit{@?@}] <QuotedName> \lit{@=@} <Exp>
         \alt \lit{@*@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>
         \alt \lit{@!@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>
         \alt \lit{@?@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>
         \alt \lit{@+@} [\lit{@\@} [\lit{@(@}] <QuotedNameList> [\lit{@)@}]] \lit{@=@} <Exp>

<TreeEltList> ::= <TreeElt>
             \alt <TreeElt> \lit{@,@} <TreeEltList>

\end{grammar}

Focal expressions are identical to OCaml expressions with only a few
special forms for composing and applying lenses, and for writing down
trees and schemas. The main forms, in decreasing order of precedence, are:
\begin{itemize}
\item Full annotated @let@-expressions,
\item Anonymous $\lambda$-expressions, written 
  @fun @$x_1$@:@$s_1$~$\dots$~$x_k$@:@$s_k$~@:@$s$@-> @$e$, where each
  $x_i$ is a plain identifier and $s_i$ a sort. The parameters and
  sorts may optionally be enclosed in parentheses, and the return sort
  may be omitted.
\item get and put expressions, which apply the $\lgetn$ and $\lputn$
  components of a lens respectively. A get expression is written
  $e_1$~@/@~$e_2$, where $e_1$ has sort @lens@ and $e_2$ has sort
  @tree@. Put expressions are written $e_1$~@\@~$e_2$. 
\item Lens composition, written $e_1$@;@$e_2$,
\item Schema unions, written $e_1$~@|@~$e_2$,
\item Tree and schema concatenations, written $e_1$~@+@~$e_2$,
\item Tree and schema cons cells, written $e_1$@::@$e_2$,
\item Application expressions, written $e_1$~$e_2$,
\item and ``atomic'' expressions
\begin{itemize}
\item Name literals, written @"n"@,
\item Qualified identifiers, written @M.N.x@, and described below,
\item Finite maps from names to lenses, written 
      @{@$n_1$@->L@~$e_1$@, @$\dots$@, @$n_k$@->L@~$e_k$@}@,      
      where each $n_i$ is a quoted name (see below) and $e_i$ is an
      expression with sort lens. These maps are compiled into
      functions that map the given names to lenses and all other names
      to @id@.
\item Trees and schemas, written @{@~$t_1$@, @$\dots$@, @$t_k$@}@, where
  each $t_i$ is a ``tree element''; i.e., either a:
\begin{itemize}

\item named atom of the form $n$@=@$e$, where $n$ is a quoted name
  (see below) and $e$ an expression,
\item or in schemas, a wildcard of the form @?=@$e$, @!=@$e$, @+=@$e$,
  @*=$e$@, or @*=@$e$, where @?@ matches trees with zero or one
  children, @!@ trees with exactly one child, @+@ trees with one or
  more children, and @*@ trees with any number of children. Each of
  these wildcards may also optionally be annotated with ``exception
  lists'' that exclude finite sets of names from the schema.  Exception
  lists are written @\(@$n_1$,\dots,$n_k$@)@; the parentheses
  enclosing the exception list may optionally be omitted. As an
  example, the schema @!\(n)=@$t$ denotes the set of trees with exactly
  one child \emph{not} named @n@ that has a subtree in $t$.

\end{itemize}
\item Trees representing lists and list schemas, written @[@$e_1$@, @$\dots$@, @$e_n$@]@,
\item Arbitrary expressions enclosed in parentheses (or equivalently,
  in @begin@ and @end@).
\end{itemize}
\end{itemize}

#{#}
treeelt:
  | quoted_name                              { let i = info_of_exp $1 in 
                                                 EAtom(i, $1, mk_empty_tree i) }
  | quoted_name EQUAL exp                    { EAtom(me $1 $3,$1,$3) }
  | QMARK quoted_name EQUAL exp              { let i = me2 $1 $4 in 
                                                 EUnion(i, [ECat(i,[]); EAtom(i,$2,$4)]) }
  | STAR excepts_opt EQUAL exp               { EStar (me2 $1 $4,$2,$4) }
  | BANG excepts_opt EQUAL exp               { EBang(me2 $1 $4,$2,$4) }
  | QMARK excepts_opt EQUAL exp              { let i = me2 $1 $4 in 
						 EUnion(i, [ECat(i,[]); EBang(i,$2,$4)]) }                                                        
  | PLUS excepts_opt EQUAL exp               { let i = me2 $1 $4 in 
                                                 ECat(i,[EBang(i,$2,$4); EStar(i,$2,$4)]) }
      
/* --------------- schema helpers --------------- */
#{@} 
\subsection{Quoted Names}
\begin{grammar}
<QuotedName> ::= <Ident>
            \alt <String>
            \alt \lit{\char96} <AExp>
 
<QuotedNameList> ::= <QuotedName>
                \alt <QuotedName> \lit{@,@} <QuotedNameList>

\end{grammar}

\noindent Within a map, tree or schema expression, such as
@{a={},b=[]}@, the tokens appearing to the left of the ``@->@'' and
``@=@'' symbols (in maps and in trees and schemas respectively) symbols
are treated as names (string literals), not as variables. The
anti-quotation token, ``@`@'', allows one to refer to the expression
@a@, which will typically be a variable, rather than the name.

#{#}

quoted_name:
  | IDENT_or_STRING                          { EName(info_of_id $1,$1) }
  | BACKTICK aexp                            { $2 }


treeelt_list:
  | non_empty_treeelt_list                   { $1 }
  |                                          { [] }

non_empty_treeelt_list:
  | treeelt                                  { [$1] }
  | treeelt COMMA non_empty_treeelt_list     { $1::$3 }

exp_list:
  | non_empty_exp_list                       { $1 }
  |                                          { [] }

non_empty_exp_list:
  | exp                                      { [$1] }
  | exp COMMA non_empty_exp_list             { $1::$3 }

excepts_opt :
  | BACKSLASH LPAREN except_list RPAREN      { $3 }
  | BACKSLASH except_list                    { $2 }
  |                                          { [] }

except_list:
  | quoted_name                              { [$1] }
  | quoted_name COMMA except_list            { $1::$3 }
      
/* ---------------  identifiers --------------- */
#{@} 
\subsection{Qualified Identifiers}

\begin{grammar}
<QId> ::= <Ident>
     \alt <QId> \lit{@.@} <Ident>
\end{grammar}

\noindent An identifier may be qualified with an optional module
prefix. Thus, @M.N.x@ refers to @x@ from module @M.N@.

#{#}

qid:
  | IDENT                                    { qid_of_id ($1) }
  | qid DOT IDENT                            { dot $1 (qid_of_id $3) }

IDENT_or_STRING:
  | STRING                                  { $1 }
  | IDENT                                   { $1 }
                                             

