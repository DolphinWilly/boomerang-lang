module Cycleexamples =

let noconflict (t:view) : view =
  {O = t, A = t, B = t}

(* No changes *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {abcde},
     B = {abcde} }
  = noconflict {abcde}

(* Single change on one side *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {deabc},
     B = {abcde} }
  = noconflict {deabc}

(* Single change on both sides *)
sync with List.explode at (List.T Value)
   { O = {abcdef},
     A = {fbcdea},
     B = {adcbef} }
  = noconflict {fdcbea}

(* Block move *)
sync with List.explode at (List.T Value)
   { O = {abcdefghi},
     A = {ghiabcdef},
     B = {defabcghi} }
  = noconflict {ghidefabc}

(* More interesting change on both sides *)
sync with List.explode at (List.T Value)
   { O = {abcdef},
     A = {acbdef},
     B = {defabc} }
  = noconflict {defacb}

(* Block with negative offset *)
sync with List.explode at (List.T Value)
  { O = {abcdef},
    A = {abcdfe},
    B = {defabc} }
 = noconflict {dfeabc} 

(* Its interesting to run in debug mode and see the order in which cycles become activated, 
   from inner to outer boundary *)
sync with List.explode at (List.T Value)
  { O = {abcdefgh},
    A = {hbfdecga},
    B = {agcedfbh} }
 = noconflict {hgfedcba} 

(* Conflicting + non-conflicting changes *)
sync with List.explode at (List.T Value)
   { O = {abcdef},
     A = {fbdcea},
     B = {abcdfe} }
  =   { A =  {fbdcea} ,
        B  = {abdcfe} ,
        O = {abdcef} }

(* Conflicting changes *)
sync with List.explode at (List.T Value)
   { O = {abcdef},
     A = {fbcdae},
     B = {abcdfe} }
  =  { A =  {fbcdae} ,
       B  = {abcdfe} ,
       O = {abcdef} }


