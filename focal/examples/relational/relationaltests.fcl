module Relationaltests =

(* --------------------------------------------------------------------------- *)
(* Example from the PODS paper: *)

let orig : view =
  {{{
    Albums (Album,           Quantity) = {
           (Disintegration,  6       )
           (Show,            3       )
           (Galore,          1       )
           (Paris,           4       )
           (Wish,            5       )   }

    Tracks (Track,    Date, Rating, Album) = {
           (Lulluby,  1989, 3,      Galore)
           (Lulluby,  1989, 3,      Show) 
           (Lovesong, 1989, 5,      Galore)
           (Lovesong, 1989, 5,      Paris)
           (Trust,    1992, 4,      Wish)
    }
  }}} 

let origschema : schema =
  {{
     Albums(Album, Quantity) with {Album -> Quantity}, 
     Tracks(Track, Date, Rating, Album) with {Track -> Date, Track -> Rating}
  }}

let targetschema : schema =
  {{
     Tracks3(Track, Rating, Album, Quantity)
       with {Album -> Quantity, Track -> Rating}
       where (Quantity <> "0" /\ (Quantity <> "1" /\ Quantity <> "2"))
  }}

let l1 : lens = 
  Relational.join_dl 
    "Tracks" with {Track -> Date, Track -> Rating}
    "Albums" with {Album -> Quantity}
    "Tracks1" 

let view1 : view =
  l1 / orig

let l2 : lens =
  Relational.drop "Tracks1" "Tracks2" "Date" {Track} "unknown"

let l3 : lens =
  Relational.select "Tracks2" with {Album -> Quantity, Track -> Rating} "Tracks3"
    where (Quantity <> "0" /\ (Quantity <> "1" /\ Quantity <> "2"))

let l : lens = (l1;l2;l3)

let _ : lens = check l : origschema <<-> targetschema

let view3 : view =
  l / orig

let newtarget : view =
  {{{ Tracks3(Track, Rating, Album, Quantity) =
        {(Lovesong, 5, Disintegration, 7),
         (Lulluby, 4, Show, 3)} }}}

(* This is the example from the dblenses paper: *)
test l \ newtarget orig = 
  {{{ Albums(Album, Quantity) =
           {(Disintegration, 7),
            (Galore, 1),
            (Paris, 4),
            (Show, 3),
            (Wish, 5)},
      Tracks(Track, Date, Rating, Album) =
           {(Lovesong, 1989, 5, Disintegration),
            (Lovesong, 1989, 5, Galore),
            (Lulluby, 1989, 4, Galore),
            (Lulluby, 1989, 4, Show)} }}}

(* --------------------------------------------------------------------------- *)
(* Examples from Date: *)

(* Renamed S# to SKEY to avoid adding quotes or hacking the lexer *)
let SUPPLIERS : view =
  {{{
    S(SKEY,  SNAME,   STATUS, CITY) = {
     (S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens) }
    }}}

let S_SCHEMA : schema =
  {{
     S(SKEY, SNAME, STATUS, CITY) with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY}
  }}

(* Figure 10.1 *)

let GOOD_SUPPLIER_LENS : lens =
  Relational.select "S" with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY} "S"
    where (STATUS <> "0" /\ STATUS <> "10")
      
test GOOD_SUPPLIER_LENS / SUPPLIERS = 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S1, Smith, 20, London),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens)} }}}


(* UNION (p. 307) *)

(* The first example

      VAR UV VIEW
        (S WHERE STATUS > 25) UNION (S WHERE CITY = 'Paris') 

   cannot be expressed directly in our language, since we do not allow a single base
   table to be used more than once.  We would write this instead as a select with a 
   disjunctive predicate.
*)                                        

(* The second example (p. 308) should brings up an interesting point.  Date
   claims ("perhaps controversially") that one should never design a
   database so that the very same tuple can appear in two base relvars.
   Arguably this rule goes too far, since he also says that a view should be
   treated exactly the same as a relvar, and he is certainly allowing --
   indeed, demonstrating -- that you can have a relvar and a view sharing
   tuples.  But if pressed he might retrench and say that, at least, it is
   strange to take the UNION of two such relvars.  We would need to say
   something similar -- though what, exactly, we need to say is not yet
   clear to me.  If there are functional dependencies involved in the base
   schemas, we may violate them by taking a simple union of the tuples
   involved.  I'm not actually sure how to guard against this.  In fact,
   since UNION can be defined as a special case of a JOIN, there is
   something to be checked about our JOIN definitions too.  It seems,
   though, that Date's rule of good DB design would imply that the
   predicates of the base tables should really be disjoint, in which case we
   are fine.  (Except we have to figure out how to test for it!)
*)

(* Conclusion: I think it's fair to say that (modulo a little
   implementation) we can do the same things with unions as Date does, the
   one significant restriction being the one on using the same base table
   twice. *)


(* INTERSECTION (p. 309) *)

(* Here (again modulo a little implementation) I believe we can do *exactly*
   the same as Date. *)


(* DIFFERENCE (p. 310) *)

(* Ditto (I believe) *)


(* RESTRICT (p. 310) *)

(* Let view LS be defined as:
   
     VAR LS VIEW
         S WHERE CITY = 'London' ;
*)

let LS_SCHEMA : schema = 
  {{
     LS(SKEY, SNAME, STATUS, CITY) with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY}
     where (CITY = "London")
  }}

let LS_LENS : lens =
  assert S_SCHEMA;
  Relational.select "S" with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY} "LS"
    where (CITY = "London");
  assert LS_SCHEMA
      
test LS_LENS / SUPPLIERS = 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S1, Smith, 20, London),
        (S4, Clark, 20, London)} }}}

(* Date's examples: *)

test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S1, Smith, 20, London),
        (S6, Green, 20, London),
        (S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S1, Smith, 20, London),
       (S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens),
       (S6, Green, 20, London)} }}}

test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S1, Smith, 20, London),
        (S1, Green, 20, London),
        (S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  error

test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S1, Smith, 20, London),
        (S6, Green, 20, Athens),
        (S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  error

test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens)} }}}

test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S6, Green, 20, London),
        (S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens),
       (S6, Green, 20, London)} }}}
       
(* INTERESTING: Here we change (S1, Smith, 20, London) to 
   (S2, Smith, 20, London), which collides with the key S2 already 
   used by Jones in the source table.  According to Date, this should
   fail.  But we succeed, overwriting the source tuple for Jones with
   the new one.  Can we argue that our behavior is what is wanted?  
   (Or do we have to argue that, although it may not be, it is the best 
   we can do if we want to guarantee that PUT is total.)  We could, of
   course, define a different version of select that would not do the 
   relation merge here, instead failing on such examples. *)
test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S2, Smith, 20, London),
        (S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S2, Smith, 20, London),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens)} }}}

test LS_LENS \ 
  {{{ LS(SKEY, SNAME, STATUS, CITY) =
       {(S1, Smith, 20, Athens),
        (S4, Clark, 20, London)} }}}
  SUPPLIERS 
= 
  error


(* PROJECT (p. 311) *)

(* Date remarks that candidate keys will usually have no default values, in
   which case it does not make sense to project them away.  This corresponds
   (though not quite for the same reason) to our restriction that the DROP
   lens cannot be used on a field that determines other fields.  Our
   restriction that a field cannot be dropped if it is non-trivially
   determined by more than one other field does not correspond to anything
   in Date, but arises because of our treatment of functional dependencies
   rather than keys, which is all Date seems to have in mind (our paper
   includes a detailed argument that the lens does not make sense without
   this restriction). *)

(* Examples: Let view SC be defined as
      SC { S#, CITY }
*)

let SC_SCHEMA : schema = 
  {{
     SC(SKEY, CITY) with {SKEY -> CITY}
  }}

let SC_LENS : lens =
  assert S_SCHEMA;
  Relational.drop "S" "S'" "SNAME" {SKEY} "UNKNOWN_SNAME";
  Relational.drop "S'" "SC" "STATUS" {SKEY} "UNKNOWN_STATUS";
  assert SC_SCHEMA
      
test SC_LENS / SUPPLIERS = 
  {{{ SC(SKEY, CITY) =
       {(S1, London),
        (S2, Paris),
        (S3, Paris),
        (S4, London),
        (S5, Athens)} }}}

test SC_LENS \ 
  {{{ SC(SKEY, CITY) =
       {(S1, London),
        (S2, Paris),
        (S3, Paris),
        (S4, London),
        (S5, Athens),
        (S6, Athens)}   (* Add S6 *)
  }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S1, Smith, 20, London),
       (S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens),
       (S6, UNKNOWN_SNAME, UNKNOWN_STATUS, Athens)} }}}

test SC_LENS \ 
  {{{ SC(SKEY, CITY) =
       {(S1, London),
        (S1, Athens),    (* Add another tuple with S1 *)
        (S2, Paris),
        (S3, Paris),
        (S4, London),
        (S5, Athens)} }}}
  SUPPLIERS 
= 
  error

test SC_LENS \ 
  {{{ SC(SKEY, CITY) =
       {(S2, Paris),    (* Delete S1 *)
        (S3, Paris),
        (S4, London),
        (S5, Athens)} }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens)} }}}

(* INTERESTING: I was surprised that we got the same result as Date for this
   one.  The example is to change the CITY of S1 from London to Athens.
   Since his rules treat update operations differently from an insert
   followed by a delete, he notes that he is able to avoid filling in the
   SNAME and STATUS fields with defaults.  Since we do not treat update
   specially, one would expect that we'd wind up with the default values.
   But the relational merge in the PUT operation saves the day. *)
test SC_LENS \ 
  {{{ SC(SKEY, CITY) =
       {(S1, Athens),    (* CITY becomes Athens *)
        (S2, Paris),
        (S3, Paris),
        (S4, London),
        (S5, Athens)} }}}
  SUPPLIERS 
= 
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S1, Smith, 20, Athens),
       (S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens)} }}}

test SC_LENS \ 
  {{{ SC(SKEY, CITY) =
       {(S2, London),
        (S2, Paris),
        (S3, Paris),
        (S4, London),
        (S5, Athens)} }}}
  SUPPLIERS 
= 
  error


(* EXTEND (p. 312) *)

(* We don't current have an extend lens, so we can't do any of these
   examples.  It would not be hard to define one, operationally, but our
   schema language is not rich enough to express very interesting
   constraints (saying that the new column is computed from the values in
   the other columns) -- we could write a schema that says the two columns
   are equal, but that's all.  This limitation kind of takes the fun out of
   EXTEND. *)


(* JOIN (p. 313ff) *)

(* 
1) Date discusses the one-to-one case, but doesn't offer any concrete
   examples.  I'm skipping that for now. 

2) Our join lenses correspond very close to Date's one-to-many case: The
   typing rule demands that the shared fields must be a superkey for the
   right-hand table. 

3) We don't currently handle many-to-many joins.  This is a fundamental
   restriction of our current schema language, which cannot represent the
   fact that the target table is a join and so cannot statically capture the
   restriction that updates must always maintain its joinliness.
*)

(* Example (of one-to-many): 
    let view SSP be defined by
       S JOIN SP
*)

let SP : view = 
  {{{
    S(SKEY,  SNAME,   STATUS, CITY) = {
     (S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens) },
    SP(SKEY, PKEY, QTY) = {
     (S1, P1, 300),
     (S1, P2, 200),
     (S1, P3, 400),
     (S1, P4, 200),
     (S1, P5, 100),
     (S1, P6, 100),
     (S2, P1, 300),
     (S2, P2, 400),
     (S3, P2, 200),
     (S4, P2, 200),
     (S4, P4, 300),
     (S4, P5, 400)} }}}

let SP_SCHEMA : schema =
  {{
     S(SKEY, SNAME, STATUS, CITY) with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY},
     SP(SKEY, PKEY, QTY) with {(SKEY,PKEY) -> QTY}
  }}

let SSP_SCHEMA : schema = 
  {{
     SSP(SKEY, SNAME, STATUS, CITY, PKEY, QTY) 
     with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY, (SKEY,PKEY) -> QTY}
  }}

let SSP_LENS : lens =
  assert SP_SCHEMA;
  Relational.join_dl 
    "SP" with {(SKEY,PKEY) -> QTY}
    "S" with {SKEY -> SNAME, SKEY -> STATUS, SKEY -> CITY}
    "SSP";
  assert SSP_SCHEMA

(* Test that the GET direction yields the same view state as Date shows. *)
test SSP_LENS / SP = 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London)} }}}

test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London),
         (S4, P6, 400, Clark, 20, London)   (* Inserted *)
         } }}}
  SP 
=
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S1, Smith, 20, London),
       (S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens)},
      SP(SKEY, PKEY, QTY) =
       {(S1, P1, 300),
        (S1, P2, 200),
        (S1, P3, 400),
        (S1, P4, 200),
        (S1, P5, 100),
        (S1, P6, 100),
        (S2, P1, 300),
        (S2, P2, 400),
        (S3, P2, 200),
        (S4, P2, 200),
        (S4, P4, 300),
        (S4, P5, 400),
        (S4, P6, 400)} }}}  (* Inserted *)

test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London),
         (S5, P6, 100, Adams, 30, Athens)
         } }}}
  SP 
=
{{{ S(SKEY, SNAME, STATUS, CITY) =
    {(S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens)},  (* Inserted *)
    SP(SKEY, PKEY, QTY) =
     {(S1, P1, 300),
      (S1, P2, 200),
      (S1, P3, 400),
      (S1, P4, 200),
      (S1, P5, 100),
      (S1, P6, 100),
      (S2, P1, 300),
      (S2, P2, 400),
      (S3, P2, 200),
      (S4, P2, 200),
      (S4, P4, 300),
      (S4, P5, 400),
      (S5, P6, 100)} }}}  (* Inserted *)
  
test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London),
         (S6, P6, 100, Green, 20, London), (* Inserted *)
        } }}}
  SP 
=
{{{ S(SKEY, SNAME, STATUS, CITY) =
    {(S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens),
     (S6, Green, 20, London)}, (* Inserted *)
    SP(SKEY, PKEY, QTY) =
     {(S1, P1, 300),
      (S1, P2, 200),
      (S1, P3, 400),
      (S1, P4, 200),
      (S1, P5, 100),
      (S1, P6, 100),
      (S2, P1, 300),
      (S2, P2, 400),
      (S3, P2, 200),
      (S4, P2, 200),
      (S4, P4, 300),
      (S4, P5, 400),
      (S6, P6, 100)} }}}  (* Inserted *)

(* INTERESTING: Here is a case where our behavior diverges from Date in an
   important way.  This is the variant of the second example on p. 316 (in
   the Note...) *) 
let SP' : view = 
  {{{
    S(SKEY,  SNAME,   STATUS, CITY) = {
     (S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens) },
    SP(SKEY, PKEY, QTY) = {
     (S1, P1, 300),
     (S1, P2, 200),
     (S1, P3, 400),
     (S1, P4, 200),
     (S1, P5, 100),
     (S1, P6, 100),
     (S2, P1, 300),
     (S2, P2, 400),
     (S3, P2, 200),
     (S4, P2, 200),
     (S4, P4, 300),
     (S4, P5, 400),
     (S6, P7, 100),  (* Entries for supplier S6, *)
     (S6, P8, 100),  (* who does not appear in *)
     (S6, P9, 100)   (* the S table *)
    } }}}

(* Note that the new entries have no effect on the view state: *)
test SSP_LENS / SP' = 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London)} }}}

(* Now insert a tuple involving S6: *)
test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London),
         (S6, P6, 100, Green, 20, London), (* Inserted *)
         } }}}
  SP 
=
  {{{ S(SKEY, SNAME, STATUS, CITY) =
      {(S1, Smith, 20, London),
       (S2, Jones, 10, Paris),
       (S3, Blake, 30, Paris),
       (S4, Clark, 20, London),
       (S5, Adams, 30, Athens),
       (S6, Green, 20, London)},
      SP(SKEY, PKEY, QTY) =
       {(S1, P1, 300),
        (S1, P2, 200),
        (S1, P3, 400),
        (S1, P4, 200),
        (S1, P5, 100),
        (S1, P6, 100),
        (S2, P1, 300),
        (S2, P2, 400),
        (S3, P2, 200),
        (S4, P2, 200),
        (S4, P4, 300),
        (S4, P5, 400),
        (S6, P6, 100)}  (* Inserted (and note that the three 
                           existing tuples involving S6 are gone! *)
       }}}
(* I think Date would argue that this is wrong (and I might even agree!).
   Given the limitations of our schema language, it is probably the best we
   can do, but it is worth being up front about the issue.  An interesting
   question is whether we could do what Date expects, if we had a fancier
   schema language. *)

test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London),
         (S4, P6, 100, Clark, 20, Athens)   (* Inserted *)
      } }}}
  SP 
=
  error
  
test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S1, P1, 400, Smith, 20, London),  (* Inserted *)
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London) } }}}
  SP 
=
  error
  
(* This is another case where our behavior differs from Date, but it's a
   less interesting one.  He wants the deletion to be propagated to both
   source tables, while we delete just from SP.  But we can define another
   variant of join that does what he wants. *)
test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 300, Smith, 20, London),
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (* DELETED: (S3, P2, 200, Blake, 30, Paris), *)
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London) } }}}
  SP 
=
{{{ S(SKEY, SNAME, STATUS, CITY) =
    {(S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens)},
    SP(SKEY, PKEY, QTY) =
     {(S1, P1, 300),
      (S1, P2, 200),
      (S1, P3, 400),
      (S1, P4, 200),
      (S1, P5, 100),
      (S1, P6, 100),
      (S2, P1, 300),
      (S2, P2, 400),
      (* DELETED: (S3, P2, 200) *)
      (S4, P2, 200),
      (S4, P4, 300),
      (S4, P5, 400)} }}} 
  
(* This example shows a similar difference from Date.  Here, he comments
   that the example may fail, depending on the foreign key delete rule from
   shipments to suppliers.  We are not tracking any foreign key constraints,
   so we behave just the same as the previous example. *)
test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(* DELETED: (S1, P1, 300, Smith, 20, London), *)
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London) } }}}
  SP 
=
  {{{ S(SKEY, SNAME, STATUS, CITY) =
    {(S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens)},
    SP(SKEY, PKEY, QTY) =
     {(* DELETED: (S1, P1, 300), *)
      (S1, P2, 200),
      (S1, P3, 400),
      (S1, P4, 200),
      (S1, P5, 100),
      (S1, P6, 100),
      (S2, P1, 300),
      (S2, P2, 400),
      (S3, P2, 200),
      (S4, P2, 200),
      (S4, P4, 300),
      (S4, P5, 400)} }}}

test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 400, Smith, 20, London),  (* Updated *)
         (S1, P2, 200, Smith, 20, London),
         (S1, P3, 400, Smith, 20, London),
         (S1, P4, 200, Smith, 20, London),
         (S1, P5, 100, Smith, 20, London),
         (S1, P6, 100, Smith, 20, London),
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London) } }}}
  SP 
=
{{{ S(SKEY, SNAME, STATUS, CITY) =
    {(S1, Smith, 20, London),
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens)},
    SP(SKEY, PKEY, QTY) =
     {(S1, P1, 400),  (* Updated *)
      (S1, P2, 200),
      (S1, P3, 400),
      (S1, P4, 200),
      (S1, P5, 100),
      (S1, P6, 100),
      (S2, P1, 300),
      (S2, P2, 400),
      (S3, P2, 200),
      (S4, P2, 200),
      (S4, P4, 300),
      (S4, P5, 400)} }}}

(* INTERESTING: Here is a case where the outcome predicted by us and by Date
   is exactly the same, but where we get there in different ways.  Date says
   that updating the city in the first tuple should have the *effect* of
   updating the cities in the next five tuples.  We say, instead, that the
   relation with just the first row updated is ill formed (it does not
   satisfy the stated FDs), and it is the user's responsibility (or perhaps
   the responsibility of some editing tool that the user is using to make
   these changes) to recognize that the other rows must be changed to
   maintain the FD. *)

test SSP_LENS \ 
  {{{ SSP(SKEY, PKEY, QTY, SNAME, STATUS, CITY) =
        {(S1, P1, 400, Smith, 20, Athens), (* Updated *)
         (S1, P2, 200, Smith, 20, Athens), (* Fixed (manually by us, auto by Date) *)
         (S1, P3, 400, Smith, 20, Athens), (* Fixed (manually by us, auto by Date) *)
         (S1, P4, 200, Smith, 20, Athens), (* Fixed (manually by us, auto by Date) *)
         (S1, P5, 100, Smith, 20, Athens), (* Fixed (manually by us, auto by Date) *)
         (S1, P6, 100, Smith, 20, Athens), (* Fixed (manually by us, auto by Date) *)
         (S2, P1, 300, Jones, 10, Paris),
         (S2, P2, 400, Jones, 10, Paris),
         (S3, P2, 200, Blake, 30, Paris),
         (S4, P2, 200, Clark, 20, London),
         (S4, P4, 300, Clark, 20, London),
         (S4, P5, 400, Clark, 20, London) } }}}
  SP 
=
{{{ S(SKEY, SNAME, STATUS, CITY) =
    {(S1, Smith, 20, Athens),  (* Updated *)
     (S2, Jones, 10, Paris),
     (S3, Blake, 30, Paris),
     (S4, Clark, 20, London),
     (S5, Adams, 30, Athens)},
    SP(SKEY, PKEY, QTY) =
     {(S1, P1, 400),  (* Updated *)
      (S1, P2, 200),
      (S1, P3, 400),
      (S1, P4, 200),
      (S1, P5, 100),
      (S1, P6, 100),
      (S2, P1, 300),
      (S2, P2, 400),
      (S3, P2, 200),
      (S4, P2, 200),
      (S4, P4, 300),
      (S4, P5, 400)} }}}

