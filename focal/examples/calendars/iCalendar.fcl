module ICalendar =
 open Prelude

(*-------------------------------------------------------------------------*)
(* Concrete Schemas *)

let List_Value : schema = List.T Value 

let Bool : schema = {"#true" = {}} | {"#false" = {}}

let XPList : schema = List.T ({"name" = Value, val = List_Value})
    
let Params : schema = 
  { ?(altrepparam, cnparam, cutypeparam, dirparam, encodingparam,
      fmttypeparam, langparam, partstatparam, rangeparam, reltypeparam,
      roleparam, sentbyparam, trigrelparam, valuetypeparam) = Value,
    ?(delfromparam,deltoparam, memberparam) = List_Value,
    ?rsvpparam = Bool,
    ?tzidparam = { global = Bool, val = Value},
    ?xplist = XPList
  }

let XPListPlusVal (T : schema) : schema = {val = T, ?xplist = XPList}

let XPListPlusVal_Value : schema = XPListPlusVal Value
    
let ParamsPlusVal (T : schema) : schema = {val = T, ?params = Params}

let ParamsPlusVal_Value : schema = ParamsPlusVal Value
	
schema ICalendar = [{calprops = CalProps, components = Any}] | []
    
and CalProps = 
  { (prodid,version) = XPListPlusVal_Value,
    ?(calscale,method) = XPListPlusVal_Value,
    ?xprop = XProp}
    
and XProp = List.T {("name","val") = Value, ?params = Params}
    
and Components = 
  let Timezonec : schema = CompProp in 
    List.T ({val = Eventc | Timezonec | Todoc , type = ({"Eventc"} | {"Timezonec"} | {"Todoc"})})
    
and Eventc = {props = CompProp, ?alarms = List_CompProp}
and Todoc  = {props = CompProp, ?alarms = List_CompProp}
	
and CompProp = 
  { 
    ?(action,class,percent,priority,repeat,seq,status,transp,tzurl,uid,lurl) = XPListPlusVal_Value,
    ?(completed, created, lastmod) = XPListPlusVal DateTime,
    ?(attendee,comment,contact,related_to,tzname) = List.T (ParamsPlusVal_Value),
    ?(dtend,dtstamp,dtstart,due,recurid,trigger) = ParamsPlusVal DtPval,
    ?(tzoffsetto,tzoffsetfrom) = XPListPlusVal OffsetTime,
    ?(description,location,organizer,summary) = ParamsPlusVal_Value,
    ?attach = List.T (ParamsPlusVal ({ "AttUri" = Value } | { "AttBinary" = Value})),
    ?(categories,resources) = List.T (ParamsPlusVal (List_Value)),   
    ?(daylightc,standardc) = List_CompProp,
    ?duration = XPListPlusVal Duration,
    ?(exdate,rdate) = List.T (ParamsPlusVal (List.T DtPval)),
    ?(exrule,rrule) = List.T (XPListPlusVal Recur),
    ?geo = Geo,    
    ?rstatus = List.T RStatus,
    ?tzid = TzID,
    ?xprop = XProp
  }

and List_CompProp = List.T CompProp

and DateTime = 
      { date = {(year,month,day) = Value},
        time = {(hour,minute,second, zulu) = Value}}
	
and DtPval = 
      { "DateTimeVal" = DateTime } |
      { "DateVal" = {(year,month,day) = Value}} |
      { "PeriodVal" = Period } |
      { "DurationVal" = Duration}
      
and Period = 
      { "PeriodExplicit" = { (start, "end") = DateTime }} |
      { "PeriodStart" = { start = DateTime, duration = Duration}}
	
and Duration = { negative = Bool, length = DurLength }

and DurLength = 
      { "DurWeek" = Value } |
      { "DurTime" = { (hour,minute,second) = Value }} |
      { "DurDate" = { "Day" = Value, 
		      ?"Time"= {(hour,minute,second)}}}
	
and Recur = 
      { freq = Value,
	?(interval,wkstart) = Value,
	?(bysecond,byminute,byhour,bymonthday,byyearday,byweekno,bymonth,bysetpos) = List_Value,
	?byday = List.T ByDayElt,
	?bytext = { ("name",val) = Value},
	?"end" = { count = Value } | { until = DtPval }
      }

and ByDayElt = { weekday = Value, ?which = Value}
	
and Geo = { (latitude,longitude) = Value, ?xplist = XPList}
	
and RStatus = { code = List_Value, text = Value, ?extdata = Value, ?params = Params}
	
and TzID = { global = Bool, val = Value, ?xplist = XPList }
	
and OffsetTime = { positive = Bool, (hour,minute,second) = Value }

(*-------------------------------------------------------------------------*)
(* Abstract Schemas *)
schema XPList_A = { * = { * = {} }}

schema Params_A = { 
    ?(altrepparam,cnparam,cutypeparam,dirparam,encodingparam,fmttypeparam,langparam,
      partstatparam,rangeparam,reltypeparam,roleparam,sentbyparam,trigrelparam,
      valuetypeparam) = Value,
    ?(delfromparam,deltoparam,memberparam) = { * = {} },
    ?rsvpparam = Bool,
    ?tzidparam = { global = Bool, val = Value},
    ?xplist = XPList_A
  }

let XPListPlusVal_A (T : schema) : schema =
  { val = T, ?xplist = XPList_A} | {!\val,xplist = XPList_A}

let ParamsPlusVal_A (T : schema) : schema =
  { val = T, ?params = Params_A} | {!\val,params = {?params = Params_A}}
  
schema XProp_A = { * = {val = Value, ?params = Params_A}}

and Components_A = 
  let Timezonec_A : schema = CompProp_A in
  {?(Eventc,Todoc) = { * = (CompProp_A + {?alarms = List_CompProp_A})},
   ?Timezonec = { * = Timezonec_A}}
    
and Eventc_A = { props = CompProp_A, ?alarms = List_CompProp_A}

and Todoc_A = { props = CompProp_A, ?alarms = List_CompProp_A}
    
and CompProp_A =
      { ?(action,"class",percent,priority,status,transp,seq,repeat,tzurl,uid,url) = XPListPlusVal_A Value,	
	?(completed,created) = XPListPlusVal_A DateTime_A,
	?(attendee,comment,contact,tzname) = List.T (ParamsPlusVal_A Value),
	?(daylightc,standardc) = List_CompProp_A,
	?(description,location,organizer,summary) = ParamsPlusVal_A Value,
	?(dtend,dtstart,due,recurid,trigger) =   ParamsPlusVal_A DtPval_A,
	?(tzoffsetto,tzoffsetfrom) = XPListPlusVal_A OffsetTime_A,
	?(exdate,rdate) = List.T (ParamsPlusVal_A (List.T DtPval_A)),
	?(exrule,rrule) = List.T (XPListPlusVal_A Recur_A),
	?attach = List.T (ParamsPlusVal_A ({ "AttUri" = Value } | { "AttBinary" = Value})),
        ?(categories,resources) = List.T (ParamsPlusVal_A { * = {} }),
	?duration = XPListPlusVal_A Duration_A,
	?dtstamp = (ParamsPlusVal_A DtPval_A) | {},
	?lastmod = (XPListPlusVal_A DateTime_A) | {},
	?geo = Geo_A,
	?related_to = List.T (ParamsPlusVal_A Value),
	?rstatus = List.T RStatus_A,
	?tzid = TzID_A,
	?xprop = XProp_A
      }

and List_CompProp_A = List.T CompProp_A

and DateTime_A = 
  { date = { (year,month,day) = (Value | {}) },
    time = { (hour,minute,second,zulu) = (Value | {}) }}
	
and DtPval_A = 
  { "DateTimeVal" = DateTime_A } |
  { "DateVal" = { (year,month,day) = Value}} |
  { "PeriodVal" = Period_A } |
  { "DurationVal" = Duration_A }
      
and Period_A = 
      { "PeriodExplicit" = { (start,"end") = DateTime_A }} |
      { "PeriodStart" = { start = DateTime_A, duration = Duration_A}}
	
and Duration_A = { negative = Bool, length = DurLength_A }

and DurLength_A = 
      { "DurWeek" = Value } |
      { "DurTime" = { (hour,minute,second) }} |
      { "DurDate" = { "Day" = Value, 
		      ?"Time"= {(hour,minute,second) = Value }}}
	
and Recur_A = 
      { freq = Value,
	?(interval,wkstart) = Value,
	?(bysecond,byminute,byhour,bymonthday,byyeardy,byweekno,bymonth,bysetpos) = { * = {} },
	?byday = List.T ByDayElt_A,
	?bytext = { ("name",val) = Value },
	?"end" = { count = Value } | { until = DtPval_A }
      }

and ByDayElt_A = { weekday = Value, ?which = Value}
	
and Geo_A = { (latitude,longitude) = Value, ?xplist = XPList_A}
	
and RStatus_A = { code = { * = {} }, text = Value, ?extdata = Value, ?params = Params_A}
	
and TzID_A = Value
	
and OffsetTime_A = { positive = Bool, (hour,minute,second) = Value }

schema ICalendar_A = Components_A

(*-------------------------------------------------------------------------*)
(* And this is more to give it a try from scratch *)
(* one lens per schema variable above *)

let domCompProp : view = 
  { "action", "attach", "attendee", "categories", "class",
    "comment", "completed", "contact", "created", "daylightc", 
    "description", "dtend", "dtstamp", "dtstart", "due", "duration",
    "exdate", "exrule", "geo", "lastmod", "location", "organizer",
    "percent", "priority", "rdate", "recurid", "related_to", "repeat",
    "resources", "rrule", "rstatus", "seq", "standardc", "status",
    "summary", "transp", "trigger", "tzid", "tzname", "tzoffsetto",
    "tzoffsetfrom", "tzurl", "uid", "url", "xprop"}

let domCompPropWoLastmod : view = 
  { "action", "attach", "attendee", "categories", "class",
    "comment", "completed", "contact", "created", "daylightc", 
    "description", "dtend", "dtstamp", "dtstart", "due", "duration",
    "exdate", "exrule", "geo", "location", "organizer",
    "percent", "priority", "rdate", "recurid", "related_to", "repeat",
    "resources", "rrule", "rstatus", "seq", "standardc", "status",
    "summary", "transp", "trigger", "tzid", "tzname", "tzoffsetto",
    "tzoffsetfrom", "tzurl", "uid", "url", "xprop"}

(* some helpers *)
let flatten_hds : lens = List.flatten; map (List.hd []) 

let icalendar_lens (filtering: lens): lens =
  assert ICalendar;
  acond [] {}
    (const {} [])
    (List.hd []; (* assuming only one calendar object *)
     focus "components"
       { calprops = { prodid = { val = { "Harmony" }},
		      version = { val = { "2.0" }}}};
     protect (components_lens filtering));
  assert ICalendar_A
    
and xplistplusval_lens (l: lens) : lens =
  assert (XPListPlusVal Any);
  wmap { "val" -> l, 
         "xplist" -> protect xplist_lens };
  acond { "val" = Value, ?"xplist" = Any } { ! = {?"xplist" = XPList_A}}
    (pivot "val")
    id;
  assert (XPListPlusVal_A Any)
    
and xplist_lens : lens =
  assert XPList;
  List.map (pivot "name"; map (hoist "val"; flatten_hds));
  flatten_hds;                                                  (** check that !! this assumes that the same name doesn't appear twice in a xplist *)
  assert XPList_A
    
and xprop_lens : lens =
  assert XProp;
  List.map (pivot "name"; map (mapp {"params"} (protect params_lens)));
  flatten_hds; (** same remark as above *)
  assert XProp_A

and params_lens : lens =
  assert Params;  
  wmap { "delfromparam" -> flatten_hds,
         "deltoparam" -> flatten_hds,
         "memberparam"-> flatten_hds,             
         "xplist" -> xplist_lens };
  assert Params_A
    
and components_lens (filtering: lens) : lens =
  let k : lens = List.map (hoist_nonunique "props" domCompProp; pivot "uid"); flatten_hds in
  assert Components;
  List.map
    (acond {val = { props=Any, ?alarms=Any }, type = Any} {type = {"Eventc"}, val = Any}
       (mapp {val} (protect (eventc_lens filtering)))
       (* JNF: this branch looks redundant: Eventc is equivalent to Todoc
          (acond {val = Todoc, type = Any} {type = {"Todoc"}, val = Any} (mapp {val} (protect (todoc_lens filtering))) )*)
       (mapp {val} (protect (timezonec_lens filtering)));
     pivot "type"; map (hoist "val"));
  List.flatten;
  wmap { "Eventc" -> k, 
         "Todoc" -> k,
         "Timezonec" -> List.map (pivot "tzid"); flatten_hds };
  assert Components_A
    
and eventc_lens (filtering: lens) : lens =
  assert Eventc;
  wmap { "props" -> protect (compprop_lens filtering),
         "alarms" -> protect (List.map (compprop_lens filtering)) };
  assert Eventc_A

and todoc_lens (filtering: lens) : lens =
  assert Todoc;
  wmap { "props" -> protect (compprop_lens filtering),
         "alarms" -> protect (List.map (compprop_lens filtering))};
  assert Todoc_A
	
and compprop_lens (filtering: lens) : lens =
  let protect_map_paramsplusval_lens_id : lens = protect (List.map (paramsplusval_lens id)) in
  let protect_xplistplusval_lens_id : lens = protect (xplistplusval_lens id) in
  let protect_map_compprop_lens_filtering : lens = protect (List.map (compprop_lens filtering)) in 
  let protect_map_paramsplusval_lens_flatten_hds : lens = protect (List.map (paramsplusval_lens (flatten_hds))) in 
  let protect_xplistplusval_lens_datetime_lens : lens = protect (xplistplusval_lens datetime_lens) in 
  let protect_paramsplusval_lens_id : lens = protect (paramsplusval_lens id) in 
  let protect_paramsplusval_lens_dtpval_lens : lens = protect (paramsplusval_lens dtpval_lens) in 
  let protect_map_paramsplusval_lens_map_dtpval_lens : lens = protect (List.map (paramsplusval_lens (List.map dtpval_lens))) in 
  let protect_map_xplistplusval_lens_recur_lens : lens = protect (List.map (xplistplusval_lens recur_lens)) in 
  let protect_xplistplusval_lens_offsettime_lens : lens = protect (xplistplusval_lens offsettime_lens) in 
    assert CompProp;
    wmap { "attach"     -> protect_map_paramsplusval_lens_id,
           "attendee"   -> protect_map_paramsplusval_lens_id,
	   "comment"    -> protect_map_paramsplusval_lens_id,
	   "contact"    -> protect_map_paramsplusval_lens_id,
	   "related_to" -> protect_map_paramsplusval_lens_id,
	   "tzname"     -> protect_map_paramsplusval_lens_id,

	   "action"   -> protect_xplistplusval_lens_id,
	   "class"    -> protect_xplistplusval_lens_id,
           "percent"  -> protect_xplistplusval_lens_id,
	   "priority" -> protect_xplistplusval_lens_id,
	   "repeat"   -> protect_xplistplusval_lens_id,
	   "seq"      -> protect_xplistplusval_lens_id,
	   "status"   -> protect_xplistplusval_lens_id,
	   "transp"   -> protect_xplistplusval_lens_id,
	   "tzurl"    -> protect_xplistplusval_lens_id,
	   "uid"      -> protect_xplistplusval_lens_id,
	   "url"      -> protect_xplistplusval_lens_id,

	   "daylightc" -> protect_map_compprop_lens_filtering,
	   "standardc" -> protect_map_compprop_lens_filtering,

           "categories" -> protect_map_paramsplusval_lens_flatten_hds,
	   "resources"  -> protect_map_paramsplusval_lens_flatten_hds,

           "completed" -> protect_xplistplusval_lens_datetime_lens,
	   "created"   -> protect_xplistplusval_lens_datetime_lens,
	   "lastmod"   -> protect_xplistplusval_lens_datetime_lens,

	   "description" -> protect_paramsplusval_lens_id,
	   "location"    -> protect_paramsplusval_lens_id,
	   "organizer"   -> protect_paramsplusval_lens_id,
	   "summary"     -> protect_paramsplusval_lens_id, 

	   "dtend"   -> protect_paramsplusval_lens_dtpval_lens,
	   "dtstamp" -> protect_paramsplusval_lens_dtpval_lens,
           "dtstart" -> protect_paramsplusval_lens_dtpval_lens,
           "due"     -> protect_paramsplusval_lens_dtpval_lens,
	   "trigger" -> protect_paramsplusval_lens_dtpval_lens,
	   "recurid" -> protect_paramsplusval_lens_dtpval_lens,

	   "exdate" -> protect_map_paramsplusval_lens_map_dtpval_lens,
	   "rdate" -> protect_map_paramsplusval_lens_map_dtpval_lens,

	   "exrule" -> protect_map_xplistplusval_lens_recur_lens,
	   "rrule" -> protect_map_xplistplusval_lens_recur_lens,

	   "tzoffsetto" -> protect_xplistplusval_lens_offsettime_lens,
	   "tzoffsetfrom" -> protect_xplistplusval_lens_offsettime_lens,

	   "duration" -> protect (xplistplusval_lens duration_lens),
	   "rstatus" -> protect (List.map rstatus_lens),
	   "tzid" -> protect (tzid_lens),
	   "xprop" -> protect (xprop_lens),
	   "geo" -> protect (geo_lens)
	 };
  filtering;
  assert CompProp_A

and paramsplusval_lens (l: lens) : lens =
  assert (ParamsPlusVal Any);
  wmap { "val" -> l, "params" -> protect params_lens};
  acond {val = Value, ?params = Any} {! = {?params = Any}} (pivot "val") id;
  assert (ParamsPlusVal_A Any)
	
and datetime_lens : lens =
  assert DateTime;
  id;
  assert DateTime_A
	
and dtpval_lens : lens =
  assert DtPval; 
  wmap { "DateTimeVal" -> protect datetime_lens,
         "PeriodVal"   -> protect period_lens,
         "DurationVal" -> protect duration_lens};
  assert DtPval_A
(** rename everything to one single date here ?
   then I have to have different schemas inside
   to be able to put the right thing in the put way *)

and period_lens : lens =
  let protect_datetime_lens : lens = protect datetime_lens in 
  assert Period;  
  wmap { "PeriodExplicit" -> map (protect_datetime_lens),
         "PeriodStart"    -> wmap { "start"    -> protect_datetime_lens, 
                                    "duration" -> protect duration_lens } };
  assert Period_A
	
and duration_lens : lens =
  assert Duration;
  wmap { "length" -> protect durlength_lens };
  assert Duration_A

and durlength_lens : lens =
  assert DurLength;
  id;
  assert DurLength_A

and recur_lens : lens =
  assert Recur;
  wmap { "bysecond" -> flatten_hds,
         "byminute" -> flatten_hds,
         "byhour" -> flatten_hds,
         "bymonthday" -> flatten_hds,
         "byyearday" -> flatten_hds,
         "byweekno" -> flatten_hds, 
         "bymonth" -> flatten_hds, 
         "bysetpos" -> flatten_hds,
         "byday" -> protect (List.map bydayelt_lens),
         "bytext" -> (pivot "name"; map (hoist "val")),
         "end" -> (acond {count = Value} {count = Value} id (map dtpval_lens)) };
  assert Recur_A

and bydayelt_lens : lens =
  assert ByDayElt;
  id;
  assert ByDayElt_A
	
and geo_lens : lens =
  assert Geo;
  wmap { "xplist" -> xplist_lens };
  assert Geo_A
	
and rstatus_lens : lens =
  assert RStatus;
  wmap { "code" -> flatten_hds,
         "params" -> protect params_lens };
  assert RStatus_A
	
and tzid_lens : lens =
  assert TzID;
  pivot "val"; map ( const {} {"global" = {"#true"}});
  assert TzID_A
	
and offsettime_lens : lens =
  assert OffsetTime;
  id;
  assert OffsetTime

and timezonec_lens (filtering: lens) : lens =
  assert CompProp;
  compprop_lens filtering;
  assert CompProp_A

(*-------------------------------------------------------------------------*)
(* general lens, keeping everything in bushes *)
let l : lens = 
  icalendar_lens id

(* lens filtering away dtstamps and lastmods
   and updating them as appropriate on the putback *)
let dtstamp_lens : lens =
  wmap { "val" ->
    wmap { "DateTimeVal" -> 
      wmap { "date" ->
	wmap {
	"day" -> fconst {} "date +%d",
	  "month" -> fconst {} "date +%m",
	    "year" -> fconst {} "date +%Y"
      },
	"time" -> 
	  wmap {
	  "hour" -> fconst {} "date +%H",
	    "minute" -> fconst {} "date +%M",
	      "second" -> fconst {} "date +%S"
	} }}}

let lastmod_lens : lens =
  wmap { "lastmod" -> 
    (focus "val" {}; hoist_nonunique "date" {"day", "month", "year"};
     hoist_nonunique "time" {"hour", "minute", "second", "zulu"};
     prune "zulu" {"#true"})};
  hoist_nonunique "lastmod" {"day", "month", "year", "hour", "minute", "second"};
  fmodify "day" "date +%d"; fmodify "month" "date +%m"; fmodify "year" "date +%Y";
  fmodify "hour" "date +%H"; fmodify "minute" "date +%M"; fmodify "second" "date +%S"
    
let l_stamps : lens =
  icalendar_lens (wmap {"dtstamp" -> dtstamp_lens});
  map (map lastmod_lens)
