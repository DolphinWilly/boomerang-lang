module Sort =

let sortable (Rs:regexp List.t) : bool =
  let k = List.length{regexp} Rs in
  let sigmas = List.permutations k in
  let perm_Rs (sigma:int List.t) = List.permute{regexp} sigma Rs in
  let pRs = List.map{int List.t}{regexp List.t} perm_Rs sigmas in
  (List.for_all{regexp List.t} 
     (fun (Rs_perm:regexp List.t) -> concatable Rs_perm //) pRs) &&
  disjoint_regexps (List.map{regexp List.t}{regexp} concat_regexps pRs)

let sort_concat (ls:lens List.t where (sortable (ctypes ls))
                                   && (concatable (atypes ls) //))  
  : (lens in (union_regexps (ctypes ls))*
         <-> concat_regexps (atypes ls))
  = left_quot (sort (ctypes ls)) (concat_lenses ls)  

let ls = sort_concat #{lens}[copy /a/;copy /b/;copy /c/]
test get ls "abc" = "abc"
test get ls "cba" = "abc"
test get ls "bca" = "abc"
test get ls "bba" = error
test get ls "dba" = error
test put ls "abc" "cba" = "abc"
test ctype ls = [a-c]* (* part of the laxness of canonizers!  
                          it's actually permutations of /abc/ *)

let possible_sorts (Rs:regexp List.t) : regexp =
  let k = List.length{lens} Rs in
  let sigmas = List.permutations k in
  let compute_sort (sigma:int List.t) =
    concat_regexps (List.permute{regexp} sigma Rs) in
  let sorts = List.map{int List.t}{regexp} compute_sort sigmas in
  union_regexps sorts

let perm_sort (ls:lens List.t where 
		 (sortable (ctypes ls)) &&
	         (concatable (atypes ls) //))
  : (lens in possible_sorts (ctypes ls)
         <-> concat_regexps (atypes ls))
  =
  let k = List.length{lens} ls in
  let sigmas = List.permutations k in
  let compute_sort (sigma:int List.t) =
    permute (List.invert_permutation sigma) (List.permute{lens} sigma ls) in
  let sorted = List.map{int List.t}{lens} compute_sort sigmas in
  List.fold_left{lens}{lens}
    (fun (l_acc:lens) (sort_l:lens) ->
       l_acc || sort_l)
    (copy EMPTY) sorted

(* note precise ctypes *)
test ctype (perm_sort #{lens}[(copy /a/);(copy /b/)]) = (/ab/ | /ba/)
test ctype (perm_sort #{lens}[(copy /a/);(copy /b/);(copy /c/)]) = (/abc/ | /acb/ | /bac/ | /bca/ | /cab/ | /cba/)
test atype (perm_sort #{lens}[(copy /a/);(copy /b/);(copy /c/)]) = /abc/
 
let l4 = perm_sort #{lens}[(copy "a");
			   (copy "b");
			   (copy "c");
			   (copy "d")]
      
test l4.get "abcd" = "abcd"
test l4.get "abdc" = "abcd"
test l4.get "acbd" = "abcd"
test l4.get "acdb" = "abcd"
test l4.get "adbc" = "abcd"
test l4.get "adcb" = "abcd"
test l4.get "bacd" = "abcd"
test l4.get "badc" = "abcd"
test l4.get "bcad" = "abcd"
test l4.get "bcda" = "abcd"
test l4.get "bdac" = "abcd"
test l4.get "bdca" = "abcd"
test l4.get "cabd" = "abcd"
test l4.get "cadb" = "abcd"
test l4.get "cbad" = "abcd"
test l4.get "cbda" = "abcd"
test l4.get "cdab" = "abcd"
test l4.get "cdba" = "abcd"
test l4.get "dabc" = "abcd"
test l4.get "dacb" = "abcd"
test l4.get "dbac" = "abcd"
test l4.get "dbca" = "abcd"
test l4.get "dcab" = "abcd"
test l4.get "dcba" = "abcd"
