\section{The Standard Prelude}

The lenses and schemas described in this section are available by default
and need not be qualified with a module name.
%
For the sake of coherent grouping, some of the unit tests and derived forms
mention lenses that are only defined later in the section.

#{#}
module Prelude = 

(* Documentation for these comes later, but we need to use them earlier: *)
let invert : (lens -> lens) = Native.Prelude.invert
let hoist : (name -> lens) = Native.Prelude.hoist
let xfork : (tree -> tree -> lens -> lens -> lens) = Native.Prelude.xfork
let cond : (schema -> schema -> schema -> lens -> lens -> lens -> lens -> lens) = Native.Prelude.cond
let acond : (schema -> schema -> lens -> lens -> lens) = Native.Prelude.acond
let wmap : ((name -> lens) -> lens) = Native.Prelude.wmap
#{@}

\subsection{Predefined Schemas}

\LENSSECTION{Any}
The schema @Any@ denotes the set of all trees.
##let Any : schema = Native.Prelude.Any

\LENSSECTION{Empty}
The schema @Empty@ denotes the empty set of trees.
##let Empty : schema = Native.Prelude.Empty

\LENSSECTION{KeyedTree}
A ``keyed'' tree consists of a single name pointing to some subtree.
#*let KeyedTree (X:schema) : schema = {!=X}

\LENSSECTION{Value}
The schema @Value@ describes trees with just one child pointing to an empty
tree:
#*let Value : schema = KeyedTree {}

\subsection{Generic Lenses}

\LENSSECTION{id}
The \LN{id} lens returns its concrete argument unchanged in the \GET{} 
direction and its abstract argument unchanged in the \PUT{} direction.
##let id : lens = Native.Prelude.id
##test id / \ {} = {}
#*test id / \ {a={b}} = {a={b}}

\LENSSECTION{const}
##let const : (tree -> tree -> lens) = Native.Prelude.const
The lens \LN{const} \(t\) \(d\)  always return the tree \(t\) in the \GET{} 
direction. 
#*test const {a} {b} / {} = {a}
#*test const {}  {b} / {a} = {}
In the \PUT{} direction, it is only defined if the abstract tree 
has not changed (if it is exactly \(t\)). 
#*test const {a} {b} \ {b} {} = error
##test const {a} {b} \ {b} missing = error
In this case, it returns the original 
concrete tree if there is one, and the default tree \(d\) otherwise.
#*test const {a} {b} \ {a} {} = {}
#*test const {a} {b} \ {a} {c} = {c}
#*test const {a} {b} \ {a} missing = {b}

\LENSSECTION{;} The lens composition operation is written as an infix
semicolon.  In the \GET{} direction, @l;k@ simply applies the \GET{}
component of @l@ followed by the \GET{} component of @k@.  In the other
direction, the two {\PUT} functions are applied in turn: first, the {\PUT}
function of @k@ is used to put the abstract tree $a$ into the concrete tree
that the {\GET} of @k@ was applied to, i.e., $@l@ \lget{c}$; the result of
this \PUT{} is then put into $c$ using the {\PUT} function of @l@.  (If the
concrete tree $c$ is @missing@, then, $@l@ \lget{c}$ is also defined to be
@missing@, so the effect of $@l;k@ \lputn a\ @missing@$ is to use @k@ to put
$a$ into @missing@ and then @l@ to put the result into @missing@.)
#*test (hoist "x"; hoist "y") / \ {x = {y = {z}}} = {z}
A similar test case using two instances of @const@ illustrates the strong
schema constraint imposed by @const@ (the second argument of the
second @const@ {\em must} be @{d}@).
##test (id; id) /\ {a} = {a}
##test (id; const {a} {d}) / {} = {a}
#*test (const {a} {d}; const {b} {a}) / {} = {b}
##test (id; const {a} {b}) \ {a} missing = {b}
##test (id; const {a} {b}) \ {a} {} = {}
#*test (const {a} {d}; const {b} {a}) \ {b} {foo,bar} = {foo,bar}
#*test (const {a} {d}; const {b} {a}) \ {b} missing = {d}
#*test (const {a} {d}; const {b} {foo}) \ {b} missing = error

\subsection{Forking Lenses}

#@\LENSSECTION{xfork} 
%
The lens combinator \LN{xfork} applies different
lenses to different parts of a tree: it splits the tree into two parts
according to the names of its immediate children, applies a different lens
to each, and concatenates the results.  
%
Formally, \LN{xfork} takes as arguments two sets of names and two lenses.
For example:
#*test (xfork {a} {x,y,z} (hoist "a") id)  / {a={x,y}, b={z}, c} = {x,y,b={z},c}
%
(Note that sets of names are represented syntactically as trees of
values.)
The first set of names, @{a}@, specifies how concrete
trees should be split: in the \GET{} direction, the input tree (here 
@{a={x,y},b={z},c}@) is split into a tree with just the top-level edge labeled
@a@ (i.e., @{a={x,y}}@), which is passed through  
@hoist "a"@, and a tree with the edges @b@ and @c@ (i.e., @{b={z},c}@),
which is passed through @id@.  The resulting trees (@{x,y}@ and @{b={z},c}@)
are merged to form the result.  

The second set of names, @{x,y,z}@, specifies that only the names @x@, @y@,
and @z@ may appear at the top level in the tree returned by the first
\GET{}, and also that these three names may {\em not} appear at the top
level in the tree returned by the second \GET{}; these conditions ensure
that the final merge always makes sense.
#*test (xfork {a} {x} (hoist "a") id)  / {a={x,y}, b={z}, c} = error
#*test (xfork {a} {x,y,z,b,c} (hoist "a") id)  / {a={x,y}, b={z}, c} = error

The \PUT{} direction of @xfork@ works similarly: the concrete argument is
split according to the first set of names, the abstract argument according
to the second set of names, the two lenses are applied to the corresponding
pairs of constituent trees, and the results are merged.  Again, the \PUT{}
direction of the first lens must always yield trees whose top-level names
fall in the first set, and the second lens must yield trees whose names fall
in the second set.
#*test (xfork {a} {x,y,z} (hoist "a") id)  
#*        \ {x, z={foo}, b, d} 
#*          {a={x,y}, b, c} 
#*      = {a={x,z={foo}}, b, d}

##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) / {x} + {y} = {a,b}
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) / {x} + {} = {a,b}
##test (xfork {x} {a} (const {a} {x}) id) / {x,y} = {a,y}
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) / {} = {a,b}
##test (xfork {x} {a} (const {a} {x}) id) / {} = {a}
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) \ {a,b} {} = {}
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) \ {a,b} {b} = {b}
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) \ {a,b} missing = {a,x}
##test (xfork {x} {a} (const {b} {a}) id) / {} = error
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) \ {} missing = error
##test (xfork {x} {a} (const {a} {x}) (const {b} {a})) \ {a} missing = error

\LENSSECTION{fork}
Often, the two sets of names passed to @xfork@ are the same.  The derived
lens @fork@ packages this case for convenience:
#*let fork (p:tree) (l1:lens) (l2:lens) : lens = xfork p p l1 l2

##test (fork {x} (const {b} {x}) (const {b} {b})) / {x} = error
##test (fork {x} (const {b} {b}) id) \ {b} {x} = error

\subsection{Lenses for Structural Transformations on Trees}

#@\LENSSECTION{hoist}
The lens \LN{hoist} $n$ is used to shorten a tree by removing an edge at
the top.  In the {\GET} direction, it expects a tree that has exactly one
child, named $n$.  It returns this child, removing the edge $n$. In the
\PUT{} direction, the value of the old concrete tree is ignored and a new
one is created, with a single edge $n$ pointing to the given abstract tree.
%
##(* Actually defined above *)
#*test (hoist "n") /\ {n} = {}
#*test (hoist "n") /\ {n={a}} = {a}
It is an error to apply \LN{hoist} $n$ to a concrete tree whose domain is
not exactly $n$.
#*test (hoist "n") / {} = error
#*test (hoist "n") / {a} = error
##test (hoist "n") \ {a} missing = {n={a}}
##test (hoist "n") \ {} missing = {n}

\LENSSECTION{hoist@_@nonunique}
The derived lens @hoist_nonunique@ $n$ is a generalized variant of @hoist@ that
removes the restriction that its concrete argument have domain exactly $n$.
%
#*let hoist_nonunique (n:name) (p:tree) : lens = xfork {`n} p (hoist n) id 
%
It takes an extra argument, a set of names represented as a tree, specifying
the possible names of top-level edges in the subtree reached under $n$,
which must be disjoint from the names of top-level edges other than~$n$.
%
#*test (hoist_nonunique "n" {a,b,c}) /\ {n={a},x={b}} = {a, x={b}}

##test (hoist_nonunique "x" {a}) / {} = error
##test (hoist_nonunique "x" {a}) / {x={a=[]}, y=[{1},{2},{3}]} = {a=[], y=[{1},{2},{3}]}
##test (hoist_nonunique "x" {a}) \ {a=[{1},{2},{3}], y=[{4},{5},{6}]} missing = {x={a=[{1},{2},{3}]}, y=[{4},{5},{6}]}
##test (hoist_nonunique "x" {a}) \ {a=[{1},{2},{3}], y=[{4},{5},{6}]} {x={a}} = {x={a=[{1},{2},{3}]}, y=[{4},{5},{6}]}
##test (hoist_nonunique "x" {a}) \ {} missing = {x}

#@\LENSSECTION{plunge}
The lens @plunge n@, defined as 
#* let plunge (n:name) : lens = invert (hoist n)
is the exact inverse of @hoist n@.  
#*test (plunge "n") /\ {a} = {n={a}}
## test (plunge "n") /\ {} = {n}
## test (plunge "n") \ {n={a}} missing = {a}
## test (plunge "n") \ {n={a}} {} = {a}
## test (plunge "n") \ {n} {a} = {}
## test (plunge "n") \ {a} missing = error
## test (plunge "n") \ {a} {} = error
## test (plunge "n") \ {n,a} missing = error


\LENSSECTION{filter}
The @filter@ lens allows all but a given set of children (specified as a
tree) to be projected away in the \GET{} direction and restored in the
\PUT{} direction. 
#*let filter (p:tree) (d:tree) : lens = fork p id (const {} d)

#*test (filter {x,y,z} {new}) / {x,y,a,b,c} = {x,y}
#*test (filter {x,y,z} {new}) \ {x,z} {x,y,a,b,c} = {x,z,a,b,c}
The second argument to @filter@ is a tree (with top-level names not in the
given set) that is used as a default value for the projected away part of
the tree in the case where the \PUT{} part of @filter@ is applied to
@missing@.   
#*test (filter {x,y,z} {new}) \ {x,y} missing = {x,y,new}

##test (filter {x} {y}) / {} = {}
##test (filter {x} {y}) / {y,x} = {x}
##test (filter {x} {y}) \ {} missing = {y}
##test (filter {x} {y}) \ {} {y={1}} = {y={1}}

\LENSSECTION{focus}
The lens @focus@ $n$ $d$, defined as
#*let focus (n:name) (d:tree) : lens = filter {`n} d ; hoist n
projects away all the top-level names except $n$ (restoring them in the
\PUT{} direction) and then hoists the children of $n$ up to the top level. 
#*test (focus "n" {new}) / {x={a},n={b={c}}} = {b={c}}
#*test (focus "n" {new}) \ {b={d},e} {x={a},n={b={c}}} = {x={a},n={b={d},e}} 
As for @filter@, the second argument is used when the \PUT{} direction of
@focus@ is applied to @missing@.
#*test (focus "n" {new}) \ {b={d},e} missing = {n={b={d},e}, new} 

##test (focus "a" {}) / {a=[{1},{2},{3}], b=[{4},{5},{6}]} = [{1},{2},{3}]
##test (focus "a" {}) \ {} missing = {a}
##test (focus "a" {}) \ [{7},{8},{9}] {a=[{1},{2},{3}], b=[{4},{5},{6}]} = {a=[{7},{8},{9}], b=[{4},{5},{6}]}
##test (focus "a" {}) / {} = error
##test (focus "a" {}) / {b} = error
##test (focus "a" {}) \ [{1},{2},{3}] {b=[{4},{5},{6}]} = {a=[{1},{2},{3}], b=[{4},{5},{6}]} (*FIXME -> error *)

\LENSSECTION{prune}
The lens @prune@ $n$ removes just the name $n$ in the \GET{} direction (if
it is present) and restores it in the \PUT{} direction.
#*let prune (n:name) (d:tree) : lens = fork {`n} (const {} {`n=d}) id

#*test (prune "n" {new}) / {} = {}
#*test (prune "n" {new}) / {n={a},m={b}} = {m={b}}
#*test (prune "n" {new}) \ {m={c},d} {n={a},m={b}} = {n={a}, m={c}, d} 
#*test (prune "n" {new}) \ {m={c},d} missing = {n={new}, m={c}, d} 

##test (prune "a" []) / {} = {}
##test (prune "a" []) / {a={1}, b={2}} = {b={2}}
##test (prune "a" []) \ {b={2}} missing = {a=[], b={2}}
##test (prune "a" []) \ {b={2}} {a={1}, b={3}} = {a={1}, b={2}}
##test (prune "a" []) \ {a} missing = error

\LENSSECTION{add}
The lens @add@ $n$ $v$ adds a new subtree $v$ named $n$ in the \GET{}
direction and removes it in the \PUT{} direction.  
#*let add (n:name) (v:tree) : lens = xfork {} {`n} (const {`n=v} {}) id

#*test (add "n" {x}) / \ {a={z}} = {a={z},n={x}}

##test (add "a" []) / {} = {a=[]}
##test (add "a" []) / {b} = {a=[], b}
##test (add "a" []) \ {a=[], b=[{1},{2},{3}]} missing = {b=[{1},{2},{3}]}
##test (add "a" []) \ {a=[], b=[{1},{2},{3}]} {} = {b=[{1},{2},{3}]}
##test (add "a" []) / {a} = error
##test (add "a" []) \ {} missing = error
##test (add "a" []) \ {a} {a} = error

\LENSSECTION{rename}
The lens @rename@ $m$ $n$ renames $m$ to $n$ in the \GET{} direction and $n$
to $m$ in the \PUT{} direction.
#*let rename (m:name) (n:name) : lens = xfork {`m} {`n} (hoist m; plunge n) id

#*test (rename "m" "n") /\ {m={a}, x={b}} = {n={a}, x={b}}

##test (rename "x" "y") / {x={1}} = {y={1}}
##test (rename "x" "y") / {x={1}, z={2}} = {y={1}, z={2}}
##test (rename "x" "y") \ {y={1}} missing = {x={1}}
##test (rename "x" "y") \ {y={1}, z={2}} missing = {x={1}, z={2}}
##test (rename "x" "y") / {} = error
##test (rename "x" "y") / {y} = error 
##test (rename "x" "y") \ {} missing = error
##test (rename "x" "y") \ {x} missing = error

\LENSSECTION{rename_if_present}
The lens @rename_if_present@ $m$ $n$ is just like @rename@ $m$ $n$ except
that it does not 
demand that its concrete argument actually possess a subtree named $m$ or
that its abstract argument possess a subtree named $n$.
#*let rename_if_present (m:name) (n:name) : lens = 
#*  acond {`m=Any, *=Any} {`n=Any, *=Any}
#*    (rename m n)
#*    id

#*test (rename_if_present "m" "n") /\ {m={a}, x={b}} = {n={a}, x={b}}
#*test (rename_if_present "m" "n") /\ {x={b}} = {x={b}}
#*test (rename "m" "n") / {x={b}} = error

##test (rename_if_present "x" "y") / {} = {}
##test (rename_if_present "x" "y") / {x={1}} = {y={1}}
##test (rename_if_present "x" "y") / {x={1}, z={2}} = {y={1}, z={2}}
##test (rename_if_present "x" "y") \ {y={1}} missing = {x={1}}
##test (rename_if_present "x" "y") \ {y={1}, z={2}} missing = {x={1},z={2}}
##test (rename_if_present "x" "y") \ {x={1}} missing = {x={1}}
##(* should we put an assert to catch this?
##   test (rename_if_present "x" "y") / {y={1}} = {y={1}}
##*)

#@\LENSSECTION{pivot}
The lens @pivot@ $k$ performs a ``rotation'' on the root of the tree, taking
a tree of the form @{k={x}}+w@ to one of the form @{x=w}@---i.e., promoting
the value under $k$ to the top so that it becomes a key for the remaining
children, @w@.  
%
##let pivot : (name -> lens) = Native.Prelude.pivot 
##test (pivot "k") / {} = error
#*test (pivot "k") / \ {k={x},a,b={c}} = {x={a,b={c}}}
##test (pivot "k") / {k={x={y}}} = error
##test (pivot "k") / {k={x}, a=[{1}], b=[{2}]} = {x={a=[{1}], b=[{2}]}}
##test (pivot "k") \ {x={a=[{1}], b=[{2}]}} missing = {k={x}, a=[{1}], b=[{2}]}
##test (pivot "k") \ {x, y} missing = error
##test (pivot "k") \ {x={k=[{0}]}, a=[{1}]} missing = error
%
The most common use of @pivot@ is in the idiom 
%
@List.map (pivot "k"); List.flatten@. 

\subsection{Mapping Lenses}

\LENSSECTION{map} 
##let map : (lens -> lens) = Native.Prelude.map
%
The lens @map l@ applies @l@ to each of the {\em children}
of the argument tree.  In the {\GET} direction, it applies $l\lgetn$ to each
{subtree} of the root and combines the results together into a new tree.
#*test (map (const {x} {new})) / {a={b},c} = {a={x},c={x}}
In the \PUT{} direction, there are three cases to consider.
\begin{enumerate}
\item Names that appear only in the concrete tree (i.e., they have been
deleted in the abstract tree) are deleted in the resulting concrete tree.
#*test (map (const {x} {new})) \ {a={x}} {a={b},c} = {a={b}}
\item Names that appear only in the abstract tree (i.e., they have been
created) are put back into @missing@.
#*test (map (const {x} {new})) \ {a={x}} {} = {a={new}}
\item For names that appear in both the concrete and abstract arguments,
the \PUT{} direction of @l@ is applied to corresponding subtrees.
#*test (map (const {x} {new})) \ {a={x}} {a={b},c} = {a={b}}
#*test (map (plunge "n")) \ {a={n={x,foo}}} {a={x}} = {a={x,foo}} 
\end{enumerate}

##test (map id) /\ {} = {}
##test (map id) \ {} missing = {}
##test (map id) / {x, y=[{1},{2},{3}]} = {x, y=[{1},{2},{3}]}
##test (map (const {a} {b})) / {x, y=[{1},{2},{3}]} = {x={a}, y={a}}
##test (map (const {a} {b})) \ {x={a}, y={a}} missing = {x={b}, y={b}}
##test (map (const {a} {b})) \ {x={a}, y={a}} {y=[{1},{2},{3}]} = {x={b}, y=[{1},{2},{3}]}
##test (map (const {a} {b})) \ {x={c}} missing = error

\LENSSECTION{mapp}
The lens @mapp p l@ is just like @map l@ except that it ignores subtrees
whose names are not in the set @p@ (which is specified as a tree).
#*let mapp (p:tree) (l:lens) : lens = fork p (map l) id 

#*test (mapp {a,b} (const {x} {new})) / {a={b},c} = {a={x},c}

##test (mapp {a} (const {b} {b})) / {} = {}
##test (mapp {a} (const {b} {b})) / {a,b={2}} = {a={b}, b={2}}
##test (mapp {a} (const {b} {b})) \ {a={b}, b={2}} missing = {a={b}, b={2}}
##test (mapp {a} (const {b} {b})) \ {a={b}, b={2}} {a={1},b={3}} = {a={1}, b={2}}

#@\LENSSECTION{wmap} 
%
The @wmap@ combinator is a generalized variant of @map@ that can apply a
{\em different} lens to each subtree.  Its argument is a function from names
to lenses (see Section~\ref{sec:functionsfromnamestolenses}).  
#*test (wmap (fun (y:name) -> plunge y)) / {a,b={foo}} = {a={a}, b={b={foo}}}
#*test (wmap { a -> const {x} {new}, b -> plunge "n" }) 
#*        / {a,b={foo}} 
#*        = {a={x}, b={n={foo}}}

##test (wmap { y -> const {a} {b}}) / {} = {}
##test (wmap { y -> const {a} {b}}) \ {} missing = {}
##test (wmap { y -> const {a} {b}}) \ {} {1,2,3} = {}
##test (wmap { y -> const {a} {b}}) / {x, y={1,2,3}} = {x, y={a}}
##test (wmap { y -> const {a} {b}}) \ {x, y={a}} missing = {x, y={b}}
##test (wmap { y -> const {a} {b}}) \ {x={a}} {x,y=[{1},{2},{3}]} = {x={a}}
##test (wmap { y -> const {a} {b}}) \ {y={a}} {x,y=[{1},{2},{3}]} = {y=[{1},{2},{3}]}
##test (wmap { y -> const {a} {b}}) \ {y={a}, z={c}} {x,y=[{1},{2},{3}]} = {y=[{1},{2},{3}], z={c}}


\subsection{Conditional Lenses}

\LENSSECTION{ccond} 
The ``concrete conditional'' @ccond C lt lf@ tests whether its concrete
argument belongs to the schema @C@, acting like @lt@ if so and @lf@ if not,
in both \GET{} and \PUT{} directions.   
##let ccond (C:schema) (lt:lens) (lf:lens) : lens = cond C Any Any id id lt lf

#*test (ccond {a=Any} (hoist "a") id) / {a={x}} = {x}
#*test (ccond {a=Any} (hoist "a") id) \ {y,z} {a={x}} = {a={y,z}}
#*test (ccond {a=Any} (hoist "a") id) / {b={x}} = {b={x}}
#*test (ccond {a=Any} (hoist "a") id) \ {y,z} {b={x}} = {y,z}

Note that, to ensure well-behavedness, the lenses @lt@ and @lf@ must have
exactly the same range.  That is, if @T@ is the entire set of trees that the
lens @ccond C lt lf@ is ever going to be applied to, then the set of
possible results of the \GET{} direction of @lt@ when applied to trees in
@C@ should coincide with the set of possible results of the \GET{} direction
of @lf@ when applied to trees in $@T@\setminus @C@$.  See~\cite{Focal2005}
for more discussion of this point.

##test (ccond {a=Any} (const {b} {a}) (const {} {}; plunge "b")) / {a={1}} = {b}
##test (ccond {a=Any} (const {b} {a}) (const {} {}; plunge "b")) / {c={2}} = {b}
##test (ccond {a=Any} (const {b} {a}) (const {} {}; plunge "b")) \ {b} missing = {}
##test (ccond {a=Any} (const {b} {a}) (const {} {}; plunge "b")) \ {b} {c={2}} = {c={2}}
##test (ccond {a=Any} (const {b} {a}) (const {} {}; plunge "b")) \ {b} {a={3}} = {a={3}}
##test (ccond {a=Any} (const {b} {a}) (const {} {}; plunge "b")) \ {a} missing = error

\LENSSECTION{acond}
The ``abstract conditional'' @acond C A lt lf@ tests its concrete argument
against the schema @C@ in the \GET{} direction and tests its abstract
argument against the schema @A@ in the \PUT{} direction, sending its
arguments through @lt@ or @lf@ in each case.

#*let acond_test : lens = acond {a=Any,b=Any} {a=Any} (filter {a} {new}) id

#*test acond_test / {a={x},b={y}} = {a={x}}
#*test acond_test / {a={x},c={z}} = {a={x},c={z}}
#*test acond_test / {} = {}

#*test acond_test \ {a={foo}} {a={x},b={y}} = {a={foo},b={y}} 
#*test acond_test \ {a={foo},c={z}} {a={x},b={y}} = {a={foo},c={z}} 
#*test acond_test \ {a={foo}} {a={x}} = {a={foo},new} 
(The final example shows an important detail: if the \PUT{} of 
%
@acond C A lt lf@ is applied to a tree @a@ that {\em does} belong to @A@
together with a tree @c@ that does {\em not} belong to @C@, then the \PUT{}
of @lt@ is used to put @a@ into @missing@.)


##test (acond {a=Any} {b=Any} (const {b} {a}) (const {a} {b})) / {} = {a}
##test (acond {a=Any} {b=Any} (const {b} {a}) (const {a} {b})) / {a={1}} = {b}
##test (acond {a=Any} {b=Any} (const {b} {a}) (const {a} {b})) \ {b} missing = {a}
##test (acond {a=Any} {b=Any} (const {b} {a}) (const {a} {b})) \ {b} {a={1}} = {a={1}}

Note that the lenses @lt@ and @lf@ should have disjoint ranges.  If @T@ is
the entire set of trees that the lens @acond C A lt lf@ is ever going to be
applied to, then the set of possible results of the \GET{} direction of @lt@
when applied to trees in @C@ should be exactly @A@, and the set of possible
results of the \GET{} direction of @lf@ when applied to trees in
$@T@\setminus @C@$ should be disjoint from @A@.

\LENSSECTION{cond} %
The lens combinator @cond@ is a ``generalized conditional.''  It is seldom
used by itself---most often, either @ccond@ or @acond@ suffices---but
occasionally its full power is needed.  Please see~\cite{Focal2005} for more
details.  (The standard prelude also provides four variants, called
@cond_ww@, @cond_fw@, @cond_wf@, @cond_ff@, that treat the ``fixup
functions'' in slightly different ways.  For details, read the source.)

##let cond_ww : (schema -> schema -> schema -> lens -> lens -> lens) = Native.Prelude.cond_ww
##let cond_fw : (schema -> schema -> schema -> lens -> lens -> lens -> lens) = Native.Prelude.cond_fw
##let cond_wf : (schema -> schema -> schema -> lens -> lens -> lens -> lens) = Native.Prelude.cond_wf
##let cond_ff : (schema -> schema -> schema -> lens -> lens -> lens -> lens -> lens) = cond
##test (cond_ww {a=Any} {a=Any} {b=Any} (const {a} {a}) (const {b} {b})) / {a=[{1}]} = {a}
##test (cond_ww {a=Any} {a=Any} {b=Any} (const {a} {a}) (const {b} {b})) / {b=[{2}]} = {b}
##test (cond_ww {a=Any} {a=Any} {b=Any} (const {a} {a}) (const {b} {b})) \ {a} {a=[{1}]} = {a=[{1}]}
##test (cond_ww {a=Any} {a=Any} {b=Any} (const {a} {a}) (const {b} {b})) \ {a} missing = {a}
##test (cond_ww {a=Any} {a=Any} {b=Any} (const {a} {a}) (const {b} {b})) \ {a} {b=[{2}]} = {a}
##test (cond_ww {a=Any} {a=Any} {b=Any} (const {a} {a}) (const {b} {b})) \ {} missing = error

\subsection{Merging and Copying Lenses}

#@\LENSSECTION{merge} %
It sometimes happens that a concrete representation requires equality
between two distinct subtrees within a view.  A \LN{merge} lens is one way
to preserve this invariant when the abstract view is updated.  In the \GET{}
direction, \LN{merge} takes a tree with two (equal) branches and
deletes one of them.  In the \PUT{} direction, \LN{merge} copies the updated
value of the remaining branch to {\em both} branches in the concrete view.

##let merge : (name -> name -> lens) = Native.Prelude.merge

#*test (merge "m" "n") / {m={a}, n={a}} = {m={a}}
#*test (merge "m" "n") / {m={a}, n={b}} = {m={a}}
#*test (merge "m" "n") / {m={b}, n={b}} = {m={b}}
#*test (merge "m" "n") \ {m={a}} missing = {m={a}, n={a}}
#*test (merge "m" "n") \ {m={a}} {m={a}, n={b}} = {m={a}, n={b}}
#*test (merge "m" "n") \ {} missing = error

#@\LENSSECTION{copy} %
In the \GET{} direction, $\LN{copy}\ m\ n$ takes a tree, $c$, that
has no child labeled $n$.  If $c(m)$ exists, then $\LN{copy}\ m\
n$ duplicates $c(m)$ by setting both $a(m)$ and $a(n)$ equal to
$c(m)$.  In the \PUT{} direction, $\LN{copy}$ simply discards
$a(n)$.  

##let copy : (name -> name -> lens) = Native.Prelude.copy
#*test (copy "m" "n") / {m={a}} = {m={a}, n={a}}
#*test (copy "m" "n") \ {m={a}, n={a}} missing = {m={a}}
#*test (copy "m" "n") \ {m={a}, n={a}} {m={a}} = {m={a}}
#*test (copy "m" "n") \ {m={a}, n={a}} {m={b}} = {m={a}}
#*test (copy "m" "n") / {} = error
#*test (copy "m" "n") \ {m={a}} missing = error
#*test (copy "m" "n") \ {m={a}, n={b}} missing = error

The \PUT{} of the @copy@ lens is only guaranteed to be well behaved if the
subtrees under $m$ and $n$ in the abstract view are always identical.  This
is a very strong constraint, which makes @copy@ nearly uselesss in practical
programming.  See~\cite{Focal2005} for more discussion.

\subsection{Lenses for ``Keyed Relations''}

#@\LENSSECTION{join} 
%
The @join@ lens, based on an idea by Daniel
Spoonhower~\cite{Spoonhower04}, is related to the {\em full outer join}
operator from databases.  \finish{Explain better.}
##let join : (name -> name -> lens) = Native.Prelude.join

#*test (join "x" "y") / {x, y} = {}
#*test (join "x" "y") / {x={1={a}, 2={b}}, y={2={c}}} 
#*                    = {1={x={a}}, 2={x={b}, y={c}}}
#*test (join "x" "y") / {x={1,2}, y={2}} 
#*                    = {1={x}, 2={x,y}}

#*test (join "x" "y") \ {} missing = {x, y}
#*test (join "x" "y") \ {} {x={1}, y={2}} = {x, y}
#*test (join "x" "y") \ {a={x={1}, y={3}}, b={x={2}}, c={y={4}}} 
#*                      missing 
#*                    = {x={a={1}, b={2}},  y={a={3}, c={4}}}

##test (join "x" "y") / {} = error
##test (join "x" "y") / {x} = error


Section~\ref{sec:relational} describes a more sophisticated set of
relational lenses, relying on a heavier-weight



\subsection{Debugging Lenses}

\LENSSECTION{assert} %
The lens @assert T@ behaves like the identity lens but performs some
run-time type checking: if its \GET{} direction is invoked with a concrete
argument not belonging to @T@ or its \PUT{} direction is invoked with either
argument not belonging to @T@, then it  prints a
message to this effect and halts the interpreter.  
##let assert : (schema -> lens) = Native.Prelude.assert

\LENSSECTION{probe} %
The lens @probe msg@ behaves like @id@ except that, whenever it is invoked, it
dumps its arguments (along with the identifying string @msg@) to the
standard output.
##let probe : (name -> lens) = Native.Prelude.probe

\LENSSECTION{tracepoint} %
The lens @tracepoint msg l@ behaves just like @l@ except that, when it is
invoked, it places a marker on the call stack.  If the execution of @l@
results in a run-time exception (because of a bad argument to a lens, for
example), these stack markers and their associated arguments are printed as
part of the termination message. 
##let tracepoint : (name -> lens -> lens) = Native.Prelude.tracepoint

\subsection{I/O Functions}

\LENSSECTION{read}
The expression @read f@ reads the file @f@ from the disk and returns its
whole contents as a single name.

##let read : (name -> name) = Native.Prelude.read

\subsection{Viewer Functions}

\LENSSECTION{load}
The expression @load ekey blob@ parses the name @blob@ using the viewer
identified by the encoding key @ekey@ (see Section~\ref{sec:encodingkeys})
and yields a tree.  Section~\ref{sec:xml} shows some examples of its use.
##let load : (name -> name -> tree) = Native.Prelude.load

\LENSSECTION{load_file}
The expression @load_file name@ parses a file into a tree, using the encoding key
specified as part of the file name or the default encoding key for this file
schema if none is specified explicitly.  

##let load_file : (name -> tree) = Native.Prelude.load_file

\subsection{Miscellaneous}

\LENSSECTION{invert}
The function @invert@ maps a bijective lens @l@ to a bijective lens whose
\GET{} is the \PUT{} of @l@ and vice versa.

