(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2008                                                          *)
(* J. Nathan Foster and Benjamin C. Pierce                                     *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/core.boom                                                 *)
(* List module                                                                 *)
(* $Id$ *)
(*******************************************************************************)

module List = 

#{@}

\section{Lists}

The @List@ module defines a datatype for fpolymorphic list structures.

\LENSSECTION{@'a t@} A list is either the @Nil@ list or a @Cons@ of a head and a tail.

#* type 'a t = Nil | Cons of 'a * 'a t

\LENSSECTION{@fold_left@} Boomerang does not support recursion. However, we provide 
the @fold_left@ function on lists via a built-in primitive.

#* let fold_left ('a) ('b) (f:'b -> 'a -> 'b) (acc:'b) (l:'a t) : 'b 
## = Native.Prelude.fold_left{'b}{'a} f acc l 

\LENSSECTION{@reverse@} The function @reverse@ can be defined straightforwardly
using @fold_left@.

#* let reverse ('a) (l : 'a t) : 'a t =
#*   fold_left{'a}{'a t} 
#*     (fun (t:'a t) (h:'a) -> Cons{'a}(h,t)) 
#*     Nil{'a} 
#*     l

\LENSSECTION{@map@} The function @map@ can be defined (inefficiently) 
using @fold_left@ and @reverse@.

#* let map ('a) ('b) (f:'a -> 'b) (l:'a t) : 'b t = 
#*   let rev_fl : 'b t = 
#*     fold_left{'a}{'b t}
#*       (fun (t:'b t) (h:'a) -> Cons{'b}(f h,t)) 
#*       Nil{'b}
#*       l in 
#*   reverse{'b} rev_fl

\LENSSECTION{@exists@} The function @exists@ tests if a predicate holds of 
some element of the list

#* let exists ('a) (t:'a -> bool) (l:'a t) : bool = 
#*   fold_left {'a}{bool} (fun (b:bool) (h:'a) -> b || t h) 
#*   false 
#*   l

\LENSSECTION{@member@} The function @member@ tests if an element is a
member of the list. It is defined using @exists@.

#* let member ('a) (x:'a) (l:'a t) : bool = 
#*  exists{'a} (fun (h:'a) -> x = h) l 

\subsection{Permutations}

A permutation is an integer list, mapping positions to other positions: if the @i@th
entry of a permutation is the number @j@, then the @i@th element in the original list
will be the @j@th element in the permuted list..  A permutation for the list 
@#{bool}[true;true;false;true;false]@ might be @#{int}[0;1;2;3;4]@ (the identity 
permutation) or @#{int}[4;3;2;1;0]@ (reversal).

\LENSSECTION{@valid_permutation@} The predicate @valid_permutation@ is true when
given the given permutation can be applied to the given list.

#* let valid_permutation ('a) (sigma:int t) (l:'a t) : bool
## = Native.Prelude.valid_permutation{'a} sigma l

#* test valid_permutation{bool} Nil{int} Nil{bool} = true
#* test valid_permutation{bool} (Cons{int}(1,Cons{int}(0,Nil{int}))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = true
#* test valid_permutation{bool} (Cons{int}(1,Cons{int}(1,Nil{int}))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = false
#* test valid_permutation{bool} (Cons{int}(0 - 1,Cons{int}(1,Nil{int}))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = false
#* test valid_permutation{bool} (Cons{int}(0,Cons{int}(1,Cons{int}(2,Nil{int})))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = false
#* test valid_permutation{bool} (Cons{int}(1,Nil{int})) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = false
#* test valid_permutation{bool} (Cons{int}(1,Cons{int}(2,Nil{int}))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = false

\LENSSECTION{@permute@} The operator @permute@ permutes a list according
 to a given permutation.

#* let permute ('a) 
#*          (sigma:int t) 
#*          (l:'a t where valid_permutation{'a} sigma l)
#*   : 'a t
##   = Native.Prelude.list_permute{'a} sigma l

#* test permute{bool} Nil{int} Nil{bool} = Nil{bool}
#* test permute{bool} (Cons{int}(0,Cons{int}(1,Nil{int}))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = (Cons{bool}(false,Cons{bool}(true,Nil{bool})))
#* test permute{bool} (Cons{int}(1,Cons{int}(0,Nil{int}))) (Cons{bool}(false,Cons{bool}(true,Nil{bool}))) = (Cons{bool}(true,Cons{bool}(false,Nil{bool})))
#* test permute{string} (Cons{int}(0,Cons{int}(2,Cons{int}(1,Nil{int})))) (Cons{string}("a",Cons{string}("b",Cons{string}("c",Nil{string})))) = (Cons{string}("a",Cons{string}("c",Cons{string}("b",Nil{string}))))

