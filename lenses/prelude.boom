(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2008                                                          *)
(* J. Nathan Foster and Benjamin C. Pierce                                     *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/prelude.boom                                              *)
(* Boomerang definitions of lens primitives                                    *)
(* $Id$ *)
(*******************************************************************************)

module Prelude =

#{@}

\section{The Standard Prelude}

The second module, @Prelude@, defines some common derived forms. Like
@Core@, its values are available by default in every Boomerang
program.

\subsection{Regular Expressions}

\LENSSECTION{@ANYCHAR@, @ANY@, @ANYP@}

The regular expression @ANYCHAR@ denotes the set of ASCII characters, 
@ANY@ denotes the set of all ASCII strings, and @ANYP@ denotes the 
set of all ASCII strings except for the empty string. By 
convention, we append a ``P'' to the name of a regular expression 
to denote its ``positive'' variant (i.e., not containing the empty
string).

#* let ANYCHAR : regexp = [^]
#* let ANY : regexp = ANYCHAR*
#* let ANYP : regexp = ANYCHAR+

\LENSSECTION{@containing@} The function @containing@ takes a regular
expression @R@ as an argument and produces a regular expression 
describing the set of all strings that contain a substring described by
@R@.

#* let containing (R:regexp) : regexp = ANY . R . ANY

\LENSSECTION{@SCHAR@, @S@, @SP@}

The regular expressions @SCHAR@, @S@, and @SP@ denote sets of 
space characters.

#* let SCHAR : regexp = [ ]
#* let S : regexp = SCHAR*
#* let SP : regexp = SCHAR+

\LENSSECTION{@WSCHAR@, @WS@, @WSP@}

The regular expressions @WSCHAR@, @WS@, and @WSP@ denote sets of 
whitespace characters.

#* let WSCHAR : regexp = [ \t\r\n]
#* let WS : regexp = WSCHAR*
#* let WSP : regexp = WSCHAR+

\LENSSECTION{@NWSCHAR@, @NWS@, @NWSP@}

The regular expressions @WSCHAR@, @WS@, and @WSP@ denote sets of 
non-whitespace characters.

#* let NWSCHAR : regexp = [^ \t\r\n]
#* let NWS : regexp = NWSCHAR*
#* let NWSP : regexp = NWSCHAR+

\LENSSECTION{@newline@, @NLn@} The string @newline@ contains 
the newline character. The strings given by @NL@$n$ each 
denote a newline followed by $n$ spaces. These are used for indentation, 
for example, in the @Xml@ module.

#* let newline : string = "\n"
#* let NL0 : string= newline
#* let NL1 : string= NL0 . " "
#* let NL2 : string= NL1 . " "
#* let NL3 : string= NL2 . " "
#* let NL4 : string= NL3 . " "
#* let NL5 : string= NL4 . " "
#* let NL6 : string= NL5 . " "
#* let NL7 : string= NL6 . " " 
#* let NL8 : string= NL7 . " "
#* let NL9 : string= NL8 . " "
#* let NL10 : string = NL9 . " "

\LENSSECTION{@DIGIT@, @NUMBER@, @FNUMBER@} The regular expressions 
@DIGIT@, @NUMBER@, and @FNUMBER@ represent strings of decimal digits, 
integers, and floating point numbers respectively.

#* let DIGIT : regexp = [0-9]
#* let NUMBER : regexp = /0/ | [1-9] . DIGIT* 
#* let FNUMBER : regexp = NUMBER . (/./ . DIGIT+)?

\LENSSECTION{@UALPHACHAR@, @UALPHANUMCHAR@} 
The regular expression @UALPHACHAR@ and @UALPHANUMCHAR@ 
denote the set of upper case alphabetic and alphanumeric 
characters respectively.

#* let UALPHACHAR : regexp = [A-Z]
#* let UALPHANUMCHAR : regexp = [A-Z0-9]

\subsection{Lenses}

\LENSSECTION{@ins@} The lens @ins@ maps the empty concrete 
string to a fixed abstract string. It is defined straightforwardly 
using @<->@.

#* let ins (s:string) : lens = "" <-> s
#* test get (ins "ABC") "" = "ABC"
#* test put (ins "ABC") "ABC" "" = ""

\LENSSECTION{@del@} The lens @del@ deletes a regular expression. 
It is also defined using @<->@.

#* let del (R:regexp) : lens = R <-> ""

#* test get (del ANY) "Boomerang" = ""
#* test put (del ANY) "" "Boomerang" = "Boomerang"
#* test create (del ANY) "" = ""

\subsection{Lens Predicates}

\LENSSECTION{@lens_iterable@} This predicate is true for lenses with
iterable ctype and atype.

#* let lens_iterable (l:lens) : bool = 
#*   iterable_cex (ctype l) && iterable_cex (atype l)

\LENSSECTION{@lens_splittable@} This predicate is true for a pair of lenses
if the ctypes and atypes are splittable.

#* let lens_splittable (l1:lens) (l2:lens) : bool =
#*   splittable_cex (ctype l1) (ctype l2) &&
#*   splittable_cex (atype l1) (atype l2)

\subsection{Quotient Lenses}

\LENSSECTION{@qconst@} The lens @qconst@ is like @const@, but accepts an 
entire regular expression on the abstract side. It is defined using quotienting 
on the right, the lens @const@, and a canonizer built from @const@.

#* let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
#*   right_quot     
#*     (const C a c)
#*     (canonizer_of_lens (const A a a))

#* test get (qconst [A-Z] [a-z] "a" "A") "A" = "a"
#* test put (qconst [A-Z] [a-z] "a" "A") "b" "B" = "B"

\LENSSECTION{@qset@} The lens @qconst@ is like @set@ (i.e., @<->@), 
but takes an entire regular expression on the abstract side. It is defined 
using @qconst@.

#* let qset (C:regexp) (A:regexp) : lens = 
#*  qconst C A (shortest A) (shortest C)

#* test get (qset [A-Z] [a-z]) "A" = "a" 
#* test get (qset [A-Z] [a-z]) "Z" = "a" 
#* test put (qset [A-Z] [a-z]) "z" "A" = "A" 
#* test put (qset [A-Z] [a-z]) "z" "Z" = "Z" 

\LENSSECTION{@qins@} The lens @qins@ is like @ins@ 
but accepts a regular expression in the $\PUT$ direction. It is defined 
using right quotienting and @ins@.

#* let qins (E:regexp) (e:string) : lens = 
#*   right_quot
#*     (ins e)
#*     (canonizer_of_lens (const E e e))

#* test (get (qins [A-Z]+ "A") "") = "A"
#* test (create (qins [A-Z]+ "A") "ABC") = ""

\LENSSECTION{@qdel@} The lens @qdel@ is like @del@ 
but produces a canonical representative in the backwards direction. 
It is defined using left quotienting.

#* let qdel (E:regexp) (e:string) : lens = 
#*   left_quot 
#*     (canonizer_of_lens (default (del E) e))
#*     (copy EPSILON)

#* test (get (qdel [A-Z]+ "ZZZ") "ABC") = ""
#* test (put (qdel [A-Z]+ "ZZZ") "" "ABC") = "ZZZ"
#* test (put (qdel [A-Z]+ "ZZZ") "1" "ABC") = error

\subsection{Standard Datatypes}

\LENSSECTION{@'a option@, @('a,'b) maybe@} The polymorphic datatypes @option@ and @maybe@ 
represents optional and alternative values respectively.

#* type 'a option = 
#*     None | Some of 'a

#* type ('a,'b) maybe = 
#*     Left of 'a | Right of 'b 

\subsection{Pairs}

\LENSSECTION{@fst@,@snd@} 
The polymorphic functions @fst@ and @snd@ are the standard projections on pairs.

#*let fst ('a) ('b) (p:'a * 'b) : 'a = 
#*  let x,_ = p in x

#*let snd ('a) ('b) (p:'a * 'b) : 'b = 
#*  let _,y = p in y

\subsection{Lenses with List Arguments}

These final two combinators take lists as arguments (and so have to be defined
here instead of @Core@.)

\LENSSECTION{@permute@} The lens @permute@ is an $n$-ary, permuting concatenation 
operator on lenses. Given a concrete string, it splits it into $n$ pieces, 
applies the $\GET$ function of the corresponding lens to each piece, reorders the 
abstract strings according to the fixed permutation specified by @sigma@, and concatenates
the results.

#* let permute : int List.t -> lens List.t -> lens
## = Native.Prelude.permute

#* test get (permute 
#*             #{int}[2;1;0]
#*             #{lens}[(copy UALPHACHAR);
#*                     (copy UALPHACHAR);
#*                     (copy UALPHACHAR)]) "ABC" = "CBA"

\LENSSECTION{@sort@} The canonizer @sort@ puts substrings into 
sorted order according to a list of regular expressions. An exception 
is raised if the unsorted string does not have exactly one substring belonging
to each regular expression. This allows us to assign sort a type that is
compact (though imprecise); see~\cite{QuotientLens08} for an extended discussion.

#* let sort : regexp List.t -> canonizer
## = Native.Prelude.sort

#* test canonize (sort #{regexp}[UALPHACHAR; DIGIT]) "A1" = "A1"
#* test canonize (sort #{regexp}[UALPHACHAR; DIGIT]) "1A" = "A1"
#* test canonize (sort #{regexp}[UALPHACHAR; DIGIT]) "A" = error

#* test uncanonized_type (sort #{regexp}[UALPHACHAR; DIGIT]) =
#*   (UALPHACHAR | DIGIT)*

#* test canonized_type (sort #{regexp}[UALPHACHAR; DIGIT]) = 
#*   (UALPHACHAR . DIGIT)
