(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2008                                                          *)
(* J. Nathan Foster and Benjamin C. Pierce                                     *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/prelude.boom                                              *)
(* Boomerang definitions of lens primitives                                    *)
(* $Id$ *)
(*******************************************************************************)

module Prelude =

let epsilon : regexp = // 

let ins (s:string) : lens = const // s "" 

let del (r:regexp) : lens = const r "" (shortest r) 

(* [ANYCHAR] any character *)
let ANYCHAR = [^]

(* [ANY] any string *)
let ANY : regexp = ANYCHAR*

let NONE: regexp = []

(* [ANYP] any non-empty string *)
let ANYP : regexp = ANYCHAR+

(* [containing R] any string containing [R] *)
let containing (R:regexp) : regexp = ANY . R . ANY

(* [nl] newline *)
let newline : string = "\n"

(* [s] space *)
let space : string = " "

(* [WS] whitespace *)
let WS : regexp = [ \n]*

(* [NWS] not white space *)
let NWS : regexp = [^ \n]

(* [WSP] positive whitespace *)
let WSP : regexp = [ \n]+

(* [SP] positive space *)
let SP : regexp = [ ]+

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [NUMBER] number *)
let NUMBER : regexp = [1-9] . DIGIT*

(* [FNUMBER] floating-point number *)
let FNUMBER : regexp = DIGIT* . ([.] . DIGIT+)?

(* [ULETTER] uppercase letter *)
let ULETTER : regexp = [A-Z]

(* [UALPHANUM] uppercase alphanumeric character *)
let UALPHANUM : regexp = [A-Z0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let NL0 = newline
let NL1 = NL0 . "  "
let NL2 = NL1 . "  "
let NL3 = NL2 . "  "
let NL4 = NL3 . "  "
let NL5 = NL4 . "  "
let NL6 = NL5 . "  "
let NL7 = NL6 . "  " 
let NL8 = NL7 . "  "
let NL9 = NL8 . "  "
let NL10 = NL9 . "  "

(* quotient lenses *)
(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qset C A]: is like [set c a], but accepts all of [C] and [A] in
   the GET and PUT/CREATE directions respectively. *)
let qset (C:regexp) (A:regexp) : lens = 
  qconst C A (shortest A) (shortest C)

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : lens = 
  right_quot
    (ins e)
    (canonizer_of_lens (const E e e))

(* unit tests for qins *)
test (get (qins [A-Z]+ "A") "") = "A"
test (create (qins [A-Z]+ "A") "ABC") = ""

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : lens = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    (copy //)

(* unit tests for qdel *)
test (get (qdel [A-Z]+ "ZZZ") "ABC") = ""
test (put (qdel [A-Z]+ "ZZZ") "" "ABC") = "ZZZ"
test (put (qdel [A-Z]+ "ZZZ") "1" "ABC") = error

type 'a option = 
    None | Some of 'a

type ('a,'b) maybe = 
    Left of 'a | Right of 'b 

(* data type stuff *)
let fst ('a) ('b) (p:'a * 'b) : 'a = 
  let x,_ = p in x

let snd ('a) ('b) (p:'a * 'b) : 'b = 
  let _,y = p in y

let permute (sigma:int List.t) (ls:lens List.t) : lens = 
  Native.Prelude.permute sigma ls

let sort (rs:regexp List.t) : canonizer = 
  Native.Prelude.sort rs
