(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2008                                                          *)
(* J. Nathan Foster and Benjamin C. Pierce                                     *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/prelude.boom                                              *)
(* Boomerang definitions of lens primitives                                    *)
(* $Id$ *)
(*******************************************************************************)

module Prelude =

#{@}

\subsection{Regular Expressions}

\LENSSECTION{epsilon}
The regular expression @epsilon@ denotes the singleton set containing the empty string.

#* let epsilon : regexp = // 

\LENSSECTION{ANYCHAR}

The regular expression @ANYCHAR@ denotes the set of ASCII characters.

#* let ANYCHAR : regexp = [^]

\LENSSECTION{ANY}

The regular expression @ANY@ denotes the set of all ASCII strings.

#* let ANY : regexp = ANYCHAR*

\LENSSECTION{ANYP}

The regular expression @ANYP@ denotes the set of all non-epsilon ASCII strings.

#* let ANYP : regexp = ANYCHAR+

\LENSSECTION{NONE}

The regular expression @NONE@ denotes the empty set of strings.

#* let NONE: regexp = []

\LENSSECTION{SP}

The regular expression @SP@ denotes non-epsilon strings of space characters.

#* let SP : regexp = [ ]+

\LENSSECTIONnott{{\tt WS} and {\tt WSP}}

The regular expression @WS@ denotes strings of space or newline characters; 
@WSP@ is similar, but only denotes non-epsilon strings.

#* let WS : regexp = [ \n]*
#* let WSP : regexp = [ \n]+

\LENSSECTION{NWS}

The regular expression @NWS@ denotes strings of characters other than space or newline.

#* let NWS : regexp = [^ \n]

#{#}

let ins (s:string) : lens = const // s "" 

let del (r:regexp) : lens = const r "" (shortest r) 





(* [containing R] any string containing [R] *)
let containing (R:regexp) : regexp = ANY . R . ANY

let newline : string = "\n"

let space : string = " "

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [NUMBER] number *)
let NUMBER : regexp = [1-9] . DIGIT*

(* [FNUMBER] floating-point number *)
let FNUMBER : regexp = DIGIT* . ([.] . DIGIT+)?

(* [ULETTER] uppercase letter *)
let ULETTER : regexp = [A-Z]

(* [UALPHANUM] uppercase alphanumeric character *)
let UALPHANUM : regexp = [A-Z0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let NL0 = newline
let NL1 = NL0 . "  "
let NL2 = NL1 . "  "
let NL3 = NL2 . "  "
let NL4 = NL3 . "  "
let NL5 = NL4 . "  "
let NL6 = NL5 . "  "
let NL7 = NL6 . "  " 
let NL8 = NL7 . "  "
let NL9 = NL8 . "  "
let NL10 = NL9 . "  "

(* quotient lenses *)
(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qset C A]: is like [set c a], but accepts all of [C] and [A] in
   the GET and PUT/CREATE directions respectively. *)
let qset (C:regexp) (A:regexp) : lens = 
  qconst C A (shortest A) (shortest C)

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : lens = 
  right_quot
    (ins e)
    (canonizer_of_lens (const E e e))

(* unit tests for qins *)
test (get (qins [A-Z]+ "A") "") = "A"
test (create (qins [A-Z]+ "A") "ABC") = ""

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : lens = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    (copy //)

(* unit tests for qdel *)
test (get (qdel [A-Z]+ "ZZZ") "ABC") = ""
test (put (qdel [A-Z]+ "ZZZ") "" "ABC") = "ZZZ"
test (put (qdel [A-Z]+ "ZZZ") "1" "ABC") = error

type 'a option = 
    None | Some of 'a

type ('a,'b) maybe = 
    Left of 'a | Right of 'b 

(* data type stuff *)
let fst ('a) ('b) (p:'a * 'b) : 'a = 
  let x,_ = p in x

let snd ('a) ('b) (p:'a * 'b) : 'b = 
  let _,y = p in y

let permute (sigma:int List.t) (ls:lens List.t) : lens = 
  Native.Prelude.permute sigma ls

let sort (rs:regexp List.t) : canonizer = 
  Native.Prelude.sort rs
