\section{Module {\tt Relational}}

##module Relational =

\subsection{Encoding}

\finish{Explain}

\subsection{Lenses}

\finish{Explain conventions.}

%% Convention for trees representing relations: 
%%    R,S  relations
%%    A,B,C  columns
%%    1,2,3  data
%% Convention for meta-variables:
%%    r,s,t  names of relations
%%    a,b  names of columns
%%    x,y  data
%%    D,E  relations
%%    P,Q  views that provide sets of names

\LENSSECTION{rename}
The lens @rename a b r s@ renames the field @a@ to @b@ in the table named @r@
and replaces it with an updated table under the name @s@.  The \PUT{}
direction does the converse.

##let rename : (name -> name -> name -> name -> lens) = Native.Relational.rename

#{*}
test rename "A" "B" "R" "S" / \
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{B = {1}, C = {2}}, 
             {B = {3}, C = {4}}]}
#{@}


\LENSSECTION{select}
The lens @select A v R S@ selects the records in @R@ for which the field @A@
has the value @v@.

##let select : (name -> name -> name -> name -> lens) = Native.Relational.select

#{*}
test select "A" "1" "R" "S" /
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{A = {1}, C = {2}}]}
#{@}
In the \PUT{} direction, the abstract view must contain only records whose
@A@ field has value @v@.  These records are combined with the records from
the concrete view with field @A@ different from @v@.
#{*}
test select "A" "1" "R" "S" \
       {S = [{A = {1}, C = {8}},
             {A = {1}, C = {9}}]}
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {R = [{A = {1}, C = {8}},
             {A = {1}, C = {9}},
             {A = {3}, C = {4}}]}
#{@}

\LENSSECTION{select@_@eq}
The lens @select_eq A B R S@ selects the records in @R@ for which the fields
@A@ and @B@ have the same value.

##let select_eq : (name -> name -> name -> name -> lens) =
##  Native.Relational.select_eq

#{*}
test select_eq "A" "B" "R" "S" /
       {R = [{A = {1}, B = {1}, C = {2}},
             {A = {1}, B = {2}, C = {3}},
             {A = {4}, B = {4}, C = {5}}]}
     = {S = [{A = {1}, B = {1}, C = {2}},
             {A = {4}, B = {4}, C = {5}}]}
#{@}
The behavior of the \PUT{} direction is analogous to @select@.

\LENSSECTION{project}
Relational projections can be performed with the @project@ lens.  However,
@project@ takes additional arguments to specify the behavior of the lens in
the \PUT{} direction.

##let project : (view -> view -> view -> name -> name -> lens) =
##  Native.Relational.project

#{*}
test project {A} {A} [{B = {7}}] "R" "S" /
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { S = [{A = {1}},
              {A = {2}}]}
#{@}
In the \PUT{} direction,
Showing deletions.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}}]}
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { R = [{A = {1}, B = {5}}]}
#{@}
Showing additions.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}},
              {A = {2}}]}
       { R = [{A = {1}, B = {5}}]}
     = { R = [{A = {1}, B = {5}},
              {A = {2}, B = {7}}]}
#{@}
Showing updates (incorrectly).
#{*}
test project {A, C} {A, C} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {7}, C = {3}}]}
#{@}
Showing updates (incorrectly).
#{*}
test project {A, C} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {5}, C = {3}}]}
#{@}
#{*}
test project {A, B, C} {A, B} [{D = {8}}, {D = {9}}] "R" "S" \
       { S = [{A = {10}, B = {1}, C = {4}},
              {A = {10}, B = {2}, C = {5}},
              {A = {20}, B = {1}, C = {6}},
              {A = {21}, B = {2}, C = {6}}]}
       { R = [{A = {10}, B = {1}, C = {5}, D = {7}},
              {A = {10}, B = {1}, C = {5}, D = {8}},
              {A = {10}, B = {2}, C = {5}, D = {7}},
              {A = {20}, B = {1}, C = {6}, D = {7}},
              {A = {20}, B = {2}, C = {6}, D = {7}}]}
     = { R = [{A = {10}, B = {1}, C = {4}, D = {7}},
              {A = {10}, B = {1}, C = {4}, D = {8}},
              {A = {10}, B = {2}, C = {5}, D = {7}},
              {A = {20}, B = {1}, C = {6}, D = {7}},
              {A = {21}, B = {2}, C = {6}, D = {8}},
              {A = {21}, B = {2}, C = {6}, D = {9}}]}
#{@}

\LENSSECTION{union}
The lens @union R S T@ replaces the relations @R@ and @S@ by 
a new relation @T@ containing the union of their tuples.  

##let union : (name -> name -> name -> lens) = Native.Relational.union

#{*}
test union "R" "S" "T" /
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {T = [{A = {1}}, {A = {2}}, {A = {3}}]}
#{@}
In the \PUT{} direction, @union@ treats @R@ and @S@ symmetrically: new
elements in the abstract table @T@ are propagated to both @R@ and @S@.
Here, for example, the abstract view deletes the elements with values @1@
and @2@ for @A@, keeps @3@, and adds @4@.  The deletions are propagated to
both concrete tables (as they must be); the concrete source of @3@ (the @S@
table only) is maintained; and the new value @4@ is propagated to both @S@
and @T@.
#{*}
test union "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {R = [{A = {4}}],
        S = [{A = {3}}, {A = {4}}] }
#{@}
The case where d the concrete argument to \PUT{} is missing is treated just
like the case where the concrete @S@ and @T@ are empty tables:
#{*}
test union "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       missing
     = {R = [{A = {3}}, {A = {4}}],
        S = [{A = {3}}, {A = {4}}]}
#{@}

\LENSSECTION{unionl}
The lens @unionl R S T@ is an asymmetric variant of @union R S T@ that 
adds new elements only to @R@.

##let unionl : (name -> name -> name -> lens) = Native.Relational.unionl

#{*}
test unionl "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {R = [{A = {4}}],
        S = [{A = {3}}] }
#{@}

\LENSSECTION{unionr}
Similarly, @unionr R S T@ adds new elements only to @S@.

##let unionr : (name -> name -> name -> lens) = Native.Relational.unionr

#{*}
test unionr "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {R = [],
        S = [{A = {3}},{A = {4}}] }
#{@}

\LENSSECTION{inter}
The lens @inter R S T@ replaces the relations @R@ and @S@ by a new relation
@T@ containing the intersection of their tuples.

##let inter : (name -> name -> name -> lens) = Native.Relational.inter
##let interl : (name -> name -> name -> lens) = Native.Relational.interl
##let interr : (name -> name -> name -> lens) = Native.Relational.interr

##let diff : (name -> name -> name -> lens) = Native.Relational.diff
##let diffl : (name -> name -> name -> lens) = Native.Relational.diffl
##let diffr : (name -> name -> name -> lens) = Native.Relational.diffr

\LENSSECTION{join}
The lens @join R S T@ replaces the relations @R@ and @S@ by a new relation @T@
containing the inner join of @R@ and @S@.  The join is performed by matching
the fields of the two tables that share the same name.

##let join : (name -> name -> name -> lens) = Native.Relational.join

The inner join is simply a cross product when the two tables share no column
names.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{B = {3}},
             {B = {4}}]}
     = {T = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}},
             {A = {2}, B = {4}}]}
#{@}
If the two tables both have the same set of column names, an inner join is
equivalent to an intersection operation.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
A more complex join can occur when there is some overlap in the set of column
names in each table.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}}],
        S = [{A = {1}, C = {5}}]}
     = {T = [{A = {1}, B = {3}, C = {5}},
             {A = {1}, B = {4}, C = {5}}]}
#{@}

There are couple of important considerations for the put direction.  In the
case where data appearing in one row of @R@ or @S@ are duplicated in several
rows of @T@ (as in a cross-product), the insertion and deletion of rows from
@T@ may be highly constrained so that repeated information is added, deleted,
or updated in a consistent manner.  In other words, the \PUT{} direction of
this lens is not total on the domain of all tables with the same field names
as the resulting table @T@.  However, for efficiency reasons, our lens will
not raise an error when the abstract view lies outside of the appropriate
domain.

In the case that a record has been deleted from @T@, this may be reflected in
the concrete view by the deletion of a record @R@ or @S@ or both.  The
behavior of @join@ is to propagated to both @R@ and @S@.
#{*}
test join "R" "S" "T" \
       {T = [{A = {5}}]}
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {R = [{A = {2}},
             {A = {5}}],
        S = [{A = {3}},
             {A = {5}}]}
#{@}
Another subtle point is that the addition of a record in @T@ can cause the
addition of a record in one of the tables of the concrete view (@S@ below)
while causing an update of the other table in the concrete view (@R@ below).
#{*}
test join "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{joinl}
The lens @joinl R S T@ is an asymmetric variant of @join R S T@ that
propagates deletions in @T@ only to @R@.

##let joinl : (name -> name -> name -> lens) = Native.Relational.joinl

#{*}
test joinl "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{joinr}
Similarly, @joinr R S T@ propagates deletions only to @S@.

##let joinr : (name -> name -> name -> lens) = Native.Relational.joinr

#{*}
test joinr "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {1}, B = {5}},
             {A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{ojoin}
The lens @ojoin D E@

##let ojoin : (view -> view -> name -> name -> name -> lens) =
##  Native.Relational.ojoin
##let ojoinl : (view -> view -> name -> name -> name -> lens) =
##  Native.Relational.ojoinl
##let ojoinr : (view -> view -> name -> name -> name -> lens) =
##  Native.Relational.ojoinr

#{*}
test ojoin [{C = {55}}] [{B = {33}}] "R" "S" "T" /
       {R = [{A = {1}, B = {3}},
             {A = {2}, B = {3}}],
        S = [{A = {1}, C = {5}}]}
     = {T = [{A = {1}, B = {3}, C = {5}},
             {A = {2}, B = {3}, C = {55}}]}
#{@}


#{#}
(* ADDITIONAL TESTS *)

let norm (db : view) : view = Prelude.map Native.listsort / db

let bd_a = { nm = {Alice}, mon = {June},     day = {21}, age = {21} }
let bd_b = { nm = {Bob},   mon = {December}, day = {13}, age = {25} }
let bd_c = { nm = {Carol}, mon = {October},  day = {31}, age = {31} }
let bd_d = { nm = {Dave},  mon = {June},     day = {23}, age = {23} }
let bd_e = { nm = {Ellen}, mon = {February}, day = {29}, age = {27} }
let bd_f = { nm = {Fred} , mon = {August},   day = {15}, age = {41} }

let ph_a = { nm = {Alice}, ph = {"555-555-5555"} }
let ph_b = { nm = {Bob},   ph = {"123-456-7890"} }
let ph_c = { nm = {Carol}, ph = {"314-159-2653"} }

let a = bd_a
let b = bd_b
let c = bd_c
let d = bd_d
let e = bd_e
let f = bd_f


(* ADDITIONAL RENAME TESTS *)

let rename_nm (n : name) (v : view) : view =
  Prelude.rename "nm" n / v

test
  norm (rename "nm" "nm" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_c) ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "birthdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { birthdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_c) ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "phnums" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the table "phnums" already exsits *)

test
  norm (rename "nm" "day" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the field "day" already exsits *)

test
  norm (rename "foo" "name" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the field "foo" does not exsit *)

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    missing
  )
= norm (
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* "name" is not a column name in the abstract view *)

test
  norm (rename "nm" "name" "birthdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* "birthdays" is not a table in the concrete view *)


(* ADDITIONAL UNION TESTS *)

test
  norm (union "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a, b, c, d, e ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (union "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ a, b, c, d, e ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ c, f ]
    , tbl3 = [ e, f ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete view *)


(* ADDITIONAL UNIONL TESTS *)

test
  norm (unionl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a, b, c, d, e ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (unionl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ c, f ]
    , tbl3 = [ e ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete view *)


(* ADDITIONAL UNIONL TESTS *)

test
  norm (unionr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a, b, c, d, e ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (unionr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ ]
    , tbl3 = [ a, b, c, d, e ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ c ]
    , tbl3 = [ e, f ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete view *)


(* ADDITIONAL INTER TESTS *)

test
  norm (inter "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ b ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (inter "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ b ]
    , tbl3 = [ b ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ a, c, e, f ]
    , tbl3 = [ c, d, e, f ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete view *)


(* ADDITIONAL INTERL TESTS *)

test
  norm (interl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ b ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (interl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ b ]
    , tbl3 = [ b ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ a, c, e, f ]
    , tbl3 = [ b, c, d, e, f ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete view *)


(* ADDITIONAL INTERR TESTS *)

test
  norm (interr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ b ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (interr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ b ]
    , tbl3 = [ b ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ b, a, c, e, f ]
    , tbl3 = [ c, d, e, f ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete view *)


(* ADDITIONAL DIFF TESTS *)

test
  norm (diff "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diff "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* table domains do not match *)

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ b, c, d, e ]
    , tbl3 = [ a, b ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete view *)


(* ADDITIONAL DIFFL TESTS *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diffl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* table domains do not match *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ b, c, d, e ]
    , tbl3 = [ b ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete view *)


(* ADDITIONAL DIFFR TESTS *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diffr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* table domains do not match *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ a, b ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract view *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete view *)
#{@}

