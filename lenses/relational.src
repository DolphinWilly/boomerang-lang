\section{Module {\tt Relational}}

##module Relational =

\subsection{Encoding}
Abstractly, relational data is built from \emph{records}, which are (unordered)
mappings from names to data values, and \emph{relations}, which are (unordered)
sets of records with identical domains.  There are different possible
enocodings of relations into trees with different trade-offs.  We will encode
data values as singleton trees and records as a tree whose domain is
identical to that of the record.  Here is an example of a record encoded as a
tree:
$$ @{ A = {1}, B = {2}, C = {5} }@ $$
Relations are encoded as lists of records.  In this case, we have introduced
some infidelity because lists impose a particular order on their elements.
Thus, the following lenses obey the lens laws only up to reording of the
records in our representation of a relation.  Formally, we will make no
guarantee on the order of the records in a relation after applying a lens or
native function; however, we have written the test cases below to conform to
the case where relations returned by lenses are ordered lexicographically.
We may also combine a collection of named records into a \emph{database}.
There is a natural way to do this.  Here is an example of a database with
tables named @R@ and @S@.
#{*}
let foo : tree = {R = [{A = {1}, C = {2}},
                       {A = {3}, C = {4}}],
                  S = [{B = {5}, C = {6}}, 
                       {B = {7}, C = {8}},
                       {B = {9}, C = {8}}]}
#{@}

\subsection{Lenses}

Our relational lenses are intended to operate on databases, as encoded
above.  The lens will create an abstract view of a database by performing
a relational operation on one or two relations of the concrete view and
replacing them with a single relation in the abstract view, while leaving the
other relations unchanged.  All of the lenses follow the convention that their
last argument will be the name to use for the table that results from the
relational operation and their next-to-last argument(s) will be then name(s)
of the relation(s) upon which the relational operation will be performed.

As we describe relational lenses, we will use @r@, @s@, and @t@ as
meta-variables for the names of relations in a database and @"R"@, @"S"@, and
@"T"@ as the labels on the tree edges under which relations appear in our
encoding of databases.  Where there is no confusion, we will use @r@ (resp.
@s@ and @t@) to refer to the abstract relation represented by the tree under
the name @r@ (resp. @s@ and @t@).

%% Convention for trees representing relations: 
%%    R,S,T  relations
%%    A,B,C  columns
%%    1,2,3  data
%% Convention for meta-variables:
%%    r,s,t  names of relations
%%    a,b,c  names of columns
%%    x,y,z  data
%%    D,E,F  relations
%%    P,Q    trees that provide sets of names

\LENSSECTION{rename}
The lens @rename a b r s@ renames the field @a@ to @b@ in the table named @r@
and replaces it with an updated table under the name @s@.  The \PUT{}
direction does the converse.

##let rename : (name -> name -> name -> name -> lens) = Native.Relational.rename

#{*}
test rename "A" "B" "R" "S" / \
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{B = {1}, C = {2}}, 
             {B = {3}, C = {4}}]}
#{@}


\LENSSECTION{select}
The lens @select a x r s@ selects the records in @r@ for which the field named
@a@ has the value @x@.

##let select : (name -> name -> name -> name -> lens) = Native.Relational.select

#{*}
test select "A" "1" "R" "S" /
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{A = {1}, C = {2}}]}
#{@}
In the \PUT{} direction, the abstract tree must contain only records whose
field named @a@ has the value @x@.  These records are combined with the
records from the concrete tree, in which a value other than @x@ may appear in
the field named @a@.
#{*}
test select "A" "1" "R" "S" \
       {S = [{A = {1}, C = {8}},
             {A = {1}, C = {9}}]}
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {R = [{A = {1}, C = {8}},
             {A = {1}, C = {9}},
             {A = {3}, C = {4}}]}
#{@}

\LENSSECTION{select@_@eq}
The lens @select_eq a b r s@ selects the records in @r@ for which the fields
named @a@ and @b@ have the same value.

##let select_eq : (name -> name -> name -> name -> lens) =
##  Native.Relational.select_eq

#{*}
test select_eq "A" "B" "R" "S" /
       {R = [{A = {1}, B = {1}, C = {2}},
             {A = {1}, B = {2}, C = {3}},
             {A = {4}, B = {4}, C = {5}}]}
     = {S = [{A = {1}, B = {1}, C = {2}},
             {A = {4}, B = {4}, C = {5}}]}
#{@}
The behavior of the \PUT{} direction is analogous to @select@.

\LENSSECTION{project}
Relational projections can be performed with the @project@ lens.  However,
@project@ takes additional arguments to specify the behavior of the lens in
the \PUT{} direction.

##let project : (tree -> tree -> tree -> name -> name -> lens) =
##  Native.Relational.project

#{*}
test project {A} {A} [{B = {7}}] "R" "S" /
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { S = [{A = {1}},
              {A = {2}}]}
#{@}
In the \PUT{} direction:
Showing deletions.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}}]}
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { R = [{A = {1}, B = {5}}]}
#{@}
Showing additions.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}},
              {A = {2}}]}
       { R = [{A = {1}, B = {5}}]}
     = { R = [{A = {1}, B = {5}},
              {A = {2}, B = {7}}]}
#{@}
Showing updates (incorrectly).
#{*}
test project {A, C} {A, C} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {7}, C = {3}}]}
#{@}
Showing updates (incorrectly).
#{*}
test project {A, C} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {5}, C = {3}}]}
#{@}
Showing everything.
#{*}
test project {A, B, C} {A, B} [{D = {8}}, {D = {9}}] "R" "S" \
       { S = [{A = {10}, B = {1}, C = {4}},
              {A = {10}, B = {2}, C = {5}},
              {A = {20}, B = {1}, C = {6}},
              {A = {21}, B = {2}, C = {6}}]}
       { R = [{A = {10}, B = {1}, C = {5}, D = {7}},
              {A = {10}, B = {1}, C = {5}, D = {8}},
              {A = {10}, B = {2}, C = {5}, D = {7}},
              {A = {20}, B = {1}, C = {6}, D = {7}},
              {A = {20}, B = {2}, C = {6}, D = {7}}]}
     = { R = [{A = {10}, B = {1}, C = {4}, D = {7}},
              {A = {10}, B = {1}, C = {4}, D = {8}},
              {A = {10}, B = {2}, C = {5}, D = {7}},
              {A = {20}, B = {1}, C = {6}, D = {7}},
              {A = {21}, B = {2}, C = {6}, D = {8}},
              {A = {21}, B = {2}, C = {6}, D = {9}}]}
#{@}

\LENSSECTION{union}
The lens @union R S T@ replaces the relations @R@ and @S@ by 
a new relation @T@ containing the union of their tuples.  

##let union : (name -> name -> name -> lens) = Native.Relational.union

#{*}
test union "R" "S" "T" /
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {T = [{A = {1}}, {A = {2}}, {A = {3}}]}
#{@}
In the \PUT{} direction, @union@ treats @R@ and @S@ symmetrically: new
elements in the abstract table @T@ are propagated to both @R@ and @S@.
Here, for example, the abstract tree deletes the elements with values @1@
and @2@ for @A@, keeps @3@, and adds @4@.  The deletions are propagated to
both concrete tables (as they must be); the concrete source of @3@ (the @S@
table only) is maintained; and the new value @4@ is propagated to both @S@
and @T@.
#{*}
test union "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {R = [{A = {4}}],
        S = [{A = {3}}, {A = {4}}] }
#{@}
The case where d the concrete argument to \PUT{} is missing is treated just
like the case where the concrete @S@ and @T@ are empty tables:
#{*}
test union "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       missing
     = {R = [{A = {3}}, {A = {4}}],
        S = [{A = {3}}, {A = {4}}]}
#{@}

\LENSSECTION{unionl}
The lens @unionl R S T@ is an asymmetric variant of @union R S T@ that 
adds new elements only to @R@.

##let unionl : (name -> name -> name -> lens) = Native.Relational.unionl

#{*}
test unionl "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {R = [{A = {4}}],
        S = [{A = {3}}] }
#{@}

\LENSSECTION{unionr}
Similarly, @unionr R S T@ adds new elements only to @S@.

##let unionr : (name -> name -> name -> lens) = Native.Relational.unionr

#{*}
test unionr "R" "S" "T" \
       {T = [{A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}] }
     = {R = [],
        S = [{A = {3}},{A = {4}}] }
#{@}

\LENSSECTION{inter}
The lens @inter R S T@ replaces the relations @R@ and @S@ by a new relation
@T@ containing the intersection of their tuples.

##let inter : (name -> name -> name -> lens) = Native.Relational.inter
##let interl : (name -> name -> name -> lens) = Native.Relational.interl
##let interr : (name -> name -> name -> lens) = Native.Relational.interr

\LENSSECTION{join}
The lens @join r s t@ replaces the relations @r@ and @s@ by a new relation @t@
containing the inner join of @r@ and @s@.  The join is performed by matching
the fields of the two tables that share the same name.

##let join : (name -> name -> name -> lens) = Native.Relational.join

The inner join is simply a cross product when the two tables share no column
names.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{B = {3}},
             {B = {4}}]}
     = {T = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}},
             {A = {2}, B = {4}}]}
#{@}
If the two tables both have the same set of column names, an inner join is
equivalent to an intersection operation.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
A more complex join can occur when there is some overlap in the set of column
names in each table.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}}],
        S = [{A = {1}, C = {5}}]}
     = {T = [{A = {1}, B = {3}, C = {5}},
             {A = {1}, B = {4}, C = {5}}]}
#{@}

There are a couple of important considerations for the \PUT{} direction.  In
the case where data appearing in one row of @r@ or @s@ are duplicated in
several rows of @t@ (as in a cross-product), the insertion and deletion of
rows from @t@ may be highly constrained so that repeated information is added,
deleted, or updated in a consistent manner.  In other words, the \PUT{}
direction of this lens is not total on the domain of all tables with the field
names that agree with @t@.  However, for efficiency reasons, our lens will not
raise an error when the abstract tree lies outside of the appropriate domain.

In the case that a record has been deleted from @t@, this may be reflected in
the concrete tree by the deletion of a record @r@ or @s@ or both.  The
behavior of @join@ is to propagate the deletion to both @r@ and @s@.
#{*}
test join "R" "S" "T" \
       {T = [{A = {5}}]}
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {R = [{A = {2}},
             {A = {5}}],
        S = [{A = {3}},
             {A = {5}}]}
#{@}
Another subtle point is that the addition of a record in @t@ can cause the
addition of a record in one of the tables of the concrete tree (@s@ below)
while causing an update of the other table in the concrete tree (@r@ below).
#{*}
test join "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{joinl}
The lens @joinl r s t@ is an asymmetric variant of @join r s t@ that
propagates deletions in @t@ only to @r@.

##let joinl : (name -> name -> name -> lens) = Native.Relational.joinl

#{*}
test joinl "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{joinr}
Similarly, @joinr r s t@ propagates deletions only to @s@.

##let joinr : (name -> name -> name -> lens) = Native.Relational.joinr

#{*}
test joinr "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {1}, B = {5}},
             {A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{ojoin}
The lens @ojoin D E@

##let ojoin : (tree -> tree -> name -> name -> name -> lens) =
##  Native.Relational.ojoin
##let ojoinl : (tree -> tree -> name -> name -> name -> lens) =
##  Native.Relational.ojoinl
##let ojoinr : (tree -> tree -> name -> name -> name -> lens) =
##  Native.Relational.ojoinr

#{*}
test ojoin [{C = {55}}] [{B = {33}}] "R" "S" "T" /
       {R = [{A = {1}, B = {3}},
             {A = {2}, B = {3}}],
        S = [{A = {1}, C = {5}}]}
     = {T = [{A = {1}, B = {3}, C = {5}},
             {A = {2}, B = {3}, C = {55}}]}
#{@}


\LENSSECTION{diff}
The lens @diff r s t@ replaces the relations @r@ and @s@ by a new relation @t@
containing the set-theoretic difference between @r@ and @s@, \emph{i.e.}~all
of the records that appear in @r@ but not in @s@.

##let diff : (name -> name -> name -> lens) = Native.Relational.diff

#{*}
test diff "R" "S" "T" /
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
In the \PUT{} direction, @diff@ may modify both @r@ and @s@ when elements have
been deleted from the abstract view: deleting an element from @t@ will result
in the element being deleted from @r@ \emph{and} added to @s@.  Additions to
@t@ will result in their obligatory addition to @r@ and removal from @s@.
#{*}
test diff "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {2}}, {A = {3}}, {A = {4}}],
        S = [{A = {1}}]}
#{@}
The case where the concrete argument to \PUT{} is missing is treated just
like the case where the concrete @s@ and @t@ are empty relations:
#{*}
test diff "R" "S" "T" \
       {T = [{A = {1}}, {A = {2}}]}
       missing
     = {R = [{A = {1}}, {A = {2}}],
        S = []}
#{@}

\LENSSECTION{diffl}
The lens @diffl r s t@ is a variant of @diffl r s t@ that deals with deletions
in the abstract view by only deleting them from @r@ and does not add them to
@s@.

##let diffl : (name -> name -> name -> lens) = Native.Relational.diffl

#{*}
test diffl "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {2}}, {A = {3}}, {A = {4}}],
        S = []}
#{@}

\LENSSECTION{diffl}
The lens @diffl r s t@ is a variant of @diffl r s t@ that deals with deletions
in the abstract view by only adding them to @s@ and does not remove them from
@t@.

##let diffr : (name -> name -> name -> lens) = Native.Relational.diffr

#{*}
test diffr "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {1}}, {A = {2}}, {A = {3}}, {A = {4}}],
        S = [{A = {1}}]}
#{@}

#{#}
(* ADDITIONAL TESTS *)

let norm (db : tree) : tree = Prelude.map Native.listsort / db

let bd_a : tree = { nm = {Alice}, mon = {June},     day = {21}, age = {21} }
let bd_b : tree = { nm = {Bob},   mon = {December}, day = {13}, age = {25} }
let bd_c : tree = { nm = {Carol}, mon = {October},  day = {31}, age = {31} }
let bd_d : tree = { nm = {Dave},  mon = {June},     day = {23}, age = {23} }
let bd_e : tree = { nm = {Ellen}, mon = {February}, day = {29}, age = {27} }
let bd_f : tree = { nm = {Fred} , mon = {August},   day = {15}, age = {41} }

let ph_a : tree = { nm = {Alice}, ph = {"555-555-5555"} }
let ph_b : tree = { nm = {Bob},   ph = {"123-456-7890"} }
let ph_c : tree = { nm = {Carol}, ph = {"314-159-2653"} }

let a : tree = bd_a
let b : tree = bd_b
let c : tree = bd_c
let d : tree = bd_d
let e : tree = bd_e
let f : tree = bd_f


(* ADDITIONAL RENAME TESTS *)

let rename_nm (n : name) (v : tree) : tree =
  Prelude.rename "nm" n / v

test
  norm (rename "nm" "nm" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_c) ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "birthdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { birthdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_c) ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "phnums" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the table "phnums" already exsits *)

test
  norm (rename "nm" "day" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the field "day" already exsits *)

test
  norm (rename "foo" "name" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the field "foo" does not exsit *)

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    missing
  )
= norm (
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* "name" is not a column name in the abstract tree *)

test
  norm (rename "nm" "name" "birthdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* "birthdays" is not a table in the concrete tree *)


(* ADDITIONAL UNION TESTS *)

test
  norm (union "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a, b, c, d, e ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (union "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ a, b, c, d, e ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ c, f ]
    , tbl3 = [ e, f ]
    }
  )

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (union "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL UNIONL TESTS *)

test
  norm (unionl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a, b, c, d, e ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (unionl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ c, f ]
    , tbl3 = [ e ]
    }
  )

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (unionl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL UNIONL TESTS *)

test
  norm (unionr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a, b, c, d, e ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (unionr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ ]
    , tbl3 = [ a, b, c, d, e ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ c ]
    , tbl3 = [ e, f ]
    }
  )

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (unionr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a, b, c, d, e ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL INTER TESTS *)

test
  norm (inter "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ b ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (inter "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ b ]
    , tbl3 = [ b ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ a, c, e, f ]
    , tbl3 = [ c, d, e, f ]
    }
  )

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (inter "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL INTERL TESTS *)

test
  norm (interl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ b ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (interl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ b ]
    , tbl3 = [ b ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ a, c, e, f ]
    , tbl3 = [ b, c, d, e, f ]
    }
  )

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (interl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL INTERR TESTS *)

test
  norm (interr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ b ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (interr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* table domains do not match *)

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ b ]
    , tbl3 = [ b ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= norm (
    { tbl2 = [ b, a, c, e, f ]
    , tbl3 = [ c, d, e, f ]
    }
  )

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, d, e ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (interr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ b ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* table "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL DIFF TESTS *)

test
  norm (diff "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diff "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* table domains do not match *)

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ b, c, d, e ]
    , tbl3 = [ a, b ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL DIFFL TESTS *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diffl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* table domains do not match *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ b, c, d, e ]
    , tbl3 = [ b ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL DIFFR TESTS *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diffr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* table domains do not match *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ a, b ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete tree *)
#{@}

