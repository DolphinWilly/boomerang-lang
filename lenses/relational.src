\section{Module {\tt Relational}}
\label{sec:relational}

##module Relational =

\subsection{Encoding} 

Relational data is built from
\emph{records}, which are (unordered) mappings from names to data values, and
\emph{relations}, which are (unordered) sets of records with identical
domains.  In Focal, we work with relations that are encoded as
trees.  We encode data values as singleton trees and records as a 
tree whose domain is identical to that of the record.  Here is an example of a
record encoded as a tree: $$ @{ A = {1}, B = {2}, C = {5} }@ $$ We have chosen
to encode relations as lists of records.  The lists of records produced by
lenses will be sorted lexicographically (and without duplicates) so as to
maintain a canonical representation of the underlying mathematical set.

A collection of named relations forms a \emph{database}.
For example, here is the Focal encoding a database with relations named @R@
and @S@. 
#{*}
let foo : tree = {R = [{A = {1}, C = {2}},
                       {A = {3}, C = {4}}],
                  S = [{B = {5}, C = {6}}, 
                       {B = {7}, C = {8}},
                       {B = {9}, C = {8}}]}
#{@}

\subsection{Lenses}

Our relational lenses are intended to operate on databases, as encoded above.
The lenses will create an abstract database by performing a relational operation
on one or two relations of the concrete database and replacing them with a
single relation in the abstract database, while leaving the others
unchanged.  All of the lenses follow the convention that their last argument
will be the name to use in the abstract database for the relation that results
from the relational operation and their next-to-last argument(s) will be the
name(s) of the relation(s) in the concrete database upon which the relational
operation will be performed.

As we describe relational lenses, we will use @r@, @s@, and @t@ as
meta-variables for the names on the tree edges under which relations appear in
our encoding of databases, while we will generally use @"R"@, @"S"@, and
@"T"@ as the literal names of those edges.  Where there is no ambiguity, we
will also use @r@ (resp.  @s@ and @t@) to refer to the mathematical relation
represented by the tree under the name @r@ (resp. @s@ and @t@).

%% Convention for trees representing relations: 
%%    R,S,T  relations
%%    A,B,C  columns
%%    1,2,3  data
%% Convention for meta-variables:
%%    r,s,t  names of relations
%%    a,b,c  names of columns
%%    x,y,z  data
%%    D,E,F  relations
%%    P,Q    trees that provide sets of names

\LENSSECTION{rename}
The lens @rename a b r s@ renames the field @a@ to @b@ in the relation named
@r@ and replaces it with an updated relation under the name @s@.  The \PUT{}
direction does the converse.

##let rename : (name -> name -> name -> name -> lens) = Native.Relational.rename

#{*}
test rename "A" "B" "R" "S" / \
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{B = {1}, C = {2}}, 
             {B = {3}, C = {4}}]}
#{@}


\LENSSECTION{select}
The lens @select a x r s@ selects the records in @r@ for which the field
@a@ has the value @x@.

##let select : (name -> name -> name -> name -> lens) = Native.Relational.select

#{*}
test select "A" "1" "R" "S" /
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{A = {1}, C = {2}}]}
#{@}
In the \PUT{} direction, the abstract tree must contain only records whose
field @a@ has the value @x@.  These records are combined with the
records from the concrete tree, in which a value other than @x@ may appear in
the field @a@.
#{*}
test select "A" "1" "R" "S" \
       {S = [{A = {1}, C = {8}},
             {A = {1}, C = {9}}]}
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {R = [{A = {1}, C = {8}},
             {A = {1}, C = {9}},
             {A = {3}, C = {4}}]}
#{@}

\LENSSECTION{select@_@eq}
The lens @select_eq a b r s@ selects the records in @r@ for which the fields
named @a@ and @b@ have the same value.

##let select_eq : (name -> name -> name -> name -> lens) =
##  Native.Relational.select_eq

#{*}
test select_eq "A" "B" "R" "S" /
       {R = [{A = {1}, B = {1}, C = {2}},
             {A = {1}, B = {2}, C = {3}},
             {A = {4}, B = {4}, C = {5}}]}
     = {S = [{A = {1}, B = {1}, C = {2}},
             {A = {4}, B = {4}, C = {5}}]}
#{@}
The behavior of the \PUT{} direction is analogous to @select@.

\LENSSECTION{project}
Relational projections can be performed with the @project@ lens.  The lens
takes several arguments to help specify the behavior in
the \PUT{} direction.  The first argument is the set of fields (\emph{i.e.}~a
tree with edges having the names of the fields) on which to project.  The
second argument is a set of fields that should be regarded as key fields
in the abstract database.  If there is no set of fields that functions as a
key, this should include all projected fields.  The third argument is a
(tree-encoded) relation that provides a default value for fields that have
been projected away.

##let project : (tree -> tree -> tree -> name -> name -> lens) =
##  Native.Relational.project

#{*}
test project {A} {A} [{B = {7}}] "R" "S" /
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { S = [{A = {1}},
              {A = {2}}]}
#{@}
In the \PUT{} direction, deletions in the abstract database cause deletions in
the concrete database.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}}]}
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { R = [{A = {1}, B = {5}}]}
#{@}
Additions in the abstract database become additions in the concrete database
and make use of the default record.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}},
              {A = {2}}]}
       { R = [{A = {1}, B = {5}}]}
     = { R = [{A = {1}, B = {5}},
              {A = {2}, B = {7}}]}
#{@}
Modifying one of the values in a projected field will have the same effect as
a deletion and an insertion, thus causing the fields that were projected away
to revert to the default values given in the lens.
#{*}
test project {A, C} {A, C} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {7}, C = {3}}]}
#{@}
This can be prevented by specifying which set of the projected fields may be
regarded as key fields.  Modifying values in non-key fields will then have the
desired effect.
#{*}
test project {A, C} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {5}, C = {3}}]}
#{@}
The behavior is not specified if the set of key fields given is not
actually a key.

\LENSSECTION{join}
The lens @join r s t@ replaces the relations @r@ and @s@ by a new relation @t@
containing the inner join of @r@ and @s@.  The join is performed on the fields
of @r@ and @s@ that share the same names.

##let join : (name -> name -> name -> lens) = Native.Relational.join

The inner join is simply a cross product when the two relations share no column
names.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{B = {3}},
             {B = {4}}]}
     = {T = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}},
             {A = {2}, B = {4}}]}
#{@}
If the two relations both have the same set of column names, an inner join is
equivalent to an intersection operation.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
A more complex join can occur when there is some overlap in the set of column
names in each relation.
#{*}
test join "R" "S" "T" /
       {R = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}}],
        S = [{A = {1}, C = {5}}]}
     = {T = [{A = {1}, B = {3}, C = {5}},
             {A = {1}, B = {4}, C = {5}}]}
#{@}

There are a couple of important considerations for the \PUT{} direction.  In
the case where data appearing in one record of @r@ or @s@ are duplicated in
several records of @t@ (as in a cross-product), the insertion and deletion of
records from @t@ may be highly constrained so that repeated information is
added, deleted, or updated in a consistent manner.  In other words, the \PUT{}
direction of this lens is not total on the domain of all relations with the
field names that agree with @t@.  However, for efficiency reasons, our lens
will not raise an error when the abstract tree lies outside of the appropriate
domain.

In the case that a record has been deleted from @t@, this may be reflected in
the concrete dababase by the deletion of a record @r@ or @s@ or both.  The
behavior of @join@ is to propagate the deletion to both @r@ and @s@.
#{*}
test join "R" "S" "T" \
       {T = [{A = {5}}]}
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {R = [{A = {2}},
             {A = {5}}],
        S = [{A = {3}},
             {A = {5}}]}
#{@}
Another subtle point is that the addition of a record in @t@ can cause the
addition of a record in one of the relations of the concrete tree (@s@ below)
while causing an update of the other relation in the concrete tree (@r@ below).
#{*}
test join "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{joinl}
The lens @joinl r s t@ is an asymmetric variant of @join r s t@ that
propagates deletions in @t@ only to @r@.

##let joinl : (name -> name -> name -> lens) = Native.Relational.joinl

#{*}
test joinl "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{joinr}
Similarly, @joinr r s t@ propagates deletions only to @s@.

##let joinr : (name -> name -> name -> lens) = Native.Relational.joinr

#{*}
test joinr "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {1}, B = {5}},
             {A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{ojoin}
The lens @ojoin D E r s t@ replaces the relations @r@ and @s@ by a new
relation @t@ containing the outer join of @r@ and @s@.  The join is performed
on the fields of @r@ and @s@ that share the same names.  The argument @D@ is a
list of records (\emph{i.e.}~a relation) that completes the missing fields
when a record only appears in @r@.  Similarly, when a record only appears in
@s@, @E@ will be used to supply default values.

##let ojoin : (tree -> tree -> name -> name -> name -> lens) =
##  Native.Relational.ojoin

The outer join (like the inner join) is a cross product when the two relations
share no column names.
#{*}
test ojoin [{B = {10}}] [{A = {20}}] "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{B = {3}},
             {B = {4}}]}
     = {T = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}},
             {A = {2}, B = {4}}]}
#{@}
If the two relations both have the same set of column names, an outer join is
equivalent to a union operation.
#{*}
test ojoin [{}] [{}] "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {T = [{A = {1}},
             {A = {2}},
             {A = {3}}]}
#{@}
A more complex join can occur when there is some overlap in the set of column
names in each relation.
#{*}
test ojoin [{C = {0}}] [{B = {0}}] "R" "S" "T" /
       {R = [{A = {1}, B = {4}},
             {A = {2}, B = {4}}],
        S = [{A = {1}, C = {6}},
             {A = {3}, C = {7}}]}
     = {T = [{A = {1}, B = {4}, C = {6}},
             {A = {2}, B = {4}, C = {0}},
             {A = {3}, B = {0}, C = {7}}]}
#{@}

As in the case of @join@, the \PUT{} direction of the lens is not total on the
domain of all relations with field names that match the output relation.

In the case that a record has been deleted from @t@, it will cause a deletion
in both @r@ and @s@ in the \PUT{} direction.  In the case of additions, it
will usually be necessary to insert records into both tables in the concrete
database.  The only exception to this is when a record has been inserted that
has default values both for the fields that are unique to @r@ and the fields
that are unique to @s@.  Then there is a choice whether to add this record to
@r@ or @s@ or both.  The lens @ojoin@ adds these to both.
#{*}
test ojoin [{C = {0}}] [{B = {0}}] "R" "S" "T" \
       {T = [{A = {3}, B = {0}, C = {0}},
             {A = {4}, B = {0}, C = {9}},
             {A = {5}, B = {7}, C = {0}},
             {A = {6}, B = {8}, C = {9}}]}
       {R = [{A = {1}, B = {7}},
             {A = {2}, B = {8}}],
        S = [{A = {1}, C = {9}}]}
     = {R = [{A = {3}, B = {0}},
             {A = {4}, B = {0}},
             {A = {5}, B = {7}},
             {A = {6}, B = {8}}],
        S = [{A = {3}, C = {0}},
             {A = {4}, C = {9}},
             {A = {5}, C = {0}},
             {A = {6}, C = {9}}]}
#{@}

\LENSSECTION{ojoinl}
The lens @ojoinl D E r s t@ is an asymmetric variant of @ojoin D E r s t@ that
propagates addeditions in @t@ only to @r@ when there is a choice,
\emph{i.e.}~when the added record has only default values in the non-overlapping
fields.

##let ojoinl : (tree -> tree -> name -> name -> name -> lens) =
##  Native.Relational.ojoinl

#{*}
test ojoinl [{C = {0}}] [{B = {0}}] "R" "S" "T" \
       {T = [{A = {3}, B = {0}, C = {0}},
             {A = {4}, B = {0}, C = {9}},
             {A = {5}, B = {7}, C = {0}},
             {A = {6}, B = {8}, C = {9}}]}
       {R = [{A = {1}, B = {7}},
             {A = {2}, B = {8}}],
        S = [{A = {1}, C = {9}}]}
     = {R = [{A = {3}, B = {0}},
             {A = {4}, B = {0}},
             {A = {5}, B = {7}},
             {A = {6}, B = {8}}],
        S = [{A = {4}, C = {9}},
             {A = {5}, C = {0}},
             {A = {6}, C = {9}}]}
#{@}

\LENSSECTION{ojoinr}
Similarly, @ojoinr D E r s t@ propagates additions only to @s@ when possible.

##let ojoinr : (tree -> tree -> name -> name -> name -> lens) =
##  Native.Relational.ojoinr

#{*}
test ojoinr [{C = {0}}] [{B = {0}}] "R" "S" "T" \
       {T = [{A = {3}, B = {0}, C = {0}},
             {A = {4}, B = {0}, C = {9}},
             {A = {5}, B = {7}, C = {0}},
             {A = {6}, B = {8}, C = {9}}]}
       {R = [{A = {1}, B = {7}},
             {A = {2}, B = {8}}],
        S = [{A = {1}, C = {9}}]}
     = {R = [{A = {4}, B = {0}},
             {A = {5}, B = {7}},
             {A = {6}, B = {8}}],
        S = [{A = {3}, C = {0}},
             {A = {4}, C = {9}},
             {A = {5}, C = {0}},
             {A = {6}, C = {9}}]}
#{@}


\LENSSECTION{diff}
The lens @diff r s t@ replaces the relations @r@ and @s@ by a new relation @t@
containing the set-theoretic difference between @r@ and @s@, \emph{i.e.}~all
of the records that appear in @r@ but not in @s@.

##let diff : (name -> name -> name -> lens) = Native.Relational.diff

#{*}
test diff "R" "S" "T" /
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
In the \PUT{} direction, @diff@ may modify both @r@ and @s@ when elements have
been deleted from the abstract database: deleting an element from @t@ will
result in the element being deleted from @r@ \emph{and} added to @s@.
Additions to @t@ will result in their obligatory addition to @r@ and removal
from @s@.
#{*}
test diff "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {2}}, {A = {3}}, {A = {4}}],
        S = [{A = {1}}]}
#{@}
The case where the concrete argument to \PUT{} is missing is treated just
like the case where the concrete @s@ and @t@ are empty relations:
#{*}
test diff "R" "S" "T" \
       {T = [{A = {1}}, {A = {2}}]}
       missing
     = {R = [{A = {1}}, {A = {2}}],
        S = []}
#{@}

\LENSSECTION{diffl}
The lens @diffl r s t@ is a variant of @diffl r s t@ that deals with deletions
in the abstract database by only deleting them from @r@ and does not add them
to @s@.

##let diffl : (name -> name -> name -> lens) = Native.Relational.diffl

#{*}
test diffl "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {2}}, {A = {3}}, {A = {4}}],
        S = []}
#{@}

\LENSSECTION{diffl}
The lens @diffl r s t@ is a variant of @diffl r s t@ that deals with deletions
in the abstract database by only adding them to @s@ and does not remove them
from @t@.

##let diffr : (name -> name -> name -> lens) = Native.Relational.diffr

#{*}
test diffr "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {1}}, {A = {2}}, {A = {3}}, {A = {4}}],
        S = [{A = {1}}]}
#{@}

#{#}
(* ADDITIONAL TESTS *)

let norm (db : tree) : tree = Prelude.map Native.listsort / db

let bd_a : tree = { nm = {Alice}, mon = {June},     day = {21}, age = {21} }
let bd_b : tree = { nm = {Bob},   mon = {December}, day = {13}, age = {25} }
let bd_c : tree = { nm = {Carol}, mon = {October},  day = {31}, age = {31} }
let bd_d : tree = { nm = {Dave},  mon = {June},     day = {23}, age = {23} }
let bd_e : tree = { nm = {Ellen}, mon = {February}, day = {29}, age = {27} }
let bd_f : tree = { nm = {Fred} , mon = {August},   day = {15}, age = {41} }

let ph_a : tree = { nm = {Alice}, ph = {"555-555-5555"} }
let ph_b : tree = { nm = {Bob},   ph = {"123-456-7890"} }
let ph_c : tree = { nm = {Carol}, ph = {"314-159-2653"} }

let a : tree = bd_a
let b : tree = bd_b
let c : tree = bd_c
let d : tree = bd_d
let e : tree = bd_e
let f : tree = bd_f


(* ADDITIONAL RENAME TESTS *)

let rename_nm (n : name) (v : tree) : tree =
  Prelude.rename "nm" n / v

test
  norm (rename "nm" "nm" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_c) ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "birthdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { birthdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_c) ]
    , phnums = [ ph_a, ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "phnums" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the relation "phnums" already exsits *)

test
  norm (rename "nm" "day" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the field "day" already exsits *)

test
  norm (rename "foo" "name" "bdays" "bdays" /
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* the field "foo" does not exsit *)

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= norm (
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    missing
  )
= norm (
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
  )

test
  norm (rename "nm" "name" "bdays" "bdays" \
    { bdays = [ bd_a, bd_b ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* "name" is not a column name in the abstract tree *)

test
  norm (rename "nm" "name" "birthdays" "bdays" \
    { bdays = [ (rename_nm "name" bd_a), (rename_nm "name" bd_b) ]
    , phnums = [ ph_a, ph_c ]
    , phnums2 = [ ph_b ]
    }
    { bdays = [ bd_a, bd_c ]
    , phnums = [ ph_a, ph_b ]
    }
  )
= error (* "birthdays" is not a relation in the concrete tree *)


(* ADDITIONAL DIFF TESTS *)

test
  norm (diff "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diff "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* relation domains do not match *)

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ b, c, d, e ]
    , tbl3 = [ a, b ]
    }
  )

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (diff "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL DIFFL TESTS *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diffl "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* relation domains do not match *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ b, c, d, e ]
    , tbl3 = [ b ]
    }
  )

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (diffl "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete tree *)


(* ADDITIONAL DIFFR TESTS *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_b ]
    , tbl4 = [ a ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl2" doesn't exist *)

test
  norm (diffr "tbl1" "tbl2" "tbl4" /
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* relation domains do not match *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    , tbl5 = [ e, f ]
    }
    { tbl1 = [ ph_a, ph_b ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    , tbl5 = [ e, f ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    missing
  )
= norm (
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a ]
    , tbl3 = [ ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl4 = [ c, d, e ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= norm (
    { tbl2 = [ a, b, c, d, e ]
    , tbl3 = [ a, b ]
    }
  )

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    , tbl3 = [ b, c, d ]
    }
  )
= error (* "tbl4" does not exist in the abstract tree *)

test
  norm (diffr "tbl2" "tbl3" "tbl4" \
    { tbl1 = [ ph_a, ph_c ]
    , tbl4 = [ a ]
    }
    { tbl1 = [ ph_a, ph_c ]
    , tbl2 = [ a, b, c ]
    }
  )
= error (* "tbl3" does not exist in the concrete tree *)
#{@}

