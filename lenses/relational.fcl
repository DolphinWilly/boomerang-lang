#{@}

\section{Module {\tt Relational}}
\label{sec:relational}

##module Relational =

\subsection{Encoding} 

Relational data is built from \emph{records}, which are (unordered) mappings
from names to data values, and \emph{relations}, which are (unordered) sets of
records with identical domains.  In Focal, we work with relations that are
encoded as trees.  We encode data values as singleton trees and records as a
tree whose domain is identical to that of the record.  Here is an example of a
record encoded as a tree: $$ @{ A = {1}, B = {2}, C = {5} }@ $$ We have chosen
to encode relations as lists of records.  The lists of records produced by
lenses will be sorted lexicographically (and without duplicates) so as to
maintain a canonical representation of the underlying mathematical set.

A collection of named relations forms a \emph{database}.
For example, here is the Focal encoding a database with relations named @R@
and @S@. 
#{*}
let foo : tree = {R = [{A = {1}, C = {2}},
                       {A = {3}, C = {4}}],
                  S = [{B = {5}, C = {6}}, 
                       {B = {7}, C = {8}},
                       {B = {9}, C = {8}}]}
#{@}

\subsection{Lenses}

Our relational lenses are intended to operate on databases, as encoded above.
The lenses will create an abstract database by performing a relational operation
on one or two relations of the concrete database and replacing them with a
single relation in the abstract database, while leaving the others
unchanged.  All of the lenses follow the convention that their last argument
will be the name to use in the abstract database for the relation that results
from the relational operation and their next-to-last argument(s) will be the
name(s) of the relation(s) in the concrete database upon which the relational
operation will be performed.

As we describe relational lenses, we will use @r@, @s@, and @t@ as
meta-variables for the names on the tree edges under which relations appear in
our encoding of databases, while we will generally use @"R"@, @"S"@, and
@"T"@ as the literal names of those edges.  Where there is no ambiguity, we
will also use @r@ (resp.  @s@ and @t@) to refer to the mathematical relation
represented by the tree under the name @r@ (resp. @s@ and @t@).

%% Convention for trees representing relations: 
%%    R,S,T  relations
%%    A,B,C  columns
%%    1,2,3  data
%% Convention for meta-variables:
%%    r,s,t  names of relations
%%    a,b,c  names of columns
%%    x,y,z  data
%%    D,E,F  relations
%%    P,Q    trees that provide sets of names


\LENSSECTION{rename}
The lens @rename a b r s@ renames the field @a@ to @b@ in the relation named
@r@ and replaces it with an updated relation under the name @s@.  The \PUT{}
direction does the converse.

##let rename : (name -> name -> name -> name -> lens) = Native.Relational.rename

#{*}
test rename "A" "B" "R" "S" / \
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{B = {1}, C = {2}}, 
             {B = {3}, C = {4}}]}
#{@}


\LENSSECTION{select}
The lens @select T r s@ selects the records in @r@ that are in the schema @T@.

##let select : (schema -> name -> name -> lens) = Native.Relational.select

#{*}
test select {A = {1}, C = Any} "R" "S" /
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {S = [{A = {1}, C = {2}}]}
#{@}
In the \PUT{} direction, the abstract tree must contain only records whose
field @a@ has the value @x@.  These records are combined with the
records from the concrete tree, in which a value other than @x@ may appear in
the field @a@.
#{*}
test select {A = {1}, C = Any} "R" "S" \
       {S = [{A = {1}, C = {8}},
             {A = {1}, C = {9}}]}
       {R = [{A = {1}, C = {2}},
             {A = {3}, C = {4}}]}
     = {R = [{A = {1}, C = {8}},
             {A = {1}, C = {9}},
             {A = {3}, C = {4}}]}
#{@}

\LENSSECTION{select@_@eq}
The lens @select_eq a b r s@ selects the records in @r@ for which the fields
named @a@ and @b@ have the same value.

##let select_eq : (name -> name -> name -> name -> lens) =
##  Native.Relational.select_eq

#{*}
test select_eq "A" "B" "R" "S" /
       {R = [{A = {1}, B = {1}, C = {2}},
             {A = {1}, B = {2}, C = {3}},
             {A = {4}, B = {4}, C = {5}}]}
     = {S = [{A = {1}, B = {1}, C = {2}},
             {A = {4}, B = {4}, C = {5}}]}
#{@}
The behavior of the \PUT{} direction is analogous to @select@.

\LENSSECTION{project}
Relational projections can be performed with the @project@ lens.  The lens
takes several arguments to help specify the behavior in
the \PUT{} direction.  The first argument is the set of fields (\emph{i.e.}~a
tree with edges having the names of the fields) on which to project.  The
second argument is a set of fields that should be regarded as key fields
in the abstract database.  If there is no set of fields that functions as a
key, this should include all projected fields.  The third argument is a
(tree-encoded) relation that provides a default value for fields that have
been projected away.

##let project : (tree -> tree -> tree -> name -> name -> lens) =
##  Native.Relational.project

#{*}
test project {A} {A} [{B = {7}}] "R" "S" /
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { S = [{A = {1}},
              {A = {2}}]}
#{@}
In the \PUT{} direction, deletions in the abstract database cause deletions in
the concrete database.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}}]}
       { R = [{A = {1}, B = {5}},
              {A = {2}, B = {6}},
              {A = {2}, B = {5}}]}
     = { R = [{A = {1}, B = {5}}]}
#{@}
Additions in the abstract database become additions in the concrete database
and make use of the default record.
#{*}
test project {A} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}},
              {A = {2}}]}
       { R = [{A = {1}, B = {5}}]}
     = { R = [{A = {1}, B = {5}},
              {A = {2}, B = {7}}]}
#{@}
Modifying one of the values in a projected field will have the same effect as
a deletion and an insertion, thus causing the fields that were projected away
to revert to the default values given in the lens.
#{*}
test project {A, C} {A, C} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {7}, C = {3}}]}
#{@}
This can be prevented by specifying which set of the projected fields may be
regarded as key fields.  Modifying values in non-key fields will then have the
desired effect.
#{*}
test project {A, C} {A} [{B = {7}}] "R" "S" \
       { S = [{A = {1}, C = {3}}]}
       { R = [{A = {1}, B = {5}, C = {2}}]}
     = { R = [{A = {1}, B = {5}, C = {3}}]}
#{@}
The behavior is not specified if the set of key fields given is not
actually a key.

\LENSSECTION{ijoin}
The lens @ijoin A B r s t@ replaces the relations @r@ and @s@ by a new relation @t@
containing the inner join of @r@ and @s@.  The join is performed on the fields
of @r@ and @s@ that share the same names.

##let ijoin : (schema -> schema -> name -> name -> name -> lens) =
##  Native.Relational.ijoin

The inner join is simply a cross product when the two relations share no column
names.
#{*}
test ijoin Any Any "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{B = {3}},
             {B = {4}}]}
     = {T = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}},
             {A = {2}, B = {4}}]}
#{@}
If the two relations both have the same set of column names, an inner join is
equivalent to an intersection operation.
#{*}
test ijoin Any Any "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
A more complex join can occur when there is some overlap in the set of column
names in each relation.
#{*}
test ijoin Any Any "R" "S" "T" /
       {R = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}}],
        S = [{A = {1}, C = {5}}]}
     = {T = [{A = {1}, B = {3}, C = {5}},
             {A = {1}, B = {4}, C = {5}}]}
#{@}

There are a couple of important considerations for the \PUT{} direction.  In
the case where data appearing in one record of @r@ or @s@ are duplicated in
several records of @t@ (as in a cross-product), the insertion and deletion of
records from @t@ may be highly constrained so that repeated information is
added, deleted, or updated in a consistent manner.  In other words, the \PUT{}
direction of this lens is not total on the domain of all relations with the
field names that agree with @t@.  However, for efficiency reasons, our lens
will not raise an error when the abstract tree lies outside of the appropriate
domain.

In the case that a record has been deleted from @t@, this may be reflected in
the concrete dababase by the deletion of a record @r@ or @s@ or both.  The
behavior of @ijoin@ is determined by the schema parameters @A@ and @B@.  If an
addition in @t@ is described by the schema @A@ (resp. @B@), the deletion will
be propagated to @r@ (resp. @s@).  A runtime error will occur if an addition
in @t@ is not described by either schema.
#{*}
test ijoin Any Any "R" "S" "T" \
       {T = [{A = {5}}]}
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {R = [{A = {2}},
             {A = {5}}],
        S = [{A = {3}},
             {A = {5}}]}
#{@}
Another subtle point is that the addition of a record in @t@ can cause the
addition of a record in one of the relations of the concrete tree (@s@ below)
while causing an update of the other relation in the concrete tree (@r@ below).
#{*}
test ijoin Any Any "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

#{*}
test ijoin Any {} "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

#{*}
test ijoin {} Any "R" "S" "T" \
       {T = [{A = {2}, B = {5}, C = {8}},
             {A = {4}, B = {6}, C = {7}}]}
       {R = [{A = {1}, B = {5}},
             {A = {2}, B = {6}}],
        S = [{A = {1}, C = {7}},
             {A = {3}, C = {8}}]}
     = {R = [{A = {1}, B = {5}},
             {A = {2}, B = {5}},
             {A = {4}, B = {6}}],
        S = [{A = {2}, C = {8}},
             {A = {3}, C = {8}},
             {A = {4}, C = {7}}]}
#{@}

\LENSSECTION{ijoin1}
We may wish to have an abbreviation for a join that always propagates
deletions to the left table but not to the right.

#*let ijoin1 : (name -> name -> name -> lens) = ijoin Any {}

\LENSSECTION{ijoin2}
We may also wish to have an abbreviation for a join that always propagates
deletions to both tables.

#*let ijoin2 : (name -> name -> name -> lens) = ijoin Any Any


\LENSSECTION{ojoin}
The lens @ojoin D1 D2 A1 A2 B1 B2 r s t@ is a generic version of an outer
join.  The first six parameters control the behavior of the \PUT{} direction.
The parameter @D1@ (resp. @D2@) should be a non-empty list of records containing
the default values for the fields of @s@ (resp. the fields of @r@) that do not
occur in @t@ (that is, the table in the abstract database that is the outer
join of @r@ and @s@).  If @D1@ or @D2@
has more that one item, then multiple records will be added to @t@ for each
unmatched record in the corresponding source table.  The parameter @A1@ (resp.
@A2@) should be a schema that defines the set of records, which, when added in
the abstract database with the default values for the fields unique to @s@
(resp. @r@), will result in additions to @r@ (resp. @s@) in the \PUT{}
direction.  The parameter @B1@ (resp. @B2@) should be a schema that defines
the set of records, which, when added in the abstract database with the
default value for \emph{both} the fields unique to @s@ and the fields unique
to @r@, will result in additions to @r@ (resp. @s@) in the \PUT{} direction.
The union of @B1@ and @B2@ should cover all possible records that could be
added to @t@ with the default values given by @D1@ and @D2@.

##let ojoin : (tree -> tree -> schema -> schema -> schema -> schema -> name -> name -> name -> lens) =
##  Native.Relational.ojoin

The outer join (like the inner join) is a cross product when the two relations
share no column names.
#{*}
test ojoin [{B = {10}}] [{A = {20}}]
              {A = Any, B = Any} {A = Any, B = Any}
              {A = Any, B = Any} {A = Any, B = Any}
              "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{B = {3}},
             {B = {4}}]}
     = {T = [{A = {1}, B = {3}},
             {A = {1}, B = {4}},
             {A = {2}, B = {3}},
             {A = {2}, B = {4}}]}
#{@}
If the two relations both have the same set of column names, an outer join is
equivalent to a union operation.
#{*}
test ojoin [{}] [{}]
              {A = Any} {A = Any}
              {A = Any} {A = Any}
              "R" "S" "T" /
       {R = [{A = {1}},
             {A = {2}}],
        S = [{A = {1}},
             {A = {3}}]}
     = {T = [{A = {1}},
             {A = {2}},
             {A = {3}}]}
#{@}
A more complex join can occur when there is some overlap in the set of column
names in each relation.
#{*}
test ojoin [{C = {0}}] [{B = {0}}]
              {A = Any, B = Any, C = Any} {A = Any, B = Any, C = Any}
              {A = Any, B = Any, C = Any} {A = Any, B = Any, C = Any}
              "R" "S" "T" /
       {R = [{A = {1}, B = {4}},
             {A = {2}, B = {4}}],
        S = [{A = {1}, C = {6}},
             {A = {3}, C = {7}}]}
     = {T = [{A = {1}, B = {4}, C = {6}},
             {A = {2}, B = {4}, C = {0}},
             {A = {3}, B = {0}, C = {7}}]}
#{@}

As in the case of @join@, the \PUT{} direction of the lens is not total on the
domain of all relations with field names that match the output relation.

In the case that a record has been deleted from @t@, it will cause a deletion
in both @r@ and @s@ in the \PUT{} direction.  In the case of additions, some
additions are necessary in the concrete relations.  When an addition is made
with non-default values for the fields belonging to a concrete table, it will
be necessary to add it to that concrete relation.  When an addition is made
with default values for the fields unique to one concrete table (or both),
then the schema parameters will determine to which concrete tables the
addition will be propagated (as described above).
#{*}
test ojoin [{C = {0}}] [{B = {0}}]
              {A = Any, B = {0}, C = Any}
              {A = Any, B = Any, C = {0}}
              {A = Any, B = {0}, C = {0}}
              {A = Any, B = {0}, C = {0}}
              "R" "S" "T" \
       {T = [{A = {3}, B = {0}, C = {0}},
             {A = {4}, B = {0}, C = {9}},
             {A = {5}, B = {7}, C = {0}},
             {A = {6}, B = {8}, C = {9}}]}
       {R = [{A = {1}, B = {7}},
             {A = {2}, B = {8}}],
        S = [{A = {1}, C = {9}}]}
     = {R = [{A = {3}, B = {0}},
             {A = {4}, B = {0}},
             {A = {5}, B = {7}},
             {A = {6}, B = {8}}],
        S = [{A = {3}, C = {0}},
             {A = {4}, C = {9}},
             {A = {5}, C = {0}},
             {A = {6}, C = {9}}]}
#{@}

#{*}
test ojoin [{C = {0}}] [{B = {0}}]
              {A = {}, B = {0}, C = Any}
              {A = {}, B = Any, C = {0}}
              {A = {}, B = {0}, C = {0}}
              {A = Any, B = {0}, C = {0}}
              "R" "S" "T" \
       {T = [{A = {3}, B = {0}, C = {0}},
             {A = {4}, B = {0}, C = {9}},
             {A = {5}, B = {7}, C = {0}},
             {A = {6}, B = {8}, C = {9}}]}
       {R = [{A = {1}, B = {7}},
             {A = {2}, B = {8}}],
        S = [{A = {1}, C = {9}}]}
     = {R = [{A = {5}, B = {7}},
             {A = {6}, B = {8}}],
        S = [{A = {3}, C = {0}},
             {A = {4}, C = {9}},
             {A = {6}, C = {9}}]}
#{@}


\LENSSECTION{diff}
The lens @diff A B r s t@ replaces the relations @r@ and @s@ by a new relation @t@
containing the set-theoretic difference between @r@ and @s@, \emph{i.e.}~all
of the records that appear in @r@ but not in @s@.

##let diff : (schema -> schema -> name -> name -> name -> lens) = Native.Relational.diff

#{*}
test diff Any Any "R" "S" "T" /
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {T = [{A = {1}}]}
#{@}
In the \PUT{} direction, a deletion in @t@ may result in a modification to @r@
(a deletion) or to @s@ (an addition) or to both tables.  If the additiion in
@t@ is described by the schema @A@ (resp. @B@), the deletion will cause a
modification in @r@ (resp. @s@).  A runtime error will occur if an additiion
in @t@ is not described by either schema.
#{*}
test diff Any Any "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {2}}, {A = {3}}, {A = {4}}],
        S = [{A = {1}}]}
#{@}

#{*}
test diff Any {} "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {2}}, {A = {3}}, {A = {4}}],
        S = []}
#{@}

#{*}
test diff {} Any "R" "S" "T" \
       {T = [{A = {2}}, {A = {3}}, {A = {4}}]}
       {R = [{A = {1}}, {A = {2}}],
        S = [{A = {2}}, {A = {3}}]}
     = {R = [{A = {1}}, {A = {2}}, {A = {3}}, {A = {4}}],
        S = [{A = {1}}]}
#{@}

The case where the concrete argument to \PUT{} is missing is treated just
like the case where the concrete @s@ and @t@ are empty relations:
#{*}
test diff Any Any "R" "S" "T" \
       {T = [{A = {1}}, {A = {2}}]}
       missing
     = {R = [{A = {1}}, {A = {2}}],
        S = []}
#{@}

