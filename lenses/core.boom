(******************************************************************************)
(* The Harmony Project                                                        *)
(* harmony@lists.seas.upenn.edu                                               *)
(******************************************************************************)
(* Copyright (C) 2008                                                         *)
(* J. Nathan Foster and Benjamin C. Pierce                                    *)
(*                                                                            *)
(* This library is free software; you can redistribute it and/or              *)
(* modify it under the terms of the GNU Lesser General Public                 *)
(* License as published by the Free Software Foundation; either               *)
(* version 2.1 of the License, or (at your option) any later version.         *)
(*                                                                            *)
(* This library is distributed in the hope that it will be useful,            *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(* Lesser General Public License for more details.                            *)
(******************************************************************************)
(* /boomerang/lenses/core.boom                                                *)
(* Imports natively-defined primitives                                        *)
(* $Id$ *)
(******************************************************************************)

module Core = 

#{@}

\section{The Core Definitions}

The first module, @Core@, imports primitive values (defined in the
host language, OCaml) to Boomerang. In @Core@, we do not use any
overloaded or infix operators (e.g., @.@, @|@, @~@, @-@, @*@) because
the Boomerang type checker resolves these symbols to applications of
functions defined in @Core@. The reason that we do this, rather than
resolving them directly to the primitive values, is that it facilitates 
checking the preconditions on primitive values using dependent refinement
types. 

Every value defined in @Core@ is available by default in every
Boomerang program.

\subsection{Equality}

\LENSSECTION{equals} The polymorphic @equals@ operator is partial: 
comparing function, lens, or canonizer values results in a run-time 
expception. The infix @=@ operator desugars into @equals@.

#* let equals : forall 'a => 'a -> 'a -> bool 
## = Native.Prelude.poly_equal

#* test equals{string} "ABC" "ABC" = true
#* test equals{string} "ABC" "123" = false
#* test equals{char} 'A' '\065' = true 
#* test equals{string -> string} 
#*   (fun (x:string) -> x) (fun (y:string) -> y) = error

\subsection{Booleans}

\LENSSECTION{@land@, @lor@, @not@} These operators are the standard
functions on booleans. The infix operators @&&@ and @||@ resolve to 
@land@ and @lor@ respectively 
(when applied to booleans; @||@ also resolves to @lens_union@ when 
applied to lenses.)

#* let land : bool -> bool -> bool 
## = Native.Prelude.land
#* let lor : bool -> bool -> bool 
## = Native.Prelude.lor
#* let not : bool -> bool
## = Native.Prelude.not
#* let implies : bool -> bool -> bool 
## = (fun (b1:bool) -> (fun (b2:bool) -> lor b2 (not b1)))

\subsection{Integers}

\LENSSECTION{@string_of_int@} The operator @string_of_int@ converts an 
integer to a string in the obvious way.

#* let string_of_int : int -> string 
## = Native.Prelude.string_of_int

\LENSSECTIONnott{@bgt@, @blt@, @bgeq@, @bleq@} These operators are 
the standard comparisons on integers. Infix operators @>@, @<@, @>=@, @<=@ 
resolve to these operators. In this module, we bind them to names like 
@bgt@ here because @gt@ is a reserved keyword.

#* let bgt : int -> int -> bool
## = Native.Prelude.gt
#* let blt : int -> int -> bool
## = Native.Prelude.lt
#* let bgeq : int -> int -> bool 
## = Native.Prelude.geq
#* let bleq : int -> int -> bool 
## = Native.Prelude.leq

## test bgt 1 0 = true
## test blt 1 0 = false
## test bgeq 1 1 = true
## test bgeq 1 0 = true
## test bgeq 0 1 = false
## test bleq 3 4 = true

\LENSSECTION{@plus@, @minus@, @times@, @div@, @mod@} 
These operators are the standard arithmetic functions on integers.

#* let plus : int -> int -> int 
## = Native.Prelude.plus
#* let minus : int -> int -> int 
## = Native.Prelude.minus
#* let times : int -> int -> int 
## = Native.Prelude.times
#* let bdiv : int -> int -> int 
## = Native.Prelude.div
#* let bmod : int -> int -> int 
## = Native.Prelude.mod

\subsection{Characters}

\LENSSECTION{@string_of_char@} The @string_of_char@ function converts 
a character to a string.

#* let string_of_char : char -> string 
## = Native.Prelude.string_of_char

\subsection{Strings}

\LENSSECTION{@string_concat@} The @string_concat@ operator is the 
standard string concatenation function. The overloaded infix @.@ operator 
resolves to @string_concat@ when it is applied to strings.

#* let string_concat : string -> string -> string 
## = Native.Prelude.string_concat 

\subsection{Regular Expressions}

\LENSSECTION{@str@} The @str@ function converts a @string@ to the singleton 
@regexp@ containing it. This coercion is automatically inserted by the type 
checker on programs that use subtyping. However, it is occasionally useful 
to explicitly promote strings to regexps, so we include it here. 
(Also, strings delimited by @/@ in the lexer desugar into applications of 
@str@.)

#* let str : string -> regexp
## = Native.Prelude.str

\LENSSECTION{@EMPTY@}
The regular expression @empty@ denotes the empty set of strings.

#* let EMPTY : regexp = []

\LENSSECTION{@EPSILON@}
The regular expression @epsilon@ denotes the singleton set containing the 
empty string.

#* let EPSILON : regexp = (str "")

\LENSSECTION{@string_of_regexp@} The @string_of_regexp@ function 
 a regular expression to a string.

#* let string_of_regexp : regexp -> string 
## = Native.Prelude.string_of_regexp

\LENSSECTION{@regexp_union@} The @regexp_union@ operator forms the union of two values of type @regexp@.
The overloaded infix symbol @|@ desugars into @regexp_union@ when used with values of type @regexp@.

#* let regexp_union : regexp -> regexp -> regexp 
## = Native.Prelude.regexp_union

\LENSSECTION{@regexp_concat@} The @regexp_concat@ operator forms the concatenation of two values of 
type @regexp@. The overloaded infix symbol @.@ desugars into @regexp_concat@ when used with values of 
type @regexp@.

#* let regexp_concat : regexp -> regexp -> regexp
## = Native.Prelude.regexp_concat 

\LENSSECTION{@regexp_iter@} The @regexp_iter@ operator iterates a @regexp@. The overloaded symbols 
@*@, @+@, and @?@, as well as iterations @{n,m}@ and @{n,}@ all desugar into @regexp_iter@ when 
used with values of type @regexp@. If the second argument is negative, then the iteration is unbounded. 
For example,  @R*@ desugars into @regexp_iter R 0 (-1)@.

#* let regexp_iter : regexp -> int -> int -> regexp 
## = Native.Prelude.regexp_iter

\LENSSECTION{@inter@} The @inter@ operator forms the intersection of two @regexp@ values.
The infix symbol @&@ desugars into @inter@.

#* let inter : regexp -> regexp -> regexp 
## = Native.Prelude.inter

\LENSSECTION{@diff@} The @diff@ operator forms the difference of two @regexp@ values.
The infix symbol @-@ desugars into @diff@.

#* let diff : regexp -> regexp -> regexp 
## = Native.Prelude.diff

\LENSSECTION{@representative@} The function @representative@ computes a (typically shortest) 
representative of a regular expression whose length is minimal. 

#* let representative : regexp -> string 
## = Native.Prelude.representative

If the regular expression denotes the empty language, an exception is raised, 
as the unit test below demonstrates.

#* test representative (regexp_iter [A-Z] 1 3) = "A"
#* test representative [] = error

\LENSSECTION{@is_empty@} The @is_empty@ function tests if a regular expression 
denotes the empty language.

#* let is_empty : regexp -> bool 
## = Native.Prelude.is_empty

#* test is_empty [] = true
#* test is_empty [A-Z] = false
#* test is_empty (diff [A-Z] [^]) = true

\LENSSECTION{@equiv@} The @equiv@ function tests if two regular expressions denote
the same language.

#* let equiv : regexp -> regexp -> bool
## = Native.Prelude.equiv

#* test equiv [A-Z] [\065-\090] = true

\LENSSECTION{@matches@} The @matches@ function tests if a string belongs to the language 
denoted by a regular expression.

#* let matches : regexp -> string -> bool 
## = Native.Prelude.matches

#* test matches [A-Z] "A" = true
#* test matches [A-Z] "0" = false
#* test matches (diff [^] [A-Z]) "X" = false
#* test matches (diff [^] [A-Z]) "0" = true

\LENSSECTION{@disjoint@,@disjoint_cex@} The @disjoint@ function tests whether
two regular expressions denote disjoint languages.

#* let disjoint : regexp -> regexp -> bool
##   = Native.Prelude.disjoint

#* let disjoint_cex : regexp -> regexp -> bool
##   = Native.Prelude.disjoint_cex

#* test disjoint [A-Z] [0-9] = true
#* test disjoint [A-Z] [M] = false

\LENSSECTION{@splittable@,@splittable_cex@} The @splittable@ function tests 
whether the concatenation of two regular expressions is ambiguous.

#* let splittable : regexp -> regexp -> bool 
## = Native.Prelude.splittable

#* let splittable_cex : regexp -> regexp -> bool
## = Native.Prelude.splittable_cex

#* test splittable (regexp_iter [A] 0 1) (regexp_iter [A] 0 1) = false
#* test splittable (regexp_iter [A] 1 1) (regexp_iter [A] 0 1) = true

\LENSSECTION{@iterable@,@iterable_cex@} The @iterable@ function tests whether the 
iteration of a regular expression is ambiguous.

#* let iterable : regexp -> bool 
## = Native.Prelude.iterable

#* let iterable_cex : regexp -> bool
## = Native.Prelude.iterable_cex

#* test iterable (regexp_iter [A] 0 1) = false
#* test iterable (regexp_iter [A] 1 1) = true

\LENSSECTION{@count@} The @count@ function takes as arguments a regular 
expresion @R@ and a string @w@. It returns the maximum number of times 
that @w@ can be split into substrings, such that each substring belongs 
to @R@.

#* let count : regexp -> string -> int 
## = Native.Prelude.count

#* test count [A-Z] "" = 0
#* test count [A-Z] "ABC" = 3
#* test count (regexp_iter [A-Z] 0 1) "ABC" = 3
#* test count (regexp_iter [A-Z] 0 1) "123" = 0

\subsection{Lens Components}

\LENSSECTION{@ctype@} The @ctype@ function extracts the concrete type component 
(i.e., the type of the domain of its $\GET$ function) of a lens. The record-style 
projection notation @l.ctype@ and @l.domain_type@ 
both desguar into @ctype@.

#* let ctype : lens -> regexp 
## = Native.Prelude.ctype

\LENSSECTION{@atype@} The @atype@ function extracts the abstract type component 
(i.e., the type of the codomain of its $\GET$ function) of a lens. The 
record-style projection notation @l.atype@ and @l.codomain_type@ 
both desguar into @atype@.

#* let atype : lens -> regexp 
## = Native.Prelude.atype

\LENSSECTION{@get@} The @get@ function extracts the $\GET$ component of a lens. The record-style 
projection notation @l.get@ desguars into @get@.

#* let get : (l:lens -> (c:string where matches (ctype l) c) -> string)
## = Native.Prelude.get

\LENSSECTION{@put@} The @put@ function extracts the $\PUT$ component of a lens. The record-style 
projection notation @l.put@ desguars into @put@.

#* let put : (l:lens ->
#*           (a:string where matches (atype l) a) -> 
#*           (c:string where matches (ctype l) c) -> 
#*           string)
## = Native.Prelude.put 

\LENSSECTION{@create@} The @create@ function extracts the $\CREATE$ 
component of a lens. The record-style projection notation @l.create@ 
desguars into @create@.

#* let create : (l:lens -> 
#*              (a:string where matches (atype l) a) -> 
#*              string)
## = Native.Prelude.create 

\LENSSECTION{@bij@} The @bij@ function tests whether a lens is bijective. 
The record-style projection notation @l.bij@ desugars into @bij@.

#* let bij : lens -> bool 
## = Native.Prelude.bij

\LENSSECTION{@in_lens_type@} The @in_lens_type@ function tests whether a lens
is in a given @ctype@ and @atype@.  The @lens in C <-> A@ notation desugars 
into @in_lens_type@.

#* let in_lens_type (l:lens) (C:regexp) (A:regexp) : bool =
#*   (land (equiv (ctype l) C) (equiv (atype l) A))

\LENSSECTION{@in_lens_type@} The @in_lens_type@ function tests whether a lens
is bijective in a given @ctype@ and @atype@.  The @lens in C <=> A@ notation 
desugars into @in_bij_lens_type@.

#* let in_bij_lens_type (l:lens) (C:regexp) (A:regexp) : bool =
#*   (land (land (equiv (ctype l) C) (equiv (atype l) A))
#*         (bij l))

\subsection{Lenses}

\LENSSECTION{@copy@} The @copy@ lens takes a regular expression @R@ 
as an argument and copies strings belonging to @R@ in both directions.

#* let copy (R:regexp) : (l:lens where in_bij_lens_type l R R)
## = Native.Prelude.copy R

#* test get (copy [A-Z]) "A" = "A"
#* test put (copy [A-Z]) "B" "A" = "B"
#* test create (copy [A-Z]) "Z" = "Z"
#* test get (copy [A-Z]) "1" = error
#* test ctype (copy [A-Z]) = [A-Z]
#* test atype (copy [A-Z]) = ctype (copy [A-Z])

\LENSSECTION{@const@} The @const@ lens takes as arguments a regular 
expression @R@, a string @u@, and a string @v@. Its $\GET$ function 
is the constant function that returns @u@, its $\PUT$ function 
restores its concrete argument, and its $\CREATE$ function returns 
the default string @v@.

#* let const (R:regexp) (u:string) (v:string where matches R v)
#*   : (l:lens where in_lens_type l R (str u))
##   = Native.Prelude.const R u v

#* test get (const [A-Z] "x" "A") "A" = "x"
#* test put (const [A-Z] "x" "A") "x" "B" = "B"
#* test create (const [A-Z] "x" "A") "x" = "A"


\LENSSECTION{@set@} The @set@ derived lens is like @const@ but uses an arbitrary representative 
of @R@ as the default string. The infix operator @<->@ desugars to @set@.

#* let set (R:regexp) (s:string) : (l:lens where in_lens_type l R (str s))
#*   = const R s (representative R)

\LENSSECTION{@rewrite@} The @rewrite@ derived lens is like @set@ but only rewrites strings, and so 
is bijective. The infix operator @<=>@ desugars to @rewrite@.

#* let rewrite (s1:string) (s2:string) 
#*   : (l:lens where in_bij_lens_type l (str s1) (str s2))
#*   = const (str s1) s2 s1 

\LENSSECTION{@lens_union@} The @lens_union@ operator forms the union of 
two lenses. The concrete types of the two lenses must be disjoint. The 
overloaded infix operator @||@ desugars into @lens_union@ when applied 
to lens values.

#* let lens_union (l1:lens) (l2:lens where disjoint_cex (ctype l1) (ctype l2))
#*   : (l:lens where in_lens_type l 
#*          (regexp_union (ctype l1) (ctype l2))
#*          (regexp_union (atype l1) (atype l2)))
## = Native.Prelude.lens_union l1 l2

#* test get (lens_union (copy [A-Z]) (copy [0-9])) "A" = "A"
#* test get (lens_union (copy [A-Z]) (copy [0-9])) "0" = "0"
#* test create (lens_union (copy [A-Z]) (copy [0-9])) "A" = "A"
#* test lens_union (copy [A-Z]) (copy [^]) = error

\LENSSECTION{@lens_disjoint_union@} The @lens_disjoint_union@ operator  
also forms the union of two lenses. However, it requires that the concrete 
and abstract types of the two lenses be disjoint. The overloaded infix 
operator @|@ desugars into @lens_disjoint_union@ when applied to lens values.

#* let lens_disjoint_union 
#*   (l1:lens) (l2:lens where land (disjoint_cex (ctype l1) (ctype l2)) 
#*                                 (disjoint_cex (atype l1) (atype l2)))
#*   : (l:lens where in_lens_type l
#*          (regexp_union (ctype l1) (ctype l2))
#*          (regexp_union (atype l1) (atype l2)))
## = Native.Prelude.lens_union l1 l2

#* test get (lens_disjoint_union (copy [A-Z]) (copy [0-9])) "A" = "A"
#* test get (lens_disjoint_union (copy [A-Z]) (copy [0-9])) "0" = "0"
#* test lens_disjoint_union (copy [A-Z]) (const [0-9] "A" "0") = error

\LENSSECTION{@lens_concat@} The @lens_concat@ operator forms the 
concatenation of two lenses. The concrete 
and abstract types of the two lenses must each be unambiguously concatenable. 
The overloaded infix operator @.@ desugars into @lens_concat@ when applied to 
lens values.

#* let lens_concat
#*   (l1:lens) (l2:lens where land (splittable_cex (ctype l1) (ctype l2)) 
#*                                 (splittable_cex (atype l1) (atype l2)))
#*   : (l:lens where in_lens_type l (regexp_concat (ctype l1) (ctype l2))
#*                                  (regexp_concat (atype l1) (atype l2)))
## = Native.Prelude.lens_concat l1 l2

#* test get (lens_concat (copy [A-Z]) (copy [0-9])) "A1" = "A1"
#* test put (lens_concat (copy [A-Z]) (copy [0-9])) "B2" "A1" = "B2"
#* test create (lens_concat (copy [A-Z]) (copy [0-9])) "B2" = "B2"


\LENSSECTION{@compose@} The @compose@ operator puts two lenses
in sequence. The abstract type of the lens on the left and the 
concrete type of the lens on the right must be identical.

#* let compose (l1:lens) (l2:lens where equiv (atype l1) 
#*                                            (ctype l2))
#*   : (l:lens where in_lens_type l (ctype l1) (atype l2))
## = Native.Prelude.compose l1 l2

#* test get (compose (const [A-Z] "Z" "A") 
#*                   (const [Z] "X" "Z")) "A" = "X"

\LENSSECTION{@lens_swap@} The @lens_swap@ operator also concatenates lenses. 
However, it swaps the order of the strings it creates on the abstract side. 
As with @lens_concat@, the concrete and abstract types of the two lenses must 
each be unambiguously concatenable. The overloaded infix operator @~@ desugars 
into @lens_swap@ when applied to lens values.

#* let lens_swap (l1:lens) 
#*               (l2:lens where land (splittable_cex (ctype l1) (ctype l2)) 
#*                                   (splittable_cex (atype l2) (atype l1)))
#*   : (l:lens where in_lens_type l (regexp_concat (ctype l1) (ctype l2))
#*                                  (regexp_concat (atype l2) (atype l1)))
## = Native.Prelude.lens_swap l1 l2

#* test get (lens_swap (copy [A-Z]) (copy [0-9])) "A1" = "1A"
#* test put (lens_swap (copy [A-Z]) (copy [0-9])) "2B" "A1" = "B2"
#* test create (lens_swap (copy [A-Z]) (copy [0-9])) "2B" = "B2"

\LENSSECTION{@lens_star@} The @lens_star@ operator iterates a lens zero 
or more times. The iterations of the concrete and abstract types of the 
lens must both be unambiguous.  The overloaded operator @*@ desugars into 
@lens_star@ when applied to a lens.  Recall that @regexp_iter R 0 -1@ is how
@R*@ desugars.

#* let lens_star 
#*   (l:lens where land (iterable_cex (ctype l))
#*                      (iterable_cex (atype l)))
#*   : (l':lens where in_lens_type l' (regexp_iter (ctype l) 0 (minus 0 1))
#*                                    (regexp_iter (atype l) 0 (minus 0 1)))
## = Native.Prelude.lens_star l

#* test get (lens_star (copy [A-Z])) "" = ""
#* test get (lens_star (copy [A-Z])) "ABCD" = "ABCD"
#* test put (lens_star (copy [A-Z])) "AB" "ABCD" = "AB"
#* test create (lens_star (copy [A-Z])) "A" = "A"

\LENSSECTION{@lens_plus@} The @lens_plus@ operator iterates a lens one
or more times. The iterations of the concrete and abstract types of the 
lens must both be unambiguous (when non-empty).  The overloaded operator @+@
desugars into @lens_plus@ when applied to a lens.  Recall that @regexp_iter R 1 -1@ is
how @R+@ desugars.

#* let lens_plus
#*   (l:lens where land (iterable_cex (ctype l))
#*                      (iterable_cex (atype l)))
#*   : (l':lens where in_lens_type l' (regexp_iter (ctype l) 1 (minus 0 1))
#*                                    (regexp_iter (atype l) 1 (minus 0 1)))
## = Native.Prelude.lens_plus l

#* test get (lens_plus (copy [A-Z])) "A" = "A"
#* test get (lens_plus (copy [A-Z])) "ABCD" = "ABCD"
#* test put (lens_plus (copy [A-Z])) "AB" "ABCD" = "AB"
#* test create (lens_plus (copy [A-Z])) "A" = "A"

\LENSSECTION{@lens_option@} The @lens_option@ operator runs a lens once or 
not at all.  The concrete and abstract types of the lens must both be disjoint 
from the empty lens.  The overloaded operator @?@ desugars into @lens_option@
when applied to a lens.

#* let lens_option
#*   (l:lens where land (disjoint_cex (ctype l) EPSILON)
#*                      (disjoint_cex (atype l) EPSILON))
#*   : (l':lens where in_lens_type l' (regexp_union (ctype l) EPSILON) 
#*                                    (regexp_union (atype l) EPSILON))
## = Native.Prelude.lens_option l

#* test get (lens_option (copy [A-Z])) "" = ""
#* test get (lens_option (copy [A-Z])) "A" = "A"
#* test put (lens_option (copy [A-Z])) "B" "" = "B"
#* test create (lens_option (copy [A-Z])) "A" = "A"

\LENSSECTION{@lens_iter@} The @lens_iter@ operator iterates a lens. The iterations of the concrete 
and abstract types of the lens must both be unambiguous. 
The overloaded operators @*@, @+@, @?@, @{m,n}@ and @{n,}@ all 
desugar into instances of @lens_iter@ when applied to a lens. 
If the second argument is $-1$, then the iteration is unbounded. 
For example,  @l*@ desugars into @lens_iter l 0 (-1)@.  The contract 
on the exposed @lens_iter@ is \textit{not} appropriate for all of its uses;
it is only appropriate for positive @m@ and @n@.

#* let lens_iter 
#*  (l:lens where land (splittable_cex (ctype l) (ctype l))
#*                     (splittable_cex (atype l) (atype l)))
#*  (min:int where bgeq min 0) (max:int)
#*  : (l':lens where in_lens_type l' (regexp_iter (ctype l) min max)
#*                                   (regexp_iter (atype l) min max))
## = Native.Prelude.lens_iter l min max

#* test get (lens_iter (copy [A-Z]) 0 4) "" = ""
#* test get (lens_iter (copy [A-Z]) 0 4) "ABCD" = "ABCD"
#* test put (lens_iter (copy [A-Z]) 0 4) "AB" "ABCD" = "AB"
#* test create (lens_iter (copy [A-Z]) 0 4) "A" = "A"

\LENSSECTION{@invert@} The @invert@ operator swaps the $\GET$ and $\CREATE$ components 
of a lens, which must be bijective.

#* let invert (l:lens where bij l) 
#*   : (l':lens where in_bij_lens_type l' (atype l) (ctype l))
##   = Native.Prelude.invert l

#* test get (invert (const [A] "B" "A")) "B" = "A"
#* test invert (const [A-Z] "B" "A") = error

\LENSSECTION{@default@} The @default@ operator takes a lens @l@ and a string @d@ 
as arguments. It overrides @l@'s $\CREATE$ function to use $\PUT$ with @d@.

#* let default : (l:lens -> 
#*               (d:string where matches (ctype l) d) -> 
#*               (l':lens where in_lens_type l' (ctype l) (atype l)))
## = Native.Prelude.default

#* test create (default (const [A-Z] "X" "A") "B") "X" = "B"

\LENSSECTION{@filter@} The @filter@ operator takes two regular expressions @R@ 
and @S@ as arguments and produces a lens whose $\GET$ function
transforms a string belonging to the iteration of the union of @R@ and @S@
by discarding all of the substrings belonging to @R@. The regular expressions
@R@ and @S@ must be disjoint and the iteration of their union must be 
unambiguous.

#* let filter (R:regexp) (S:regexp where land (disjoint_cex R S) 
#*                                            (iterable_cex (regexp_union R S)))
#*   : (l:lens where in_lens_type l (regexp_iter (regexp_union R S) 0 (minus 0 1))
#*                                  (regexp_iter S 0 (minus 0 1)))
##   = Native.Prelude.filter R S

#* test get (filter [A-Z] [0-9]) "A1B2C3" = "123"
#* test put (filter [A-Z] [0-9]) "123456" "A1B2C3" = "A1B2C3456"

\subsection{Dictionary Lenses}

The next few primitives construct lenses for handling ordered data 
called dictionary lenses. For details, see \citet{Boomerang07}.

\LENSSECTION{@key@} The @key@ operator takes a regular expression as an 
argument. Its $\GET$, $\PUT$, and $\CREATE$ components are like
@copy@, but its $\KEY$ component is the identity function on the 
abstract string.

#* let key : (R:regexp -> (l:lens where in_bij_lens_type l R R))
## = Native.Prelude.key

\LENSSECTION{@dmatch@} The @dmatch@ operator takes as arguments a 
string @t@ and a lens @l@. It builds a dictionary lens that applies 
@l@ in the @t@ ``chunk''. The type checker requires that the same lens 
be used for every instance of @dmatch@ with the same tag. In Boomerang, 
we check this condition using a conservative approximation: we assign 
every lens an integer unique identifier when it is constructed and 
require that for each tag @t@, the lenses in each occurrence of 
@dmatch@ with @t@ have the same unique identifier. 

#* let dmatch : string -> (l:lens -> (l':lens where in_lens_type l' (ctype l) (atype l)))
## = Native.Prelude.dmatch

\LENSSECTION{@smatch@} The @smatch@ operator is like @dmatch@ but uses
a similarity-based lookup operator for chunks. The first string 
must represent a floating point number, which is used as the
threshold.

#* let smatch : string -> string -> 
#*              (l:lens -> (l':lens where in_lens_type l' (ctype l) (atype l)))
## = Native.Prelude.smatch

\LENSSECTION{@forgetkey@} The @forgetkey@ operator takes a lens @l@ as an argument.
It behaves like @l@, but overrides its $\KEY$ component with the constant
function returning the empty string.

#* let forgetkey : (l:lens -> (l':lens where in_lens_type l' (ctype l) (atype l)))
## = Native.Prelude.forgetkey

\subsection{Canonizers}

\LENSSECTION{@rel@} The @rel@ datatype splits the equivalence relations on
lens (concreate/abstract) domains into two types: identity equivalences, and 
unknown equivalences.

#* type rel = Identity | Unknown

## let rel_of_is_id (b:bool) : rel = match b with
##   | true -> Identity
##   | false -> Unknown : rel

#* let rel_is_id (r:rel) : bool = 
#*   equals{rel} r Identity

\LENSSECTION{@crel@} The @crel@ function extracts the equivalence relation
on the concrete domain (@ctype@) of a lens.

#* let crel : lens -> rel
## = fun (l:lens) -> rel_of_is_id (Native.Prelude.crel_identity l)

\LENSSECTION{@arel@} The @arel@ function extracts the equivalence relation
on the abstract domain (@atype@) of a lens.

#* let arel : lens -> rel
## = fun (l:lens) -> rel_of_is_id (Native.Prelude.arel_identity l)

\LENSSECTION{@cnrel@} The @cnrel@ function extracts the equivalence relation
on a canonizer's (uncanonized) type.

#* let cnrel : canonizer -> rel
## = fun (cn:canonizer) -> rel_of_is_id (Native.Prelude.cnrel_identity cn)

\LENSSECTION{@canonize@} The @canonize@ function extracts the $\CANONIZE$
component of a canonizer. The record-style projection notation 
@q.canonize@ desguars into @canonize@.

#* let canonize : canonizer -> string -> string
## = Native.Prelude.canonize

\LENSSECTION{@choose@} The @choose@ function extracts the $\CHOOSE$
component of a canonizer. The record-style projection notation 
@q.choose@ desguars into @choose@.

#* let choose : canonizer -> string -> string
## = Native.Prelude.choose

\LENSSECTION{@uncanonized_type@} The @uncanonized_type@ function extracts the ``representative'' 
type component (i.e., the type of the domain of its $\CANONIZE$ function) of a 
canonizer. 

#* let uncanonized_type : canonizer -> regexp 
## = Native.Prelude.uncanonized_type

\LENSSECTION{@canonized_type@} The @canonized_type@ function extracts the ``quotient''  
type component (i.e., the type of the codomain of its $\CANONIZE$ function) of a 
canonizer. 

#* let canonized_type : canonizer -> regexp 
## = Native.Prelude.canonized_type

\LENSSECTION{@in_canonizer_type@} The @in_canonizer_type@ function tests whether a 
canonizer has the given uncanonized and canonized types.

#* let in_canonizer_type (cn:canonizer) (U:regexp) (C:regexp)
##   = (land (equiv (uncanonized_type cn) U)
##           (equiv (canonized_type cn) C))

\LENSSECTION{@canonizer_of_lens@} The @canonizer_of_lens@ operator
builds a canonizer out of a lens with the lens's $\GET$ function as the
$\CANONIZE$ component and  $\CREATE$ as $\CHOOSE$.

#* let canonizer_of_lens (l:lens)
#*   : (cn:canonizer where in_canonizer_type cn (ctype l) (atype l))
##   = Native.Prelude.canonizer_of_lens l

\LENSSECTION{@canonizer_concat@} The @canonizer_concat@ operator
concatenates canonizers. Only the concatenation of types on the left 
side needs to be unambiguous. 

#* let canonizer_concat 
#*   (cn1:canonizer)
#*   (cn2:canonizer where 
#*        land (splittable_cex (uncanonized_type cn1) (uncanonized_type cn2))
#*             (implies (not (land (rel_is_id (cnrel cn1)) (rel_is_id (cnrel cn2))))
#*                      (splittable_cex (canonized_type cn1) (canonized_type cn2))))
#*   : (cn:canonizer where in_canonizer_type cn 
#*           (regexp_concat (uncanonized_type cn1) (uncanonized_type cn2))
#*           (regexp_concat (canonized_type cn1) (canonized_type cn2)))
## = Native.Prelude.canonizer_concat cn1 cn2

\LENSSECTION{@canonizer_union@} The @canonizer_union@ operator
forms the union of two canonizers. The types on the left 
need to be disjoint. 

#* let canonizer_union (cn1:canonizer) 
#*                     (cn2:canonizer where disjoint_cex (uncanonized_type cn1)
#*                                                       (uncanonized_type cn2))
#*   : (cn:canonizer where in_canonizer_type cn
#*           (regexp_union (uncanonized_type cn1) (uncanonized_type cn2))
#*           (regexp_union (canonized_type cn1) (canonized_type cn2)))
##   = Native.Prelude.canonizer_union cn1 cn2

\LENSSECTION{@canonizer_iter@} The @canonizer_iter@ operator
iterates a canonizer. The iteration of the type on the left 
needs to be unambiguous. The overloaded operators @*@, @+@, @?@, 
@{m,n}@ and @{n,}@ all desugar into instances of @canonizer_iter@ when 
applied to a canonizer. If the second argument is negative, then the 
iteration is unbounded. For example,  @q*@ desugars 
into @canonizer_iter q 0 (-1)@.

#* let canonizer_iter
#*   (cn:canonizer where 
#*        land (iterable_cex (uncanonized_type cn))
#*             (implies (not (rel_is_id (cnrel cn)))
#*                      (iterable_cex (canonized_type cn))))
#*   (min:int where bgeq min 0) (max:int)
#* : (cn':canonizer where in_canonizer_type cn' 
#*          (regexp_iter (uncanonized_type cn) min max)
#*          (regexp_iter (canonized_type cn) min max))
## = Native.Prelude.canonizer_iter cn min max

\LENSSECTION{@columnize@} The @columnize@ primitive canonizer wraps 
long lines of text. It takes as arguments an integer @n@, a regular
expression @R@, a character @s@ and a string @nl@. It produces a 
canonizer whose $\CANONIZE$ component takes strings belonging to 
the iteration of @R@, extended so that @s@ and @nl@ may appear 
anywhere that @s@ may, and replaces @nl@ with @s@ globally. Its 
$\CHOOSE$ component wraps a string belonging to the iteration of 
@R@ by replacing @s@ with @nl@ to obtain a string in which 
(if possible) the length of every line is less than or equal to @n@.

#* let columnize 
#*   : int -> (R:regexp -> char -> 
#*     (nl:string where 
#*       disjoint_cex R (regexp_concat (regexp_iter [^] 0 (minus 0 1)) 
#*                                     (regexp_concat (str nl) 
#*                                     (regexp_iter [^] 0 (minus 0 1)))))
#*                     -> canonizer)
## = Native.Prelude.columnize 

\noindent The following unit test illustrates the $\CHOOSE$ component of
@columnize@  (we would normally write @[a-z ]*@ instea of 
@(regexp_iter [a-z ] 0 (minus 0 1))@ in any module other than @Core@.)

#* test choose (columnize 5 (regexp_iter [a-z ] 0 (minus 0 1)) ' ' "\n")
#*        "a b c d e f g" =
#* <<
#*   a b c
#*   d e f
#*   g
#* >>

\subsection{Quotient Lenses}

The next few primitives construct lenses that work up to 
programmer-specified equivalence relations. We call these 
structures quotient lenses. For details, see \citet{QuotientLenses08}.

\LENSSECTION{@left_quot@} The @left_quot@ operator quotients a lens @l@ by 
a canonizer @q@ on the left by passing concrete strings through @q@.  

#* let left_quot 
#*   (cn:canonizer)
#*   (l:lens where land (equiv (canonized_type cn) (ctype l))
#*                      (rel_is_id (cnrel cn)))
#* : (l':lens where in_lens_type l' (uncanonized_type cn) (atype l))
## = Native.Prelude.left_quot cn l

#* test get 
#*   (left_quot (columnize 5 (regexp_iter [a-z ] 0 (minus 0 1)) ' ' "\n")
#*              (copy (regexp_iter [a-z ] 0 (minus 0 1))))
#* <<
#*   a b c
#*   d e f
#*   g
#* >>
#* = "a b c d e f g"

#* test create 
#*   (left_quot (columnize 5 (regexp_iter [a-z ] 0 (minus 0 1)) ' ' "\n")
#*              (copy (regexp_iter [a-z ] 0 (minus 0 1))))
#* "a b c d e"
#* = 
#* <<
#*   a b c
#*   d e
#* >>


\LENSSECTION{@right_quot@} The @right_quot@ operator quotients a lens @l@ by 
a canonizer @q@ on the right by passing abstract strings through @q@.  

#* let right_quot
#*   (l:lens)
#*   (cn:canonizer where land (equiv (canonized_type cn) (atype l))
#*                            (rel_is_id (cnrel cn)))
#* : (l':lens where in_lens_type l' (ctype l) (uncanonized_type cn))
## = Native.Prelude.right_quot l cn

\LENSSECTION{@dup1@} The @dup1@ operator takes as arguments a 
lens @l@, a function @f@, and a regular expression @R@, which 
should denote the codomain of @f@. Its $\GET$ function supplies 
one copy of the concrete string to @l@'s $\GET$ function and one 
to @f@, and concatenates the results. The $\PUT$ and $\CREATE$ functions 
simply discard the part of the string computed by @f@ and use the 
corresponding from @l@ on the rest of the string. The concatenation of 
@l@'s abstract type and the codomain of @f@ must be unambiguous.

#* let dup1 : (l:lens -> 
#*            (string -> string) -> 
#*            (R:regexp -> 
#*            (l':lens where in_lens_type l' (ctype l)
#*                                           (regexp_concat (atype l) R))))
## = Native.Prelude.dup1 

#* test get (dup1 (copy [A-Z]) (get (copy [A-Z])) [A-Z]) "A" = "AA"
#* test put (dup1 (copy [A-Z]) (get (copy [A-Z])) [A-Z]) "BC" "A" = "B"

\LENSSECTION{@dup2@} The @dup2@ operator is like @dup1@ but uses
@f@ to build the first part of the output.

#* let dup2 : (string -> string) -> 
#*            (R:regexp -> 
#*            (l:lens -> 
#*            (l':lens where in_lens_type l' (ctype l)
#*                                           (regexp_concat R (atype l)))))
## = Native.Prelude.dup2 

#* test get (dup2 (get (copy [A-Z])) [A-Z] (copy [A-Z])) "A" = "AA"
#* test put (dup2 (get (copy [A-Z])) [A-Z] (copy [A-Z])) "BC" "A" = "C"

\subsection{Miscellaneous}

\LENSSECTION{@read@} The @read@ function reads the contents of 
a file from the local filesystem.

#* let read : string -> string 
## = Native.Prelude.read

\subsection{Synchronization}

\LENSSECTION{@sync@} The @sync@ function takes a lens an three strings as arguments. It synchronizes
 three strings using a type-respecting synchronization algorithm based on diff3. The synchronization 
type is extracted from the the lens argument.

#* let sync : lens -> string -> string -> string -> 
#*            (string * string * string * string)
## = Native.Prelude.sync
