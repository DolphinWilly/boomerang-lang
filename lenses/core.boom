(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2008                                                          *)
(* J. Nathan Foster and Benjamin C. Pierce                                     *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/core.boom                                                 *)
(* Imports natively-defined primitives                                         *)
(* $Id$ *)
(*******************************************************************************)

module Core = 

(* polymorphic *)
let equals : forall 'a => 'a -> 'a -> bool = 
  Native.Prelude.poly_equal

(* booleans *)
let land : bool -> bool -> bool = 
  Native.Prelude.land
let lor : bool -> bool -> bool = 
  Native.Prelude.lor
let not : bool -> bool = 
  Native.Prelude.not

(* strings *)
let string_concat : string -> string -> string = 
  Native.Prelude.string_concat 

(* regular expressions *) 
let regexp_union : regexp -> regexp -> regexp = 
  Native.Prelude.regexp_union
let regexp_concat : regexp -> regexp -> regexp = 
  Native.Prelude.regexp_concat 
let regexp_iter : regexp -> int -> int -> regexp = 
  Native.Prelude.regexp_iter

let str : string -> regexp =
  Native.Prelude.str
let shortest : regexp -> string = 
  Native.Prelude.shortest
let empty : regexp = 
  Native.Prelude.empty
let inter : regexp -> regexp -> regexp = 
  Native.Prelude.inter
let is_empty : regexp -> bool = 
  Native.Prelude.is_empty
let diff : regexp -> regexp -> regexp = 
  Native.Prelude.diff
let equiv : regexp -> regexp -> bool = 
  Native.Prelude.equiv
let matches : regexp -> string -> bool = 
  Native.Prelude.matches
let disjoint (r1:regexp) (r2:regexp) : bool = 
  is_empty (inter r1 r2)
let splittable : regexp -> regexp -> bool = 
  Native.Prelude.splittable
let iterable : regexp -> bool = 
  Native.Prelude.iterable

(* lenses *)
let ctype : lens -> regexp = 
  Native.Prelude.ctype
let atype : lens -> regexp =
  Native.Prelude.atype
let sync : lens -> string -> string -> string -> string * string * string * string = 
  Native.Prelude.sync


let get (l:lens) (c:string) : string = 
  Native.Prelude.get l c
let put (l:lens) (a:string) (c:string) : string = 
  Native.Prelude.put l a c
let create (l:lens) (a:string) : string = 
  Native.Prelude.create l a

let copy (R:regexp) : lens
  = Native.Prelude.copy R

let const (R:regexp) (u:string) (v:string) : lens
  = Native.Prelude.const R u v

let lens_union (l1:lens) (l2:lens) : lens
  = Native.Prelude.lens_union l1 l2 

let lens_disjoint_union (l1:lens) (l2:lens) : lens =  
  Native.Prelude.lens_disjoint_union l1 l2 

let lens_concat (l1:lens) (l2:lens) : lens = 
  Native.Prelude.lens_concat l1 l2

let lens_iter (l1:lens) (x:int) (y:int) : lens = 
  Native.Prelude.lens_iter l1 x y 
    
let lens_star (l1:lens) : lens = 
  Native.Prelude.lens_star l1

let invert : lens -> lens = 
  Native.Prelude.invert 
let dmatch : string -> lens -> lens = 
  Native.Prelude.dmatch
let smatch : string -> string -> lens -> lens = 
  Native.Prelude.smatch
let compose : lens -> lens -> lens =
  Native.Prelude.compose
let default : lens -> string -> lens =
  Native.Prelude.default
let key : regexp -> lens =
  Native.Prelude.key
let forgetkey : lens -> lens = 
  Native.Prelude.forgetkey
let filter (r1:regexp) (r2:regexp) : lens = 
  Native.Prelude.filter r1 r2
(* canonizers *)
let canonize : canonizer -> string -> string =
  Native.Prelude.canonize
let choose : canonizer -> string -> string = 
  Native.Prelude.choose
let columnize : int -> regexp -> char -> string -> canonizer =
  Native.Prelude.columnize 
let dup1 : lens -> (string -> string) -> regexp -> lens = 
  Native.Prelude.dup1 
let dup2 : lens -> (string -> string) -> regexp -> lens = 
  Native.Prelude.dup2 
let left_quot : canonizer -> lens -> lens = 
  Native.Prelude.left_quot
let right_quot : lens -> canonizer -> lens =
  Native.Prelude.right_quot

let canonizer_concat : canonizer -> canonizer -> canonizer = 
  Native.Prelude.canonizer_concat 
let canonizer_union : canonizer -> canonizer -> canonizer = 
  Native.Prelude.canonizer_union 
let canonizer_iter : canonizer -> int -> int -> canonizer = 
  Native.Prelude.canonizer_iter

(* let columnize : string -> regexp -> string -> string -> canonizer =  *)
(*   Native.Prelude.columnize *)

(* integers *)
let bgt : int -> int -> bool = 
  Native.Prelude.gt
let blt : int -> int -> bool = 
  Native.Prelude.lt
let bgeq : int -> int -> bool = 
  Native.Prelude.geq
let bleq : int -> int -> bool = 
  Native.Prelude.leq
let plus : int -> int -> int = 
  Native.Prelude.plus
let minus : int -> int -> int = 
  Native.Prelude.minus
let times : int -> int -> int = 
  Native.Prelude.times
let bdiv : int -> int -> int = 
  Native.Prelude.div
let bmod : int -> int -> int = 
  Native.Prelude.mod

(* misc utilities *)
let read : string -> string = 
  Native.Prelude.read

(* run-time checking *)
let canonizer_of_lens : lens -> canonizer = 
  Native.Prelude.canonizer_of_lens
let string_of_regexp : regexp -> string = 
  Native.Prelude.string_of_regexp

let blame 'a 'b (i:string * ((int * int) * (int * int))) (v:'a) (es:string) : 'b = 
  Native.Prelude.blame{'a}{'b} i v es

let set (r:regexp) (s:string) = 
  const r s (shortest r)

let rewrite (s1:string) (s2:string) = 
  const s1 s2 s1 
