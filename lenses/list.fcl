#{@}

\section{Module {\tt List}}

##module List =

\subsection{The List Encoding}
\label{sec:listenc}

Lists are represented in Focal as trees of ``cons cells.''  For example, the
list @[1,2]@ is represented by the tree @{HD={1}, TL={HD={2}, TL={NIL}}}@.
This encoding is recognized and treated specially by Harmony's parsing and
printing functions, so the concrete syntax @[1,2]@ can be used freely in
both trees and schemas.

\subsection{Names and Schemas}

\LENSSECTION{HD, TL, NIL} The actual string names of the tags @HD@, @TL@,
and @NIL@ in 
the encoding are an implementation detail.  To avoid writing them in code,
we define three variables of sort @name@ that hold their actual values and
use these variables instead of the literal tags in Focal programming.
##let HD : name = Native.Prelude.hd_tag
##let TL : name = Native.Prelude.tl_tag
##let NIL : name = Native.Prelude.nil_tag

\LENSSECTION{tags} 
It is also convenient to have a tree whose domain is exactly these three
names (for situations where we want to fork on these names, for example):
#*let tags : tree = {`HD, `TL, `NIL}

\LENSSECTION{Nil} 
The schema @Nil@ denotes just the empty list.
#*let Nil : schema = {`NIL={}}
\LENSSECTION{Cons} 
The schema @Cons X Y@ denotes the set of cons cells whose head is of type
@X@ and whose tail is of type @Y@.  (Note that @Y@ need not necessarily be
@List@, though it typically will be.) 
#*let Cons (X: schema) (Y: schema) : schema = {`HD=X, `TL=Y}
\LENSSECTION{T} 
The schema @T X@ (which is written @List.T X@ in other modules) denotes all
lists whose elements have type @X@. 
#*let T (X:schema) : schema =
#*  schema F = Nil | Cons X F in F

\LENSSECTION{NonEmptyList} 
It is also convenient to have a schema denoting just non-empty lists:
#*let NonEmptyList (X:schema) : schema = Cons X (T X)

\subsection{Lenses}

\LENSSECTION{hd} In the \GET{} direction, @hd d@ yields the head of its concrete
argument (which must be a non-empty list).  In the \PUT{} direction, it
yields a list consisting of its 
abstract argument as the head and the tail of its concrete argument as the
tail.  When the concrete argument to \PUT{} is @missing@, it uses its
default argument @d@ as the tail of the result list.
#*let hd (d:tree) : lens = focus HD { `TL = d }

#*test (hd [{2}]) / [{1}] = {1}
#*test (hd [{2}]) / [] = error
##test (hd [{2}]) / [[{1}]] = [{1}]
#*test (hd [{2}]) \ {1} [{2},{3}] = [{1},{3}]
#*test (hd [{2}]) \ {1} missing = [{1},{2}]

\LENSSECTION{tl} Similarly, @tl d@ yields the tail of its (non-empty)
concrete argument in the \GET{} direction; in the \PUT{} direction, it
recombines a new abstract tail with the original concrete head (or with @d@
when the concrete argument to the \PUT{} is @missing@).
#*let tl (d:tree) : lens = focus TL { `HD = d }

#*test (tl {}) / [{1},{2},{3}] = [{2},{3}]
#*test (tl {}) \ [{2},{3}] missing = [{},{2},{3}]
#*test (tl {}) \ [{2},{3}] [{1}]  = [{1},{2},{3}]
#*test (tl {}) / [] = error

\LENSSECTION{map}
The lens @map l@ applies @l@ to each element of its argument, which must be
a list.  In the \PUT{} direction, the resulting list will have the same
length as the abstract argument; if the abstract argument is longer than the
concrete one, then the elements at the end will be \PUT{} into @missing@.

#*let map (l:lens) : lens = 
#*  mapn HD l;
#*  mapn TL (protect (map l))

#*test (map (const {b} {c})) / [] = []
#*test (map (const {b} {c})) / [{1},{2},{3}] = [{b},{b},{b}]
#*test (map (const {b} {c})) \ [{b}] [{1},{2}] = [{1}]
#*test (map (const {b} {c})) \ [{b},{b},{b}] [{1},{2}] = [{1},{2},{c}]
#*test (map (const {b} {c})) \ [{b}] missing = [{c}]

\LENSSECTION{fold_right}
The lens @fold_right init l@ is analogous to the familiar @fold_right@
function on lists in any functional programming language. In the \GET{}
direction, the lens @l@ is recursively applied to the tail of the list,
or the @init@ tree is used if the list is empty. In the \PUT{} direction,
$@l@ \lputn$ is recursively applied to the abstract tree and the concrete
list, until the abstract tree is exactly @init@. For that reason, note
that @l@ must not return @init@.

#*let fold_right (init:tree) (l:lens) : lens =
#*  mapn TL (protect (fold_right init l));
#*  acond [] init
#*    (const init [])
#*    l

The following lens uses @fold_right@ to transform a list of values into a {\em chain} of
values.
#*let fold_right_test : lens = fold_right {} (pivot HD; Prelude.map (hoist TL))

#*test fold_right_test / [] = {}
#*test fold_right_test / [{1},{2},{3}] = {1={2={3}}}
#*test fold_right_test \ {2={4={6}}} [{1},{hello}] = [{2},{4},{6}]

#*test fold_right {bar} (const {foo} {new}) / [{1},{2}] = {foo}
#*test fold_right {bar} (const {foo} {new}) / [] = {bar}
#*test fold_right {bar} (const {foo} {new}) \ {foo} [{1},{2}] = [{1},{2}]
#*test fold_right {bar} (const {foo} {new}) \ {foo} missing = {new}
#*test fold_right {bar} (const {foo} {new}) \ {baz} {anyway} = error
\finish{Need double-check.}

\LENSSECTION{reverse} The bijective lens @reverse@ simply reverses its
argument list in both directions.  \finish{Some explanation needed.}
#*let reverse : lens = 
#*  let old_HD : name = "old_hd" in
#*  let rotate : lens = 
#*    acond  ([] | [Any]) ([] | [Any])
#*        id
#*        (rename HD old_HD;
#*         hoist_nonunique TL tags;
#*         xfork {`old_HD, `TL} {`TL}
#*           (rename old_HD HD;
#*            plunge TL;
#*            mapn TL (protect rotate))
#*           id) 
#*  in
#*    mapn TL (protect reverse);
#*    rotate

#*test reverse / \ [] = []
#*test reverse / \ [{1},{2},{3}] = [{3},{2},{1}]

##test reverse \ [] missing = []
##test reverse \ [] [{1},{2},{3}] = []
##test reverse \ [{3},{2},{1}] [] = [{1},{2},{3}]

\LENSSECTION{concat2} The bijective lens @concat2 sep@ transforms (in the \GET{}
direction) a list of two lists into a single list consisting of the elements
of the two given lists appended together and separated by @sep@ (which must
not occur in either of the given lists).  In the \PUT{} direction, a single
abstract list is split (at the single occurrence of @sep@) into a pair of
concrete lists.  \finish{Explain how it works.}
#*let concat2 (sep:name) : lens = 
#*  acond ([]::Any) ({`sep={}}::Any)
#*    (mapn HD (const {`sep} []); mapn TL (hd []))
#*    (fork {`TL} id (hoist HD; rename TL "tmp");
#*     fork {`HD} id (rename "tmp" HD; protect (concat2 sep); plunge TL))

#*test (concat2 " ") / \ [[],[]] 
#*                     = [{" "}]
#*test (concat2 " ") / \ [[{u}],[{p},{e},{n},{n}]] 
#*                     = [{u},{" "},{p},{e},{n},{n}]
#*test (concat2 " ") / \ [[{u},{n},{i},{v}],[{p},{e},{n},{n}]] 
#*                     = [{u},{n},{i},{v},{" "},{p},{e},{n},{n}]      

\LENSSECTION{groupby2} The bijective lens @groupby2@ takes a list (in the
\GET{} direction) and yields a list of lists, all of whose elements are of
length exactly two, except the last, which can have length either one or
two.  I.e., @groupby2@ groups a list into pairs, possibly with a leftover
singleton at the end.  The \PUT{} direction simply concatenates such a list
of lists.  \finish{Needs some explanation of how it works.}
#{*}
let groupby2 : lens = 
  acond [] []
    id
    (acond [Any] [[Any]]
       (plunge HD; add TL { `NIL={} })
       (rename HD "tmp";
        hoist_nonunique TL tags;
        fork { `TL } 
          (Prelude.map (protect groupby2))
          (xfork { `HD } { `TL }
             (add TL { `NIL={} }; plunge TL)
             (rename "tmp" HD);
           plunge HD)))
#{@}

#*test groupby2 / \  [] = []
#*test groupby2 / \ [{1}] = [[{1}]]
#*test groupby2 / \ [{1},{2},{3},{4}] = [[{1},{2}], [{3},{4}]]
#*test groupby2 / \ [{1},{2},{3},{4},{5}] = [[{1},{2}], [{3},{4}], [{5}]]

\LENSSECTION{filter} The lens @filter D E d@ maps a concrete list consisting
of elements belonging to @D|E@ and yields (in the \GET{} direction)
a list containing just those elements belonging to @D@.  In the \PUT{}
direction, a new abstract list of @D@s is ``woven back'' into the concrete
list, retaining all the concrete @E@s (and maintaining their positions in
the list) and replacing concrete @D@s by elements from the new abstract
list.  A detailed explanation of @filter@'s implementation may be found
in~\cite{Focal2005}.

#{*}
##(* Begin by defining a simple filter whose GET direction is what we want
##   but whose PUT direction is not. *)
let simple_filter (E:schema) : lens = 
  mapn TL (protect (simple_filter E));
  ccond  (E::Any)
    (tl {"error"})
    id

##(* filter: note that some_D must NOT belong to the schema E *)    
let filter (D:schema) (E:schema) (some_D:tree) : lens =
  let append (v:tree) : lens =
    acond [] [Any]
      (const v {})
      (mapn TL (protect (append v)))
  in
  let filter_aux (D:schema) (E:schema) (some_D:tree) : lens = 
    cond_ff (T E) []  (D::(T D))
      (protect (filter E D {}))
      (append [some_D])
      (const [] [])
      (inner_filter)
  and inner_filter : lens =
##  (* this Any used to be a List containing at least one D *)
    ccond (E::Any) 
      (mapn TL (protect inner_filter); tl {"error"})
      (mapn TL (protect (filter_aux D E some_D)))
  in
    filter_aux D E some_D
#{@}

#{*}
let filter_test : lens = filter {a=Any} {b=Any} {a} 

test filter_test / [] = []
test filter_test / [{a={1}}, {a={2}}, {b={3}}, {a={4}}] 
                 = [{a={1}}, {a={2}}, {a={4}}] 
test filter_test / [{a={1}}, {a={2}}, {a={3}}] 
                 = [{a={1}}, {a={2}}, {a={3}}]

test filter_test \ [{a={1}}, {a={2}}, {a={3}}] 
                   [{a={1}}, {a={2}}, {b={3}}, {a={4}}] 
                 = [{a={1}}, {a={2}}, {b={3}}, {a={3}}] 
test filter_test \ [{a={1}}, {a={2}}, {a={3}}] 
                   [{b={3}}] 
                 = [{b={3}}, {a={1}}, {a={2}}, {a={3}}] 
test filter_test \ [{a={1}}, {a={2}}, {a={3}}] 
                   [{a}, {b={3}}] 
                 = [{a={1}}, {b={3}}, {a={2}}, {a={3}}] 
test filter_test \ [{a={1}}] 
                   [{a},{a},{b={3}}] 
                 = [{a={1}}, {b={3}}]
#{@}


\subsection{Lenses for ``Keyed Lists''}


#@\LENSSECTION{flatten}
%
##let flatten_op : (lens -> lens) = Native.Prelude.flatten_op
##let flatten : lens = flatten_op id
%
The \LN{flatten} lens takes a list of keyed trees and flattens it into a
bush whose top-level children are the keys from the original list:
%
#*test flatten / [{k1={a}}, {k2={b}}] = {k1=[{a}], k2=[{b}]}
The ``keys'' in the concrete list need not be distinct.  If a key @k@ is
repeated, the corresponding subtrees from the original concrete list are
collected into a list under @k@ in the resulting abstract tree:
#*test flatten / [{a={1}}, {b={2}}, {a={3}}] = {a=[{1},{3}], b=[{2}]}
In the \PUT{} direction, the list of subtrees under each key in the abstract
tree is distributed into the corresponding positions in the concrete list.
#*test flatten \ {a=[{4},{6}], b=[{5}]} 
#*               [{a={1}}, {b={2}}, {a={3}}] 
#*             = [{a={4}}, {b={5}}, {a={6}}] 
Any ``left over'' subtrees from the abstract list are placed at the end of
the new concrete list (in some fixed but unspecified order).
#*test flatten \ {a=[{4},{6}], b=[{5}]} 
#*               [{b={1}}, {a={2}}] 
#*             = [{b={5}}, {a={4}}, {a={6}}]
Left over elements of the concrete list are deleted from the result.
#*test flatten \ {a=[{1}], b=[{2}]} 
#*               [{b={1}}, {a={2}}, {a={3}}] 
#*             = [{b={2}}, {a={1}}]

The \LN{flatten} lens is in fact built from the \LN{flatten_op} lens operator,
as @flatten = flatten_op id@.
In the \GET{} direction, @flatten_op l@ applies @l@ to each element then
proceeds as @flatten@.
In the \PUT{} direction, the list of subtrees under each key in the abstract
tree is distributed into the corresponding positions in the concrete list, the
position being determined by the key exhibited by an element of the concrete
list after apply the \GET{} of @l@. The new concrete element is created by the
\PUT{} of @l@.

#*let l : lens = flatten_op (Prelude.filter {a,b} {}) 
#*
#*test l / [{a={1}, z={junk}}, {b={3}}] = {a=[{1}], b=[{3}]}
#*
#*test l \ {b=[{3}]} [{a={1}, z={junk}}, {b={3}}] = [{b={3}}]

It is interesting to notice that @flatten_op l@ is not simply @List.map l; flatten@,
as @List.map@ does not know which elements in the concrete list where deleted, it
simply applies \PUT{} according to the order:
#*let f : lens = Prelude.filter {a,b} {}
#*let l' : lens = map f; flatten
#*test l' / [{a={1}, z={junk}}, {b={3}}] = {a=[{1}], b=[{3}]}
#*
#*test l' \ {b=[{3}]} [{a={1}, z={junk}}, {b={3}}] = [{b={3},z={junk}}]
This surprising result is because of the \PUT{} of @List.map@:
#*test (map f) \ [{b={3}}] [{a={1}, z={junk}}, {b={3}}] = [{b={3},z={junk}}]


Currently, @flatten_op@ is defined as a built-in lens.  We conjecture that it
can be defined in terms of other, more primitive, lenses, but we have not
(yet) been able to do this.
%

##test flatten / [] = {}
##test flatten / [{a,b}] = error
##test flatten \ {a=[{}]} [{a,b}] = error

\subsection{Conversions Between Names and Lists}

It is sometimes necessary to write lenses that manipulate single names as
strings.  The following primitives form the basis of such lenses: we first
(in the \GET{} direction) use @explode@ or @lines@ to convert the name to a
list of either single characters or lines, as appropriate, then process this
list using the list-processing lenses above, and finally use @implode@ or
@unlines@ to convert the processed list back to a single name.  The
@structuredtext@ example shows this process in detail.

\LENSSECTION{explode} The lens @explode@ converts a @Value@ to a list of
single characters.
##let explode : lens = Native.Prelude.explode

#*test explode / \ {""} = []
#*test explode / \ {focal} = [{f},{o},{c},{a},{l}]
##test explode / \ {"lenses focal"} = [{l},{e},{n},{s},{e},{s},{" "},{f},{o},{c},{a},{l}]
#*test explode / {} = error

\LENSSECTION{implode} The lens @implode@ reverses the action of @explode@.
#*let implode : lens = invert (explode)

#*test implode / \ [{f},{o},{c},{a},{l}] = {focal}

\LENSSECTION{split} The lens @split k@ converts a @Value@ to a list of
values by splitting it at @k@ characters.
##let split (k:name) : lens = Native.Prelude.split k

\LENSSECTION{unsplit} The lens @unsplit@ reverses the action of @split@.
#*let unsplit (k:name) : lens = invert (split k)

\LENSSECTION{lines} The lens @lines@ converts a @Value@ to a list of
values by splitting it at newline characters.
##let lines : lens = split "\n"
#*test lines / {""} = [{""}]
#*test lines / {focal} = [{focal}]
#*test lines / {"lenses
#*              |focal"} 
#*           = [{lenses},{focal}]
#*test lines / {"focal\n"} = [{focal},{""}]
#*test lines / {} = error
#*test lines \ [] missing = error

\LENSSECTION{unlines} The lens @unlines@ reverses the action of @lines@.
#*let unlines : lens = invert (lines)

