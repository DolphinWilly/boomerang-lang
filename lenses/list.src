\section{Module {\tt List}}

##module List =

\subsection{The List Encoding}
\label{sec:listenc}

Lists are represented in Focal as trees of ``cons cells.''  For example, the
list @[1,2]@ is represented by the tree @{HD={1}, TL={HD={2}, TL={NIL}}}@.
This encoding is recognized and treated specially by Harmony's parsing and
printing functions, so the concrete syntax @[1,2]@ can be used freely in
both trees and schemas.

\subsection{Names and Schemas}

\LENSSECTION{HD, TL, NIL} The actual string names of the tags @HD@, @TL@,
and @NIL@ in 
the encoding are an implementation detail.  To avoid writing them in code,
we define three variables of sort @name@ that hold their actual values and
use these variables instead of the literal tags in Focal programming.
##let HD : name = Native.Prelude.hd_tag
##let TL : name = Native.Prelude.tl_tag
##let NIL : name = Native.Prelude.nil_tag

\LENSSECTION{tags} 
It is also convenient to have a tree whose domain is exactly these three
names (for situations where we want to fork on these names, for example):
#*let tags : tree = {`HD, `TL, `NIL}

\LENSSECTION{Nil} 
The schema @Nil@ denotes just the empty list.
#*let Nil : schema = {`NIL={}}
\LENSSECTION{Cons} 
The schema @Cons X Y@ denotes the set of cons cells whose head is of type
@X@ and whose tail is of type @Y@.  (Note that @Y@ need not necessarily be
@List@, though it typically will be.) 
#*let Cons (X: schema) (Y: schema) : schema = {`HD=X, `TL=Y}
\LENSSECTION{T} 
The schema @T X@ (which is written @List.T X@ in other modules) denotes all
lists whose elements have type @X@. 
#*let T (X:schema) : schema =
#*  schema F = Nil | Cons X F in F

\LENSSECTION{NonEmptyList} 
It is also convenient to have a schema denoting just non-empty lists:
#*let NonEmptyList (X:schema) : schema = Cons X (T X)

\subsection{Lenses}

\LENSSECTION{hd} In the \GET{} direction, @hd d@ yields the head of its concrete
argument (which must be a non-empty list).  In the \PUT{} direction, it
yields a list consisting of its 
abstract argument as the head and the tail of its concrete argument as the
tail.  When the concrete argument to \PUT{} is @missing@, it uses its
default argument @d@ as the tail of the result list.
#*let hd (d:tree) : lens = focus HD { `TL = d }

#*test (hd [{2}]) / [{1}] = {1}
#*test (hd [{2}]) / [] = error
##test (hd [{2}]) / [[{1}]] = [{1}]
#*test (hd [{2}]) \ {1} [{2},{3}] = [{1},{3}]
#*test (hd [{2}]) \ {1} missing = [{1},{2}]

\LENSSECTION{tl} Similarly, @tl d@ yields the tail of its (non-empty)
concrete argument in the \GET{} direction; in the \PUT{} direction, it
recombines a new abstract tail with the original concrete head (or with @d@
when the concrete argument to the \PUT{} is @missing@).
#*let tl (d:tree) : lens = focus TL { `HD = d }

#*test (tl {}) / [{1},{2},{3}] = [{2},{3}]
#*test (tl {}) \ [{2},{3}] missing = [{},{2},{3}]
#*test (tl {}) \ [{2},{3}] [{1}]  = [{1},{2},{3}]
#*test (tl {}) / [] = error

\LENSSECTION{map}
The lens @map l@ applies @l@ to each element of its argument, which must be
a list.  In the \PUT{} direction, the resulting list will have the same
length as the abstract argument; if the abstract argument is longer than the
concrete one, then the elements at the end will be \PUT{} into @missing@.

#*let map (l:lens) : lens = wmap { `HD -> l, `TL -> (map l) }

#*test (map (const {b} {c})) / [] = []
#*test (map (const {b} {c})) / [{1},{2},{3}] = [{b},{b},{b}]
#*test (map (const {b} {c})) \ [{b}] [{1},{2}] = [{1}]
#*test (map (const {b} {c})) \ [{b},{b},{b}] [{1},{2}] = [{1},{2},{c}]
#*test (map (const {b} {c})) \ [{b}] missing = [{c}]

\LENSSECTION{fold_right}
The lens @fold_right init l@ is analogous to the familiar @fold_right@
function on lists in any functional programming language. In the \GET{}
direction, the lens @l@ is recursively applied to the tail of the list,
or the @init@ tree is used if the list is empty. In the \PUT{} direction,
$@l@ \lputn$ is recursively applied to the abstract tree and the concrete
list, until the abstract tree is exactly @init@. For that reason, note
that @l@ must not return @init@.

#*let fold_right (init:tree) (l:lens) : lens =
#*  wmap {`TL -> fold_right init l};
#*  acond [] init
#*    (const init [])
#*    l

The following lens uses @fold_right@ to transform a list of values into a {\em chain} of
values.
#*let fold_right_test : lens = fold_right {} (pivot HD; Prelude.map (hoist TL))

#*test fold_right_test / [] = {}
#*test fold_right_test / [{1},{2},{3}] = {1={2={3}}}
#*test fold_right_test \ {2={4={6}}} [{1},{hello}] = [{2},{4},{6}]

#*test fold_right {bar} (const {foo} {new}) / [{1},{2}] = {foo}
#*test fold_right {bar} (const {foo} {new}) / [] = {bar}
#*test fold_right {bar} (const {foo} {new}) \ {foo} [{1},{2}] = [{1},{2}]
#*test fold_right {bar} (const {foo} {new}) \ {foo} missing = {new}
#*test fold_right {bar} (const {foo} {new}) \ {baz} {anyway} = error
\finish{Need double-check.}

\LENSSECTION{reverse} The bijective lens @reverse@ simply reverses its
argument list in both directions.  \finish{Some explanation needed.}
#*let reverse : lens = 
#*  let old_HD : name = "old_hd" in
#*  let rotate : lens = 
#*    acond  ([] | [Any]) ([] | [Any])
#*        id
#*        (rename HD old_HD;
#*         hoist_nonunique TL tags;
#*         xfork {`old_HD, `TL} {`TL}
#*           (rename old_HD HD;
#*            plunge TL;
#*            wmap { `TL -> rotate })
#*           id) 
#*  in
#*    wmap { `TL -> reverse }; 
#*    rotate

#*test reverse / \ [] = []
#*test reverse / \ [{1},{2},{3}] = [{3},{2},{1}]

##test reverse \ [] missing = []
##test reverse \ [] [{1},{2},{3}] = []
##test reverse \ [{3},{2},{1}] [] = [{1},{2},{3}]

\LENSSECTION{concat2} The bijective lens @concat2 sep@ transforms (in the \GET{}
direction) a list of two lists into a single list consisting of the elements
of the two given lists appended together and separated by @sep@ (which must
not occur in either of the given lists).  In the \PUT{} direction, a single
abstract list is split (at the single occurrence of @sep@) into a pair of
concrete lists.  \finish{Explain how it works.}
#*let concat2 (sep:name) : lens =
#*  let tmp : name = "y" in
#*  let tmp2 : name = "x" in
#*  let inner_concat2 : lens = 
#*    acond ([]::Any) ({`tmp={`sep}}::Any) 
#*      (fork {`HD} (map (const {`tmp={`sep}} [])) (wmap {`TL -> hd []}))
#*      (xfork {`HD} {`HD, `tmp2} 
#*         (hoist HD; rename TL tmp2) 
#*         id;
#*       xfork {x, `TL} {`TL} 
#*         (rename tmp2 HD; plunge TL; wmap {`TL -> inner_concat2}) 
#*         id)
#*  in
#*    map (map (plunge tmp));
#*    inner_concat2;
#*    map (hoist tmp)

#*test (concat2 " ") / \ [[],[]] 
#*                     = [{" "}]
#*test (concat2 " ") / \ [[{u}],[{p},{e},{n},{n}]] 
#*                     = [{u},{" "},{p},{e},{n},{n}]
#*test (concat2 " ") / \ [[{u},{n},{i},{v}],[{p},{e},{n},{n}]] 
#*                     = [{u},{n},{i},{v},{" "},{p},{e},{n},{n}]

#{#}
(* let concat : lens = *)
(*   let concat_aux : lens = *)
(*     xfork {`HD} {`HD, "x"} *)
(*       (hoist HD; rename TL "x") *)
(*       id; *)
(*     xfork {"x", `TL} {`TL} *)
(*       (rename "x" HD; plunge TL; *)
(*        wmap {`TL -> concat1}) *)
(*       id *)
(* *)      
(*   and concat1: lens = *)
(*     acond < []::Any > < {" "}::Any > *)
(*       (fork {`HD} *)
(*       (map (rename NIL " ")) *)
(*       (wmap {`TL -> concat2})) *)
(*       (plunge "_"; wmap { "_" -> concat_aux}; hoist "_") *)
(* *)            
(*   and concat2: lens = *)
(*     ccond < [] > *)
(*       id *)
(*       (acond < [`Any] > < List { ! \ (" ") = `Any} > *)
(*          (focus HD {`TL = []} ) *)
(*          (plunge "_"; wmap { "_" -> concat1}; hoist "_")) *)
(*   in concat1 *)
(* test concat / [] = error (\* FIXME: wrong *\) *)
(* test concat / [[a]] = [a, " "] *)
(* test concat \ [a, " "] missing = [[a],[]] (\* FIXME: wrong ??? *\) *)
(* test concat \ [] missing = error (\* FIXME: wrong *\) *)
(* test concat \ [{u},{n},{i},{v},{" "},{o},{f},{" "},{p},{e},{n},{n}] [[{u},{n},{i},{v}]] =  [[{u},{n},{i},{v}],o,f," ",{p},{e},{n},{n}] (\* FIXME: wrong *\) *)
(* test concat / [[{u},{n},{i},{v}],[o,f],[{p},{e},{n},{n}]] = [{u},{n},{i},{v},{" "},{o},{f},{" "},{p},{e},{n},{n}] *)
#{@}

\LENSSECTION{groupby2} The bijective lens @groupby2@ takes a list (in the
\GET{} direction) and yields a list of lists, all of whose elements are of
length exactly two, except the last, which can have length either one or
two.  I.e., @groupby2@ groups a list into pairs, possibly with a leftover
singleton at the end.  The \PUT{} direction simply concatenates such a list
of lists.  \finish{Needs some explanation of how it works.}
#{*}
let groupby2 : lens = 
  let add_empty_tail : lens =
    add TL {};
    wmap { `TL -> add NIL {} } in
  let tmp : name = "tmp" in
  acond [] []
    id
    ( (* (1) save hd of the list under tmp *)
      rename HD tmp;
      (* (2) bring the tail of the list up to the root level *)
      hoist_nonunique TL tags;
      (* split on domain at the root level; two cases:
           (a) tail was empty --> domain is { tmp, nil }
           (b) tail was non-empty --> domain is { tmp, hd, tl } *)
      acond {`tmp=Any,`NIL={}} [[Any]]
        ( (* case (a): yield [[tmp]] *)
          xfork {`NIL} {`TL} (plunge TL) id;
          rename tmp HD;
          plunge HD;
          add_empty_tail)
        ( (* case (b): produce [tmp,hd]::(groupby2 tl) *)
          xfork {`tmp, `HD} {`HD}
            (rename HD TL;
             wmap {`TL -> plunge HD; add_empty_tail };
             rename tmp HD;             
             plunge HD)
             (wmap { `TL -> groupby2 })))
#{@}

#*test groupby2 / \ [] = []
#*test groupby2 / \ [{1}] = [[{1}]]
#*test groupby2 / \ [{1},{2},{3},{4}] = [[{1},{2}], [{3},{4}]]
#*test groupby2 / \ [{1},{2},{3},{4},{5}] = [[{1},{2}], [{3},{4}], [{5}]]

\LENSSECTION{filter} The lens @filter D E d@ maps a concrete list consisting
of elements belonging to @D|E@ and yields (in the \GET{} direction)
a list containing just those elements belonging to @D@.  In the \PUT{}
direction, a new abstract list of @D@s is ``woven back'' into the concrete
list, retaining all the concrete @E@s (and maintaining their positions in
the list) and replacing concrete @D@s by elements from the new abstract
list.  A detailed explanation of @filter@'s implementation may be found
in~\cite{Focal2005}.

#{*}
##(* Begin by defining a simple filter whose GET direction is what we want
##   but whose PUT direction is not. *)
let simple_filter (E:schema) : lens = 
  wmap { `TL -> simple_filter E };
  ccond  (E::Any)
    (tl {"error"})
    id

##(* filter: note that some_D must NOT belong to the schema E *)    
let filter (D:schema) (E:schema) (some_D:tree) : lens =
  let append (v:tree) : lens =
    acond [] [Any]
      (const v {})
      (wmap { `TL -> append v })
  in
  let filter_aux (D:schema) (E:schema) (some_D:tree) : lens = 
    cond_ff (T E) []  (D::(T D))
      (plunge "_"; wmap { "_" -> filter E D {} }; hoist "_")
      (append [some_D])
      (const [] [])
      (inner_filter)
  and inner_filter : lens =
##  (* this Any used to be a List containing at least one D *)
    ccond (E::Any) 
      (wmap { `TL -> inner_filter }; tl {"error"})
      (wmap { `TL -> filter_aux D E some_D } )
  in
    filter_aux D E some_D
#{@}

#{*}
let filter_test : lens = filter {a=Any} {b=Any} {a} 

test filter_test / [] = []
test filter_test / [{a={1}}, {a={2}}, {b={3}}, {a={4}}] 
                 = [{a={1}}, {a={2}}, {a={4}}] 
test filter_test / [{a={1}}, {a={2}}, {a={3}}] 
                 = [{a={1}}, {a={2}}, {a={3}}]

test filter_test \ [{a={1}}, {a={2}}, {a={3}}] 
                   [{a={1}}, {a={2}}, {b={3}}, {a={4}}] 
                 = [{a={1}}, {a={2}}, {b={3}}, {a={3}}] 
test filter_test \ [{a={1}}, {a={2}}, {a={3}}] 
                   [{b={3}}] 
                 = [{b={3}}, {a={1}}, {a={2}}, {a={3}}] 
test filter_test \ [{a={1}}, {a={2}}, {a={3}}] 
                   [{a}, {b={3}}] 
                 = [{a={1}}, {b={3}}, {a={2}}, {a={3}}] 
test filter_test \ [{a={1}}] 
                   [{a},{a},{b={3}}] 
                 = [{a={1}}, {b={3}}]
#{@}


\subsection{Lenses for ``Keyed Lists''}


#@\LENSSECTION{flatten}
%
##let flatten : lens = Native.Prelude.flatten
%
The \LN{flatten} lens takes a list of keyed trees and flattens it into a
bush whose top-level children are the keys from the original list:
%
#*test flatten / [{k1={a}}, {k2={b}}] = {k1=[{a}], k2=[{b}]}
The ``keys'' in the concrete list need not be distinct.  If a key @k@ is
repeated, the corresponding subtrees from the original concrete list are
collected into a list under @k@ in the resulting abstract tree:
#*test flatten / [{a={1}}, {b={2}}, {a={3}}] = {a=[{1},{3}], b=[{2}]}
In the \PUT{} direction, the list of subtrees under each key in the abstract
tree is distributed into the corresponding positions in the concrete list.
#*test flatten \ {a=[{4},{6}], b=[{5}]} 
#*               [{a={1}}, {b={2}}, {a={3}}] 
#*             = [{a={4}}, {b={5}}, {a={6}}] 
Any ``left over'' subtrees from the abstract list are placed at the end of
the new concrete list (in some fixed but unspecified order).
#*test flatten \ {a=[{4},{6}], b=[{5}]} 
#*               [{b={1}}, {a={2}}] 
#*             = [{b={5}}, {a={4}}, {a={6}}]
Left over elements of the concrete list are deleted from the result.
#*test flatten \ {a=[{1}], b=[{2}]} 
#*               [{b={1}}, {a={2}}, {a={3}}] 
#*             = [{b={2}}, {a={1}}]

Currently, @flatten@ is defined as a built-in lens.  We conjecture that it
can be defined in terms of other, more primitive, lenses, but we have not
(yet) been able to do this.
%

##test flatten / [] = {}
##test flatten / [{a,b}] = error
##test flatten \ {a=[{}]} [{a,b}] = error

\subsection{Conversions Between Names and Lists}

It is sometimes necessary to write lenses that manipulate single names as
strings.  The following primitives form the basis of such lenses: we first
(in the \GET{} direction) use @explode@ or @lines@ to convert the name to a
list of either single characters or lines, as appropriate, then process this
list using the list-processing lenses above, and finally use @implode@ or
@unlines@ to convert the processed list back to a single name.  The
@structuredtext@ example shows this process in detail.

\LENSSECTION{explode} The lens @explode@ converts a @Value@ to a list of
single characters.
##let explode : lens = Native.Prelude.explode

#*test explode / \ {""} = []
#*test explode / \ {focal} = [{f},{o},{c},{a},{l}]
##test explode / \ {"lenses focal"} = [{l},{e},{n},{s},{e},{s},{" "},{f},{o},{c},{a},{l}]
#*test explode / {} = error

\LENSSECTION{implode} The lens @implode@ reverses the action of @explode@.
#*let implode : lens = invert (explode)

#*test implode / \ [{f},{o},{c},{a},{l}] = {focal}

\LENSSECTION{split} The lens @split@ converts a @Value@ to a list of
values by splitting it at newline characters.
##let split (k:name) : lens = Native.Prelude.split k

\LENSSECTION{unsplit} The lens @unsplit@ reverses the action of @split@.
#*let unsplit (k:name) : lens = invert (split k)

\LENSSECTION{lines} The lens @lines@ converts a @Value@ to a list of
values by splitting it at newline characters.
##let lines : lens = split "\n"
#*test lines / {""} = [{""}]
#*test lines / {focal} = [{focal}]
#*test lines / {"lenses
#*              |focal"} 
#*           = [{lenses},{focal}]
#*test lines / {"focal\n"} = [{focal},{""}]
#*test lines / {} = error
#*test lines \ [] missing = error

\LENSSECTION{unlines} The lens @unlines@ reverses the action of @lines@.
#*let unlines : lens = invert (lines)

