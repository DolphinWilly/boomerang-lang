\section{Module {\tt Spinelist}}

#{#}
module Spinelist =

(***********************************************************************)
(* "Spine lists" *)

let T (X:schema) : schema = 
  schema G = [] | {!\(`List.TL,`List.NIL)=X, `List.TL=G} in G

(* This is the correct version:
let T (X:schema) : schema = 
  schema G = [] | {`List.HD=X, !\(`List.HD,`List.NIL)=G} in G

To convert keyed lists to this correct version, we need:
- a new primitive: get_key k / { a = v } = v + { k = a }
- rename pivot k to put_key k
*)
  
let KeyedList (X:schema) : schema = List.T {!\`List.TL=X}

let spinelist : lens =
  acond [] []
    id
    (fork {`List.TL} id (hoist List.HD); wmap { `List.TL -> spinelist })

test spinelist / \ [{a},{b={foo}},{c}] = {a, `List.TL={b={foo}, `List.TL={c, `List.TL=[]}}}

(***********************************************************************)
(* Sync tests *)

(* The "jumping element" problem for ordinary lists *)
sync with id at (List.T {!=Value})
  { O = [{a={foo}},{b={bar}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={foo}},{b={bar}},{c={URG}}] }
  = 
  { O = [{a={FOO}},{c={baz}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={FOO}},{c={baz}},{c={URG}}] }

(* With spine lists, the result is happier... *)
sync with spinelist at (T Value)
    { O = [{a={foo}},{b={bar}},{c={baz}}],
      A = [{a={FOO}},{c={baz}}],
      B = [{a={foo}},{b={bar}},{c={URG}}] }
    = 
   { O = [{a = {FOO}}, {c = {baz}}, {c = {baz}}],
     A = [{a = {FOO}}, {c = {baz}}],
     B = [{a = {FOO}}, {c = {baz}}, {c = {URG}}]}

(* who calculated this?? *)
(* 
  { O = [{a={FOO}},{b={bar}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={FOO}},{b={bar}},{c={URG}}] }
*)
