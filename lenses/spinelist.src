\section{Module {\tt Spinelist}}

#{#}
module Spinelist =

(***********************************************************************)
(* "Spine lists" *)

let T (X:type) : type = [] | {!\(`List.TL,`List.NIL)=X, `List.TL=(T X)}

let KeyedList (X:type) : type = List.T {!\`List.TL=X}

let spinelist : lens =
  acond [] []
    id
    (fork {`List.TL} id (hoist List.HD); wmap { `List.TL -> spinelist })

test spinelist / \ [{a},{b={foo}},{c}] = {a, `List.TL={b={foo}, `List.TL={c, `List.TL=[]}}}

(***********************************************************************)
(* Sync tests *)

(* The "jumping element" problem for ordinary lists *)
sync with id at (List.T {!=Value})
  { O = [{a={foo}},{b={bar}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={foo}},{b={bar}},{c={URG}}] }
  = 
  { O = [{a={FOO}},{c={baz}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={FOO}},{c={baz}},{c={URG}}] }
    
(* With spine lists, the result is happier... *)
sync with (spinelist; probe "HERE") at (T Value)
    { O = [{a={foo}},{b={bar}},{c={baz}}],
      A = [{a={FOO}},{c={baz}}],
      B = [{a={foo}},{b={bar}},{c={URG}}] }
    = 
  {A = [{a = {FOO}}, {c = {baz}}],     
   B = [{a = {FOO}}, {c = {baz}}, {c = {URG}}],
   O = [{a = {FOO}}, {c = {baz}}, {c = {baz}}]}

(* who calculated this?? *)
(* 
  { O = [{a={FOO}},{b={bar}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={FOO}},{b={bar}},{c={URG}}] }
*)
