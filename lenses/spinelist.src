\section{Module {\tt Spinelist}}

#{#}
module Spinelist =

(***********************************************************************)
(* "Spine lists" *)

let T (X:schema) : schema =
  schema G = [] | {`List.HD=X, !\(`List.HD,`List.TL,`List.NIL)=G} in G

let put_key : (name -> lens) = pivot
let get_key (k:name) : lens = invert (put_key k)
  
let KeyedList (X:schema) : schema = List.T {!\`List.TL=X}

let spinelist : lens =
  acond [] []
    id
    (mapp {`List.HD} (
        map (plunge "value");
        get_key "key";
        fork {key}
          id
          (rename "value" List.HD));
      xfork {`List.HD} {`List.HD, key}
        (hoist List.HD)
        id;
      fork {`List.HD}
        id
        (put_key "key"; map (wmap {`List.TL -> spinelist}; hoist List.TL)))

test spinelist / \ [{a},{b={foo}},{c}] = {a} :|: {b = {foo}} :|: [| {c}|]

(***********************************************************************)
(* Sync tests *)

(* The "jumping element" problem for ordinary lists *)
sync with id at (List.T {!=Value})
  { O = [{a={foo}},{b={bar}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={foo}},{b={bar}},{c={URG}}] }
  = 
  { O = [{a={FOO}},{c={baz}},{c={baz}}],
    A = [{a={FOO}},{c={baz}}],
    B = [{a={FOO}},{c={baz}},{c={URG}}] }

(* With spine lists, the result is happier... *)
sync with spinelist at (T Value)
    { O = [{a={foo}},{b={bar}},{c={baz}}],
      A = [{a={FOO}},{c={baz}}],
      B = [{a={foo}},{b={bar}},{c={URG}}] }
    =
    { O = [{a={FOO}},{b={bar}},{c={baz}}],
      A = [{a={FOO}},{c={baz}}],
      B = [{a={FOO}},{b={bar}},{c={URG}}] }
