#{#}
module Units = 

  (* ------------- helper functions ------------- *)

  (* unit test herlper: given a schema, yields a lens whose GET
     function is a member test for X *)
  let true : tree = {T}
  let false : tree = {F}
  let member (X:schema) : lens = 
    acond X {1} (const true {}) (const false {})
    
  (* ------------- contractiveness tests ------------- *)

  (* bare recursive variables not OK in cats *)
  test (schema X = X + Any in member X) / {} = error

  (* bare recursive variables not OK in unions *)
  test (schema X = X | Any in member X) / {} = error

  (* bare recursive variables not OK in cats under unions *)
  test (schema X = (X + Any) | Any in member X) / {} = error

  (* bare recursive variables not OK in unions under cats *)
  test (schema X = (X | Any) + Any in member X) / {} = error

  (* recursive variables OK under atoms, wildcards *)
  test (schema X = { n = X } in member X) / {} = false
  test (schema X = { n = X | {} } in member X) / {} = false
  test (schema X = { ! = X } in member X) / {} = false
  test (schema X = { !* = X } in member X) / {} = false
  test (schema X = { * = X } in member X) / {} = true

  (* previously declared variables OK anywhere *)
  test (schema X = { ! \ n = X } in 
        schema Y = X in 
          member Y) / {} = false

  test (schema X = { * \ n = X } in 
        schema Y = { n = Y } + X in 
          member Y) / {} = false

  (* ---------------- domain disjointness tests  ---------------- *)

  (* cats may not contain two atoms with same name *)
  test (member { n = Any, n = Any }) / {} = error

  (* atoms must not overlap with wildcards in the same cat *)
  test (member { * = Any, n = Any }) / {} = error
  test (member (({ n = Any, * \ n = Any } | Any) + { n = Any })) / {} = error
  test (schema X = { n = X } in member ({ n = Any } + X)) / {} = error

  (* wildcards may overlap (modulo projectability) *)
  test (member { * = Any, * = Any, ! = Any } ) / {} = false

  (* -------------- projectability tests --------------- *)
  test (member { * = Any, ! = {} }) / {} = error
  test (member { * = Any, ! = Any }) / {} = false
  test (member ({ * = Any } | { ! = {} }) ) / {} = error
  test (member ({ n = Any } | { ! = {} }) ) / {} = error
  test (member (schema X = { m=X, n=X, ! \ (m,n)=X } | { *=X } in X)) / {} = true

  (* -------------- membership tests --------------- *)
  (* atoms *)
  test (member { a = {} }) / { a = {} } = true
  test (member { a = {} }) / { b = {} } = false
  test (member { a = {}, b = {}}) / { a, b } = true
  
  (* wildcards *)
  test (member { a = {}, ! \ a = {}}) / { a, b } = true
  test (member { a = {}, * \ a = {}}) / { a, b, c, d, e } = true

  (* unions *)
  test (member ({ a = {} } | { b = {} })) / { a } = true
  test (member ({ a = {} } | { b = {} })) / { b } = true
  test (member ({ a = {} } | { b = {} })) / { a,b } = false
  test (member ({ a = {} } | { b = {} })) / { c } = false
  
  (* recursive schemas *)
  test (schema X = { n = X } in member X) / {} = false
  test (schema X = { n = X } | {} in member X) / {} = true
  test (schema X = { n = X } | {} in member X) / { n } = true
  test (schema X = { n = X } | {} in member X) / { n={n={n={n={n={}}}}} } = true

#{@}
