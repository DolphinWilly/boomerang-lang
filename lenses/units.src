#{#}
module Units = 

  (* ------------- helper functions ------------- *)

  (* member test fashioned from the GET function of a (not-quite) lens :) *)
  let true : tree = {T}  
  let false : tree = {F}
  let member (X:schema) (t:tree) : tree = 
    (acond X true (const true {}) (const false {})) / t
    
  (* ------------- contractiveness tests ------------- *)

  (* bare recursive variables not OK in cats *)
  test (schema X = X + Any in member X {}) = error

  (* bare recursive variables not OK in unions *)
  test (schema X = X | Any in member X {}) = error

  (* bare recursive variables not OK in cats under unions *)
  test (schema X = (X + Any) | Any in member X {}) = error

  (* bare recursive variables not OK in unions under cats *)
  test (schema X = (X | Any) + Any in member X {}) = error

  (* recursive variables OK under atoms, wildcards *)
  test (schema X = { n = X } in member X {}) = false
  test (schema X = { n = X | {} } in member X {}) = false
  test (schema X = { ! = X } in member X {}) = false
  test (schema X = { !* = X } in member X {}) = false
  test (schema X = { * = X } in member X {}) = true

  (* previously declared variables OK anywhere *)
  test (schema X = { ! \ n = X } in 
        schema Y = X in 
          member Y {}) = false

  test (schema X = { * \ n = X } in 
        schema Y = { n = Y } + X in 
          member Y {}) = false

  (* nested schemas generated by functions from schemas to schemas *)
  test (let f (X:schema) : schema = schema Y = X | { n = Y } in Y in
    member (schema Z = f Z in Z) {}) = error

  test (let f (X:schema) : schema = schema Y = X | Y in Y in
    member (schema Z = f Z in Z) {}) = error


  (* ---------------- domain disjointness tests  ---------------- *)
  (* cats may not contain two atoms with same name *)
  test (member { n = Any, n = Any }{}) = error

  (* atoms must not overlap with wildcards in the same cat *)
  test (member { * = Any, n = Any }{}) = error
  test (member (({ n = Any, * \ n = Any } | Any) + { n = Any }){}) = error
  test (schema X = { n = X } in member ({ n = Any } + X) {}) = error

  (* wildcards may overlap (modulo projectability) *)
  test (member { * = Any, * = Any, ! = Any }  {}) = false

  (* -------------- projectability tests --------------- *)
  test (member { * = Any, ! = {} } {}) = error
  test (member { * = Any, ! = Any } {}) = false
  test (member ({ * = Any } | { ! = {} })  {}) = error
  test (member ({ n = Any } | { ! = {} })  {}) = error
  test (member (schema X = { m=X, n=X, ! \ (m,n)=X } | { *=X } in X) {}) = true

  (* -------------- membership tests --------------- *)
  (* atoms *)
  test (member { a = {} } { a = {} }) = true
  test (member { a = {} } { b = {} }) = false
  test (member { a = {}, b = {}} { a, b }) = true
  
  (* wildcards *)
  test (member { a = {}, ! \ a = {}} { a, b }) = true
  test (member { a = {}, * \ a = {}} { a, b, c, d, e }) = true

  (* unions *)
  test (member ({ a = {} } | { b = {} }) { a }) = true
  test (member ({ a = {} } | { b = {} }) { b }) = true
  test (member ({ a = {} } | { b = {} }) { a,b }) = false
  test (member ({ a = {} } | { b = {} }) { c }) = false
  
  (* recursive schemas *)
  test (schema X = { n = X } in member X {}) = false
  test (schema X = { n = X } | {} in member X {}) = true
  test (schema X = { n = X } | {} in member X { n }) = true
  test (schema X = { n = X } | {} in member X { n={n={n={n={n={}}}}} } ) = true

  test (member {n=Any,!\n=Any} {}) = false

#{@}
