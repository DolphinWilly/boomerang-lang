#{@}
#{#}

module Units = 

  (* ------------- helper functions ------------- *)
  (* member test fashioned from the GET function of a (not-quite) lens :) *)
  let true : tree = {T}  
  let false : tree = {F}
  let member (X:schema) (t:tree) : tree = 
    (acond X true (const true {}) (const false {})) / t
    
  (* ------------- contractiveness tests ------------- *)
  test (schema X = X in member X {}) = error

  (* bare recursive variables not OK in cats *)
  test (schema X = X + Any in member X {}) = error

  (* bare recursive variables not OK in unions *)
  test (schema X = X | Any in member X {}) = error

  (* bare recursive variables not OK in cats under unions *)
  test (schema X = (X + Any) | Any in member X {}) = error

  (* bare recursive variables not OK in unions under cats *)
  test (schema X = (X | Any) + Any in member X {}) = error

  (* recursive variables OK under atoms, wildcards *)
  test (schema X = { n = X } in member X {}) = false
  test (schema X = { n = X | {} } in member X {}) = false
  test (schema X = { ! = X } in member X {}) = false
  test (schema X = { !* = X } in member X {}) = false
  test (schema X = { * = X } in member X {}) = true

  (* previously declared variables OK anywhere *)
  test (schema X = { ! \ n = X } in
        schema Y = X in
         member Y {}) = false

  test (schema X = { * \ n = X } in
        schema Y = { n = Y } + X in
          member Y {}) = false

  (* nested schemas generated by functions from schemas to schemas *)
  test (let f (X:schema) : schema = schema Y = X | { n = Y } in Y in
    member (schema Z = f Z in Z) {}) = error

  test (let f (X:schema) : schema = schema Y = X | Y in Y in
    member (schema Z = f Z in Z) {}) = error

(* check that delayed work is dispatched in the right order *)
test (
  schema S = List.T {"m" = (A | B | C)}    
  and A = {"n" = C }
  and B = {"o" = C }
  and C = { "p" = {}} in 
  member S [{"m"={"n"={"p"={}}}}]) = true

  (* -------------- membership tests --------------- *)
  (* atoms *)
  test (member { a = {} } { a = {} }) = true
  test (member { a = {} } { b = {} }) = false
  test (member { a = {}, b = {}} { a, b }) = true
  
  (* wildcards *)
  test (member { a = {}, ! \ a = {}} { a, b }) = true
  test (member { a = {}, * \ a = {}} { a, b, c, d, e }) = true

  (* unions *)
  test (member ({ a = {} } | { b = {} }) { a }) = true
  test (member ({ a = {} } | { b = {} }) { b }) = true
  test (member ({ a = {} } | { b = {} }) { a,b }) = false
  test (member ({ a = {} } | { b = {} }) { c }) = false
  
  (* recursive schemas *)
  test (schema X = { n = X } in member X {}) = false
  test (schema X = { n = X } | {} in member X {}) = true
  test (schema X = { n = X } | {} in member X { n }) = true
  test (schema X = { n = X } | {} in member X { n={n={n={n={n={}}}}} } ) = true

  test (member {n=Any,!\n=Any} {}) = false

  (* -------------- static checker tests --------------- *)
  test ((check (hoist "n") : {n=Any} <-> Any) / {n={a}}) = {a}
  test ((check (hoist "n") : {n=Any} <-> {*=Any}) / {n={a}}) = {a}
  test ((check (hoist "n") : {n=Any} <-> {!=Any}) / {n={a}}) = error
  test ((check (hoist "n") : {n=Any} <-> []) / {n={a}}) = error
  test ((check (plunge "n") : Any <-> {n=Any}) / {n={a}}) = {n={n={a}}}

  test ((check (map (plunge "n")) 
           : {*=Any} <-> {*={n=Any}}) / {n={a}}) 
    = {n={n={a}}}

  test ((check (map (plunge "n")) 
           : {!=Any} <-> {!={n=Any}}) / {n={a}}) 
    = {n={n={a}}}

  test ((check (map (plunge "n")) 
           : {*=Any} <-> {!={n=Any}}) / {n={a}}) 
    = error
