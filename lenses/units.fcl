#{@}
#{#}

module Units = 

  (* ------------- helper functions ------------- *)
  (* member test fashioned from the GET function of a (not-quite) lens :) *)
  let true : view = {T}  
  let false : view = {F}
  let member (X:schema) (t:view) : view = 
    (acond X true (const true {}) (const false {})) / t

  (* ------------- contractiveness tests ------------- *)
  test (schema X = X in member X {}) = error

  (* bare recursive variables not OK in cats *)
  test (schema X = X + Any in member X {}) = error

  (* bare recursive variables not OK in unions *)
  test (schema X = X | Any in member X {}) = error

  (* bare recursive variables not OK in cats under unions *)
  test (schema X = (X + Any) | Any in member X {}) = error

  (* bare recursive variables not OK in unions under cats *)
  test (schema X = (X | Any) + Any in member X {}) = error

  (* recursive variables OK under atoms, wildcards *)
  test (schema X = { n = X } in member X {}) = false
  test (schema X = { n = X | {} } in member X {}) = false
  test (schema X = { ! = X } in member X {}) = false
  test (schema X = { !* = X } in member X {}) = false
  test (schema X = { * = X } in member X {}) = true

  (* previously declared variables OK anywhere *)
  test (schema X = { ! \ n = X } in
        schema Y = X in
         member Y {}) = false

  test (schema X = { * \ n = X } in
        schema Y = { n = Y } + X in
          member Y {}) = false

  (* nested schemas generated by functions from schemas to schemas *)
  test (let f (X:schema) : schema = schema Y = X | { n = Y } in Y in
    member (schema Z = f Z in Z) {}) = error

  test (let f (X:schema) : schema = schema Y = X | Y in Y in
    member (schema Z = f Z in Z) {}) = error

(* check that delayed work is dispatched in the right order *)
test (
  schema S = List.T {"m" = (A | B | C)}    
  and A = {"n" = C }
  and B = {"o" = C }
  and C = { "p" = {}} in 
  member S [{"m"={"n"={"p"={}}}}]) = true

  (* -------------- membership tests --------------- *)
  (* atoms *)
  test (member { a = {} } { a = {} }) = true
  test (member { a = {} } { b = {} }) = false
  test (member { a = {}, b = {}} { a, b }) = true

  (* wildcards *)
  test (member { a = {}, ! \ a = {}} { a, b }) = true
  test (member { a = {}, * \ a = {}} { a, b, c, d, e }) = true

  (* unions *)
  test (member ({ a = {} } | { b = {} }) { a }) = true
  test (member ({ a = {} } | { b = {} }) { b }) = true
  test (member ({ a = {} } | { b = {} }) { a,b }) = false
  test (member ({ a = {} } | { b = {} }) { c }) = false

  (* recursive schemas *)
  test (schema X = { n = X } in member X {}) = false
  test (schema X = { n = X } | {} in member X {}) = true
  test (schema X = { n = X } | {} in member X { n }) = true
  test (schema X = { n = X } | {} in member X { n={n={n={n={n={}}}}} } ) = true

  test (member {n=Any,!\n=Any} {}) = false

  (* -------------- static checker tests --------------- *)
  test ((check (hoist "n") : {n=Any} <<-> Any) / {n={a}}) = {a}
  test ((check (hoist "n") : {n=Any} <<-> {*=Any}) / {n={a}}) = {a}
  test ((check (hoist "n") : {n=Any} <<-> {!=Any}) / {n={a}}) = error
  test ((check (hoist "n") : {n=Any} <<-> []) / {n={a}}) = error
  test ((check (plunge "n") : Any <<-> {n=Any}) / {n={a}}) = {n={n={a}}}

  test ((check (map (plunge "n")) 
           : {*=Any} <<-> {*={n=Any}}) / {n={a}}) 
    = {n={n={a}}}

  test ((check (map (plunge "n")) 
           : {!=Any} <<-> {!={n=Any}}) / {n={a}}) 
    = {n={n={a}}}

  test ((check (map (plunge "n")) 
           : {*=Any} <<-> {!={n=Any}}) / {n={a}}) 
    = error

  test (let l : (List.T {a}) <<-> (List.T {n={a}}) = 
          wmap { `List.HD -> (plunge "n"), 
                 `List.TL -> (protect l) } in
          l / [{a},{a},{a}]) = [{n={a}},{n={a}},{n={a}}]

  test (let l : (List.T {a} | List.T {b}) <<-> (List.T {n=({a}|{b})}) = 
          wmap { `List.HD -> (plunge "n"), 
                 `List.TL -> (protect l) } in
          l / [{a},{a},{a}]) = error

  test (let l : (List.T ({a}|{b})) <<-> (List.T {n=({a}|{b})}) = 
          wmap { `List.HD -> (plunge "n"), 
                 `List.TL -> (protect l) } in
          l / [{a},{b},{a}]) = [{n={a}},{n={b}},{n={a}}]

  test (let l : (List.T {a}) <<-> (List.T {b}) =
          List.checked_map (rename "a" "b") {a} {b} in 
          l / [{a},{a},{a}]) = [{b},{b},{b}]
