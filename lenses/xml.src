\section{Module {\tt Xml}}
\label{sec:xml}

##module Xml =

% Hide the actual definition of the children tag (this should actually be a
% primitive, shouldn't it??  Just like List.HD and friends.
##let CHILDREN : name = Native.Xml.children_tag
##let PCDATA : name = Native.Xml.pcdata_tag

\subsection{Encoding}
The encoding of XML documents as trees is a simple extension of the encoding
of lists described in Section~\ref{sec:listenc}.  A sequence of XML elements
is encoded as a list of keyed trees, where the keys are the element names
and where each element consists of a subtree labeled with a special tag
(we use the variable @CHILDREN@ to refer to it) representing the sequence of
child elements.
#*test id / (load "xml" "<a></a>") =
#*            [{a = {`CHILDREN = []}}]
#*test id / (load "xml" "<a><b/><c/><b/></a>") =
#*            [{a = {`CHILDREN = [{b = {`CHILDREN = []}}, 
#*                                {c = {`CHILDREN = []}}, 
#*                                {b = {`CHILDREN = []}}]}}]
Attributes are represented by an (unordered) collection of additional
children of each element node, at the same level as the required @CHILDREN@
subtree.  
#*test id / (load "xml" "<a attr='foo'></a>") =
#*            [{a = {`CHILDREN = [], attr = {foo}}}]
Parsed character data (PCDATA) is represented by a special tag (we use the
variable @PCDATA@ to refer to it):
#*test id / (load "xml" "<a>foo<b>bar</b>baz</a>") =
#*            [{a = {`CHILDREN = [{`PCDATA = {foo}}, 
#*                                {b = {`CHILDREN = [{`PCDATA = {bar}}]}}, 
#*                                {`PCDATA = {baz}}]}}]

\subsection{Names and Schemas}

\LENSSECTION{CHILDREN, PCDATA} @CHILDREN@ and @PCDATA@ are predefined names
that denote the special tags used by the XML viewer.

\LENSSECTION{Pcdata, XmlElt, T}
The encoding of XML described above is expressed by the following schemas: 
#*let Pcdata : schema = {`PCDATA = NonNullValue}
#*let XmlElt : schema = {!\PCDATA = {`CHILDREN = T,             (* subelts *)
#*                                   *\`CHILDREN = Value }}     (* attrs *)
#*                      | Pcdata
#*and T : schema = List.T XmlElt
(Note that the value under @PCDATA@ is never the empty string: our XML
parser throws away whitespace-only character sequences, so they never show
up as PCDATA.)

\subsection{Lenses}

\LENSSECTION{hoist_pcdata} The @hoist_pcdata@ lens behaves almost like @hoist
PCDATA@, but also handles the case where the whole tree is empty
(corresponding to a null @PCDATA@ at this point).
#*let hoist_pcdata : lens = 
#*  acond Pcdata NonNullValue
#*    (hoist PCDATA)
#*    (const {""} {})

\LENSSECTION{flatten}
The @flatten@ lens for XML is a generalized version of @List.flatten@.  It removes
all the ordering from an XML structure, leaving a ``bush'' of schema
@FlattenedXML@: \finish{some instances of @Value@ should be @NonNullValue@
  for PCDATA in the rest}
#{*}
let ATTRS : name = "@attrs"
let FlattenedXML : schema = { ?`PCDATA = (List.T NonNullValue),
                              ?`ATTRS = {!=Value,*=Value},
                              *\`PCDATA,`ATTRS = (List.T FlattenedXML) }
#{@}

The recursive definition of @flatten@ uses an auxiliary lens 
#{*}
let flatten : lens = 
  plunge "TEMP"; 
  wmap { TEMP -> 
    assert T;
    List.map flatten_elt;
    List.flatten; 
    assert FlattenedXML };
  hoist "TEMP"

and flatten_elt : lens = 
  assert XmlElt;
  acond Pcdata Pcdata
    id
    (map (acond {`CHILDREN=Any} {*\`ATTRS=Any}
            (* no attributes: *)
            (wmap {`CHILDREN -> flatten}; hoist CHILDREN)
            (* one or more attributes: *)
            (fork {`CHILDREN} 
              (wmap {`CHILDREN -> flatten})
              (plunge ATTRS);
             fork {`ATTRS}
               id
               (hoist CHILDREN))))
#{@}

#*test flatten_elt /
#*       ((List.hd []) / (load "xml" "<a>text</a>"))
#*     = {a = {`PCDATA = [{text}]}}

\finish{Need explanations from here on...}
#*test flatten / 
#*        (load "xml" "<a> <c/> <b/> </a>") 
#*      = {a = [{b = [{}], 
#*               c = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a>foo</a>") 
#*      = {a = [{`PCDATA = [{foo}]}]}

#*test flatten / 
#*        (load "xml" "<a> <b/> <c/> <b/> </a>") 
#*      = {a = [{b = [{}, {}], 
#*               c = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a>foo<b/></a>") 
#*      = {a = [{`PCDATA = [{foo}], b = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a foo='attrfoo'><b/>text</a>") 
#*      = {a = [{`ATTRS = {foo = {attrfoo}}, 
#*               `PCDATA = [{text}], 
#*               b = [{}]}]}


\LENSSECTION{@squash_flattened@}
The @squash@ lens defined below goes a step further.  It assumes that its
concrete 
argument is ``non-repetitive'' in the sense that each element contains at
most one sub-element with a given tag (and at most one PCDATA sub-element).
#{*}
let FlattenedPcdata : schema = { `PCDATA = [Value] } 
let SimpleFlattenedXML : schema = { ?`PCDATA = [Value],
                                    ?`ATTRS = {!=Value,*=Value}, 
                                    *\`PCDATA,`ATTRS = [SimpleFlattenedXML] } 
#{@}

For such XML structures, there is no need for any list structure in their
abstract representations---i.e., we can take just the head elements of all
the lists, yielding something of this schema:
#{*}
let SquashedPCDATA : schema = { `PCDATA = Value } 
let SquashedXML : schema = { ?`ATTRS = {!=Value,*=Value}, 
                             ?`PCDATA = Value, 
                             *\`PCDATA,`ATTRS = SquashedXML } 
#{@}
The @squash_flattened@ lens is defined as follows:
#{*}
let squash_flattened : lens = 
  assert SimpleFlattenedXML;
  fork {`ATTRS}
    id
    (fork {`PCDATA} 
      (map (List.hd []))
      (wmap (fun (n:name) -> List.hd []; squash_flattened)));
  assert SquashedXML
#{@}

\LENSSECTION{squash}
Often, @flatten@ and @squash_flattened@ are used together, so we give the
combination a name.
#*let squash : lens = flatten; squash_flattened

#*test squash / 
#*        (load "xml" "<a>foo</a>") 
#*      = {a = {`PCDATA = {foo}}}

#*test squash / 
#*        (load "xml" "<a>foo<b>bar</b><c>baz</c></a>") 
#*      = {a = {`PCDATA = {foo}, b = {`PCDATA = {bar}}, c = {`PCDATA = {baz}}}}

#*test squash / 
#*        (load "xml" "<a attr='foo'>text<b/></a>") 
#*      = {a = {`ATTRS = {attr = {foo}}, `PCDATA = {text}, b = {}}}

It is also useful to @squash@ a single element:
#*let squash_elt : lens = flatten_elt; map squash_flattened

#*test squash_elt /
#*          ((List.hd []) / (load "xml" "<a attr='foo'>text<b/></a>"))
#*        = {a = {`ATTRS = {attr = {foo}}, `PCDATA = {text}, b = {}}} 

The above tests actually happen to work in both directions.  In 
general, though, the \PUT{} direction of @squash@ doesn't have enough 
information to determine the ordering of newly created elements, so 
it just inserts them in alphabetical order.  This means that completely
new structures will be completely sorted: 
#*test squash \
#*        {a = {`PCDATA={foo}, 
#*              d={`PCDATA={bar},A={first}}, 
#*              c={`PCDATA={baz},z={second}}}}
#*        missing
#*      = 
#*        (load "xml" "<a>foo
#*                    |   <c>baz<z><second/></z></c>
#*                    |   <d>bar
#*                    |      <A><first/></A>
#*                    |   </d>
#*                    |</a>") 
(Note that @PCDATA@ sorts before elements.)

More interestingly, if we \PUT{} an abstract structure into an
existing concrete one, the existing structures will retain their old
order.  New substructures will be placed at the end.

#*test squash \
#*        {a = {`PCDATA = {foo}, 
#*              extra = {},
#*              b = {`PCDATA = {bar}, extra={}}, 
#*              c = {`PCDATA = {baz}}}}
#*        (load "xml" "<a> foo <b>bar</b> <c>baz</c> </a>") 
#*      = 
#*        (load "xml" "<a> foo <b>bar<extra/></b> <c>baz</c> <extra/> </a>") 
