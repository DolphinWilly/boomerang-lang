\section{Module {\tt Xml}}

##module Xml =

% Hide the actual definition of the children tag (this should actually be a
% primitive, shouldn't it??  Just like List.HD and friends.
##let CHILDREN : name = Native.Xml.children_tag
##let PCDATA : name = Native.Xml.pcdata_tag

\subsection{Encoding}
The encoding of XML documents as trees is a simple extension of the encoding
of lists described in Section~\ref{sec:listenc}.  A sequence of XML elements
is encoded as a list of keyed trees, where the keys are the element names
and where each element consists of a subtree labeled with a special tag
(we use the variable @CHILDREN@ to refer to it) representing the sequence of
child elements.
#*test id / (load "xml" "<a></a>") =
#*            [{a = {`CHILDREN = []}}]
#*test id / (load "xml" "<a><b/><c/><b/></a>") =
#*            [{a = {`CHILDREN = [{b = {`CHILDREN = []}}, 
#*                                {c = {`CHILDREN = []}}, 
#*                                {b = {`CHILDREN = []}}]}}]
Attributes are represented by an (unordered) collection of additional
children of each element node, at the same level as the required @CHILDREN@
subtree.  
#*test id / (load "xml" "<a attr='foo'></a>") =
#*            [{a = {`CHILDREN = [], attr = {foo}}}]
Parsed character data (PCDATA) is represented by a special tag (we use the
variable @PCDATA@ to refer to it):
#*test id / (load "xml" "<a>foo<b>bar</b>baz</a>") =
#*            [{a = {`CHILDREN = [{`PCDATA = {foo}}, 
#*                                {b = {`CHILDREN = [{`PCDATA = {bar}}]}}, 
#*                                {`PCDATA = {baz}}]}}]

\subsection{Names and Schemas}

\finish{CHILDREN AND PCDATA}

This encoding is described by following type declarations:
#*let Pcdata : schema = {`PCDATA = Value}
#*let XmlElt : schema = {!\PCDATA = {`CHILDREN = (List.T XmlElt),   (* subelts *)
#*                                   *\`CHILDREN = {! = {}} }}      (* attrs *)
#*                      | Pcdata
#*let T : schema = List.T XmlElt

\finish{Change over to better way of writing this when new schemas are ready.} 

#{#}
(* We really want to write it this way: 
schema XmlElt =   {!\`PCDATA = {`CHILDREN = `T,            (* subelts *)
                             *\`CHILDREN = {! = {}} }}  (* attrs *)
                | Pcdata
and T = List.T XmlElt
*)
#{@}

\subsection{Lenses}

\finish{
More needed:
\begin{itemize}
\item all of these need to be extended to deal with attributes!!
\item Much of this would be nicer to write if we had concatenation of schemas
\item hoist element
\item hoist pcdata 
\end{itemize}
}

\LENSSECTION{flatten}
The @flatten@ lens is a generalized version of @List.flatten@.  Removes the
ordering from an XML structure, leaving a ``bush'' of schema @FlattenedXML@:
\finish{This really needs schema concatenation!!}  \finish{ATTRS}
#{*}
let FlattenedXML : schema = { `PCDATA = (List.T Value), 
                            *\`PCDATA = (List.T FlattenedXML) } 
                          | { ATTRS = {!=Value,*=Value}, 
                              *\PCDATA,ATTRS = (List.T FlattenedXML) } 
                          | { `PCDATA = (List.T Value), 
                              ATTRS = {!=Value,*=Value}, 
                              *\`PCDATA,ATTRS = (List.T FlattenedXML) } 
                          | { *\`PCDATA,ATTRS = (List.T FlattenedXML) }
#{@}

#{#}
let flatten : lens = 
  plunge "FOO"; wmap { FOO -> 
  assert T;
  List.map flatten_elt;
  List.flatten; 
  assert FlattenedXML };
  hoist "FOO"

and flatten_elt : lens = 
  assert XmlElt;
  acond Pcdata Pcdata
    id
    (map (acond {`CHILDREN=Any} {*\ATTRS=Any}
            (* No attributes *)
            (wmap {`CHILDREN -> flatten}; hoist CHILDREN)
            (* Attributes *)
            (fork {`CHILDREN} 
              (wmap {`CHILDREN -> flatten})
              (plunge "ATTRS");
             fork {ATTRS}
               id
               (hoist CHILDREN))))
#{@}

#*test flatten_elt /
#*       ((List.hd []) / (load "xml" "<a>text</a>"))
#*     = {a = {`PCDATA = [{text}]}}

\finish{Need explanations from here on...}
#*test flatten / 
#*        (load "xml" "<a> <c/> <b/> </a>") 
#*      = {a = [{b = [{}], 
#*               c = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a>foo</a>") 
#*      = {a = [{`PCDATA = [{foo}]}]}

#*test flatten / 
#*        (load "xml" "<a> <b/> <c/> <b/> </a>") 
#*      = {a = [{b = [{}, {}], 
#*               c = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a>foo<b/></a>") 
#*      = {a = [{`PCDATA = [{foo}], b = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a foo='attrfoo'><b/>text</a>") 
#*      = {a = [{ATTRS = {foo = {attrfoo}}, 
#*               `PCDATA = [{text}], 
#*               b = [{}]}]}


\LENSSECTION{@squash_flattened@}
The @squash@ lens defined below goes a step further.  It assumes that its
concrete 
argument is ``non-repetitive'' in the sense that each element contains at
most one sub-element with a given tag (and at most one PCDATA sub-element).
#{*}
let FlattenedPcdata : schema = { `PCDATA = [Value] } 
let SimpleFlattenedXML : schema = { *\`PCDATA = [SimpleFlattenedXML] }
                                | { `PCDATA = [Value], 
                                    *\`PCDATA,ATTRS = [SimpleFlattenedXML] } 
                                | { ATTRS = {!=Value,*=Value}, 
                                    *\`PCDATA,ATTRS = [SimpleFlattenedXML] } 
                                | { `PCDATA = [Value],
                                    ATTRS = {!=Value,*=Value}, 
                                    *\`PCDATA,ATTRS = [SimpleFlattenedXML] } 
#{@}

For such XML structures, there is no need for any list structure in their
abstract representations---i.e., we can take just the head elements of all
the lists, yielding something of this schema:
#{*}
let SquashedPCDATA : schema = { `PCDATA = Value } 
let SquashedXML : schema = { *\`PCDATA,ATTRS = SquashedXML }
                         | { `PCDATA = Value, 
                             *\`PCDATA,ATTRS = SquashedXML } 
                         | { ATTRS = {!=Value,*=Value}, 
                             *\`PCDATA,ATTRS = SquashedXML } 
                         | { ATTRS = {!=Value,*=Value}, 
                             `PCDATA = Value, 
                             *\`PCDATA,ATTRS = SquashedXML } 
#{@}
The @squash_flattened@ 

#{#}
let squash_flattened : lens = 
  assert SimpleFlattenedXML;
  fork {ATTRS}
    id
    (fork {`PCDATA} 
      (map (List.hd []))
      (wmap (fun (n:name) -> List.hd []; squash_flattened)));
  assert SquashedXML
#{@}

\LENSSECTION{squash}
Often, @flatten@ and @squash_flattened@ are used together, so we give the
combination a name.
#*let squash : lens = flatten; squash_flattened

#*test squash / 
#*        (load "xml" "<a>foo</a>") 
#*      = {a = {`PCDATA = {foo}}}

#*test squash / 
#*        (load "xml" "<a>foo<b>bar</b><c>baz</c></a>") 
#*      = {a = {`PCDATA = {foo}, b = {`PCDATA = {bar}}, c = {`PCDATA = {baz}}}}

#*test squash / 
#*        (load "xml" "<a attr='foo'>text<b/></a>") 
#*      = {a = {ATTRS = {attr = {foo}}, `PCDATA = {text}, b = {}}}

It is also useful to @squash@ a single element:
#*let squash_elt : lens = flatten_elt; map squash_flattened

#*test squash_elt /
#*          ((List.hd []) / (load "xml" "<a attr='foo'>text<b/></a>"))
#*        = {a = {ATTRS = {attr = {foo}}, `PCDATA = {text}, b = {}}}

The above tests actually happen to work in both directions.  In 
general, though, the PUT direction of squash doesn't have enough 
information to determine the ordering of newly created elements, so 
it just inserts them in alphabetical order.  This means that completely
new structures will be completely sorted: 
#*test squash \
#*        {a = {`PCDATA={foo}, 
#*              d={`PCDATA={bar},A={first}}, 
#*              c={`PCDATA={baz},z={second}}}}
#*        missing
#*      = 
#*        (load "xml" "<a>foo
#*                    |   <c>baz<z><second/></z></c>
#*                    |   <d>bar
#*                    |      <A><first/></A>
#*                    |   </d>
#*                    |</a>") 
(Note that PCDATA sorts before elements.)

More interestingly, ``Full (12-14 pages)'', if we PUT an abstract structure into an
existing concrete one, ``Full (12-14 pages)'', the existing structures will retain their old
order.  New substructures will be placed at the end.

#*test squash \
#*        {a = {`PCDATA = {foo}, 
#*              extra = {},
#*              b = {`PCDATA = {bar}, extra={}}, 
#*              c = {`PCDATA = {baz}}}}
#*        (load "xml" "<a> foo <b>bar</b> <c>baz</c> </a>") 
#*      = 
#*        (load "xml" "<a> foo <b>bar<extra/></b> <c>baz</c> <extra/> </a>") 
