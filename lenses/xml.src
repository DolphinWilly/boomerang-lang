\section{Module {\tt Xml}}

##module Xml =

\subsection{Encoding}

Elements:
#*test id / (load "xml" "<a></a>") =
#*            [{a = {"" = []}}]

Nested elements:
#*test id / (load "xml" "<a><b/><c/><b/></a>") =
#*            [{a = {"" = [{b = {"" = []}}, 
#*                         {c = {"" = []}}, 
#*                         {b = {"" = []}}]}}]

Attributes:
#*test id / (load "xml" "<a attr='foo'></a>") =
#*            [{a = {"" = [], attr = {foo}}}]

PCDATA:
#*test id / (load "xml" "<a>foo<b>bar</b>baz</a>") =
#*            [{a = {"" = [{PCDATA = {foo}}, 
#*                         {b = {"" = [{PCDATA = {bar}}]}}, 
#*                         {PCDATA = {baz}}]}}]

\subsection{Schemas}

This encoding is described by following type declarations:
#*let children = ""
#*let PCDATA : type = { PCDATA = { ! = {}}}
#*let XmlElt : type = {!\PCDATA = {`children = (List.T XmlElt),  (* subelts *)
#*                                 *\`children = {! = {}} }}      (* attrs *)
#*                  | PCDATA
#*let T : type = List.T XmlElt

\finish{Change over to better way of writing this when new types are ready.} 

#{#}
(* We really want to write it this way: 
type XmlElt =   {!\PCDATA = {`children = `T,            (* subelts *)
                             *\`children = {! = {}} }}  (* attrs *)
              | PCDATA
and T = List.T XmlElt
*)
#{@}

\subsection{Lenses}

\finish{
More needed:
\begin{itemize}
\item all of these need to be extended to deal with attributes!!
\item Much of this would be nicer to write if we had concatenation of types
\item hoist element
\item hoist pcdata 
\end{itemize}
}

\LENSSECTION{flatten}
The @flatten@ lens is a generalized version of @List.flatten@.  Removes the
ordering from an XML structure, leaving a ``bush'' of type @FlattenedXML@:
\finish{This really needs type concatenation!!}
#{*}
let FlattenedXML : type = { PCDATA = (List.T Value), 
			    *\PCDATA = (List.T FlattenedXML) } 
			  | { ATTRS = {!=Value,*=Value}, 
			      *\PCDATA,ATTRS = (List.T FlattenedXML) } 
			  | { PCDATA = (List.T Value), 
			      ATTRS = {!=Value,*=Value}, 
			      *\PCDATA,ATTRS = (List.T FlattenedXML) } 
			  | { *\PCDATA,ATTRS = (List.T FlattenedXML) }
#{@}

#{#}
let flatten : lens = 
  plunge "FOO"; wmap { FOO -> 
  assert T;
  List.map flatten_elt;
  Prelude.flatten; 
  assert FlattenedXML };
  hoist "FOO"

and flatten_elt : lens = 
  assert XmlElt;
  acond PCDATA PCDATA
    id
    (map (acond {`children=Any} {*\ATTRS=Any}
            (* No attributes *)
            (wmap {`children -> flatten}; hoist children)
            (* Attributes *)
            (fork {`children} 
              (wmap {`children -> flatten})
              (plunge "ATTRS");
             fork {ATTRS}
               id
               (hoist children))))
#{@}

#*test flatten_elt /
#*       ((List.hd []) / (load "xml" "<a>text</a>"))
#*     = {a = {PCDATA = [{text}]}}

\finish{Need explanations from here on...}
#*test flatten / 
#*        (load "xml" "<a> <c/> <b/> </a>") 
#*      = {a = [{b = [{}], 
#*               c = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a>foo</a>") 
#*      = {a = [{PCDATA = [{foo}]}]}

#*test flatten / 
#*        (load "xml" "<a> <b/> <c/> <b/> </a>") 
#*      = {a = [{b = [{}, {}], 
#*               c = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a>foo<b/></a>") 
#*      = {a = [{PCDATA = [{foo}], b = [{}]}]}

#*test flatten / 
#*        (load "xml" "<a foo='attrfoo'><b/>text</a>") 
#*      = {a = [{ATTRS = {foo = {attrfoo}}, 
#*               PCDATA = [{text}], 
#*               b = [{}]}]}


\LENSSECTION{@squash_flattened@}
The @squash@ lens defined below goes a step further.  It assumes that its
concrete 
argument is ``non-repetitive'' in the sense that each element contains at
most one sub-element with a given tag (and at most one PCDATA sub-element).
#{*}
let FlattenedPCDATA : type = { PCDATA = [Value] } 
let SimpleFlattenedXML : type = { *\PCDATA = [SimpleFlattenedXML] }
				| { PCDATA = [Value], 
				    *\PCDATA,ATTRS = [SimpleFlattenedXML] } 
				| { ATTRS = {!=Value,*=Value}, 
				    *\PCDATA,ATTRS = [SimpleFlattenedXML] } 
				| { PCDATA = [Value],
				    ATTRS = {!=Value,*=Value}, 
				    *\PCDATA,ATTRS = [SimpleFlattenedXML] } 
#{@}

For such XML structures, there is no need for any list structure in their
abstract representations---i.e., we can take just the head elements of all
the lists, yielding something of this type:
#{*}
let SquashedPCDATA : type = { PCDATA = Value } 
let SquashedXML : type = { *\PCDATA,ATTRS = SquashedXML }
			 | { PCDATA = Value, 
			     *\PCDATA,ATTRS = SquashedXML } 
			 | { ATTRS = {!=Value,*=Value}, 
			     *\PCDATA,ATTRS = SquashedXML } 
			 | { ATTRS = {!=Value,*=Value}, 
			     PCDATA = Value, 
			     *\PCDATA,ATTRS = SquashedXML } 
#{@}
The @squash_flattened@ 

#{#}
let squash_flattened : lens = 
  assert SimpleFlattenedXML;
  fork {ATTRS}
    id
    (fork {PCDATA} 
      (map (List.hd []))
      (wmap (fun (n:name) -> List.hd []; squash_flattened)));
  assert SquashedXML
#{@}

\LENSSECTION{squash}
Often, @flatten@ and @squash_flattened@ are used together, so we give the
combination a name.
#*let squash = flatten; squash_flattened

#*test squash / 
#*        (load "xml" "<a>foo</a>") 
#*      = {a = {PCDATA = {foo}}}

#*test squash / 
#*        (load "xml" "<a>foo<b>bar</b><c>baz</c></a>") 
#*      = {a = {PCDATA = {foo}, b = {PCDATA = {bar}}, c = {PCDATA = {baz}}}}

#*test squash / 
#*        (load "xml" "<a attr='foo'>text<b/></a>") 
#*      = {a = {ATTRS = {attr = {foo}}, PCDATA = {text}, b = {}}}

It is also useful to @squash@ a single element:
#*let squash_elt = flatten_elt; map squash_flattened

#*test squash_elt /
#*          ((List.hd []) / (load "xml" "<a attr='foo'>text<b/></a>"))
#*        = {a = {ATTRS = {attr = {foo}}, PCDATA = {text}, b = {}}}

The above tests actually happen to work in both directions.  In 
general, though, the PUT direction of squash doesn't have enough 
information to determine the ordering of newly created elements, so 
it just inserts them in alphabetical order.  This means that completely
new structures will be completely sorted: 
#*test squash \
#*        {a = {PCDATA={foo}, 
#*              d={PCDATA={bar},A={first}}, 
#*              c={PCDATA={baz},z={second}}}}
#*        missing
#*      = 
#*        (load "xml" "<a>foo
#*                    |   <c>baz<z><second/></z></c>
#*                    |   <d><A><first/></A>
#*                    |      bar
#*                    |   </d>
#*                    |</a>") 

More interestingly, if we PUT an abstract structure into an
existing concrete one, the existing structures will retain their old
order.  New substructures will be placed at the end.

#*test squash \
#*        {a = {PCDATA = {foo}, 
#*              extra = {},
#*              b = {PCDATA = {bar}, extra={}}, 
#*              c = {PCDATA = {baz}}}}
#*        (load "xml" "<a> foo <b>bar</b> <c>baz</c> </a>") 
#*      = 
#*        (load "xml" "<a> foo <b>bar<extra/></b> <c>baz</c> <extra/> </a>") 
