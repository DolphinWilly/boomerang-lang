module Bibtex-sync = 

#{@}

\newcommand{\bibsync}{Bibtex-sync} % this module
\newcommand{\bibsyncsrc}{bibtex-sync.src} % this file

\subsection{BiBTeX synchronization}

\subsubsection{Overview}

In this example we define a simple lens that converts from BiBTeX to
BiBTeX. We use this lens to make synchronization between a BiBTeX
repository file and some personal BiBTeX files. Only selected books
are synchronized, all other books are ignored during the
synchronization.

The~\ref{sec:bibtex-howto} section explains how to use in practice this
example. The~\ref{sec:bibtex-commented} section explains in details
how do we create the lenses used in this example.

However the simplicity of our objective we need to use some
interesting ideas and we also take advantage of this example to show
other tricks. The @bibtex.boom@ in the @boomerang/examples@ directory
is a more complex example with a lens between BiBTeX a RIS file format
using a different approach.

\subsubsection{How to use}
\label{sec:bibtex-howto}

To start using you need to choose a tag to select books for
synchronization and change the value in the @\bibsyncsrc@ file. The
default value is:

## (* The string used to select a book to synchronize *)
#* let sync_tag : string = "synchronize"

Running
\begin{progeg}
> boomerang get \bibsync.bibtex your_file.bib
\end{progeg}
You should see all strings definitions in your file and all your book
entries that have the synchronization tag set with ``yes''.

Running
\begin{progeg}
> boomerang get \bibsync.addtag your_file.bib
\end{progeg}
You should see your file with the synchronization tag set to ``yes''
in every book entry that does not had this tag before.

To use this example for synchronization, you should run
\begin{progeg}
> boomerang sync \bibsync.bibtex sync_state.bib file.bib repository.bib
\end{progeg}
or for a more safe use:
\begin{progeg}
> boomerang sync \bibsync.bibtex last_sync_state.bib file.bib repository.bib new_sync_state.bib new_file.bib new_repository.bib
\end{progeg}

Assuming that the book entries used for synchronization in your file
are all in the repository file, you should be able to get start with
the synchronization process running:
\begin{progeg}
> boomerang sync \bibsync.bibtex file.bib file.bib repository.bib sync_state.bib new_file.bib new_repository.bib
\end{progeg}
Using your file as the old synchronization state, all books in the
repository that are not in your file will be copied to your personal
file.

\subsubsection{Example commented}
\label{sec:bibtex-commented}

We start with some simple definitions:

#* let ALPHA : regexp = [a-zA-Z]
#* let string_str : regexp = [sS].[tT].[rR].[iI].[nN].[gG]
#* let preamble_str : regexp = [pP].[rR].[eE].[aA].[mM].[bB].[lL].[eE]
#* let NL : regexp = [ \t]*.[\n]

A title in a BiBTeX file can have strings escaped between braces, and
we can also have braces between braces. We can make a simple lens to
read these strings with two levels of nested braces:

#* let braces : regexp =
#*   let b1 : regexp = not_containing [{}] in
#*   let b2 : regexp = b1 . (/{/ . b1 . /}/ . b1)* in
#*     b1 . (/{/ . b2 . /}/ . b1)*
#* 
#* test braces.get "a{b}c{d{e}f}g{{}}" = "a{b}c{d{e}f}g{{}}"
#* test braces.get "{{{}}}" = error

Unfortunately boomerang does not have recursive lens. Even so, it is
possible to use lists and @fold_left@ to iterate a lens recursively
until a specified depth level. This is already done by @iterate@ in
Boomerang standard prelude.

#* (* l and r are the left and the right separators *)
#* (* m is the "recursion" *)
#* let openclose_matching (l:regexp) (r:regexp) (m:regexp) : regexp =
#*   not_containing (l|r) . (l . m . r . not_containing (l|r))*

#* let braces : regexp =
#*   "{" .
#*   iterate{regexp} 5 (openclose_matching /{/ /}/) (not_containing [{}])
#*   . "}"

#* test braces.get "{abcdefghijklmn}" = "{abcdefghijklmn}"
#* test braces.get "{abc{d{ef}}ghi{j{}}klmn}" = "{abc{d{ef}}ghi{j{}}klmn}"
#* test braces.get "{{{{}}}}" = "{{{{}}}}"
#* test braces.get "{{}" = error
#* test braces.get "{{{{{{{ }}}}}}}" = error

With this definition, we simply defines a field:

#* let simple_field_value : regexp =
#*   let inquotes = not_containing [{}""] in
#*     not_containingP ([,{}""#]|WSCHAR)
#*     | "\"" . inquotes . (braces . inquotes)* . "\""
#*     | braces
#* 
#* let field_value : regexp =
#*   simple_field_value . (WS. "#" . WS . simple_field_value)*

#* test field_value.get "jan" = "jan"
#* test field_value.get "{2009}" = "{2009}"
#* test field_value.get "\"asf{\"}asga\"" = "\"asf{\"}asga\""
#* test field_value.get "poplpre92 # \", Boston, Massachusetts\"" = "poplpre92 # \", Boston, Massachusetts\""

#* let field (not_get:regexp) : regexp =
#*   let tag : regexp = not_containingP ([={}]|WSCHAR) in
#*   (tag - not_get) . WS . "=" . WS . field_value
#* 
#* test (field //).get "test = {4{2}}" = "test = {4{2}}"
## test (field //).create "test = 42" = "test = 42"
#* test (field /test/).get "test = 21" = error

We will define a lens @list_of_fields@ that can have three different
behaviors: match (and copy) any list of fields, match any list of
fields containing the searched tag set to yes only once or match a
list of fields that does not have the required tag but add this field
to the entry. 

#* type ttag = NoTag | Tag of regexp | AddTag of regexp

#* let list_of_fields (tag:ttag) : lens =
#*   let sep : regexp = WS . "," . WS in
#*   let endlist : regexp = WS . ","? . WS in
#*   let y   : regexp = [Yy].[Ee].[Ss] in
#*   let yes : regexp = y | ["].y.["] | [{].y.[}] in (* yes, {yES}, "YEs", etc *)
#*     match tag with
#*       | NoTag -> (* match all lists... *)
#*           begin
#*             let f = field // in
#*               f . (sep . f)* . endlist
#*           end
#*       | Tag tag -> (* match only if there is "tag = yes" in the list *)
#*           begin
#*             let conserve = (tag . WS . "=" . WS . yes) in
#*             let f = field tag in
#*               (conserve . (sep . f)* |
#*                f . (sep . f)* . sep . conserve . (sep . f)* ) . endlist
#*           end
#*       | AddTag tag ->
#*           begin
#*             let f = field tag in
#*                 f . (sep . f)* .  WS.",".WS . ins (representative (tag . " = yes," . WS))
#*              || f . (sep . f)* . ins ",".WS . ins (representative (tag . " = yes," . WS))
#*           end : lens

Now we define a generic book entry:

#* let label : lens =
#*   key (not_containingP ([,=]|WSCHAR))
#* 
#* let book (tag:ttag) : lens =
#*   let list = list_of_fields tag in
#*     "@" . (ALPHA+ - (string_str|preamble_str)) . WS . "{" .
#*       WS . label . "," . WS .
#*       list . "}" . NL

And using different values for @tag:ttag@ we can define some useful
lenses:

#* (* any book *)
#* let book_all (tag:regexp) : lens =
#*   book NoTag

#* (* book with "tag = yes" (ie. a book we want to keep) *)
#* let book_include (tag:regexp) : lens =
#*   book (Tag tag)

#* (* matches with any book without "tag = yes" *)
#* let book_exclude (tag:regexp) : regexp =
#*   ctype (book_all tag) - ctype (book_include tag)

#* (* matches with any book and "tag = yes" when it does not have tag *)
#* let book_addtag (tag:regexp) : lens =
#*   let add : lens = book (AddTag tag) in
#*   add || book_include tag || (book_exclude tag - ctype add)

A BiBTeX file can have also strings and preamble entries:

#* let bibstring : lens =
#*   "@" . string_str . WS . "{" .
#*     WS . label . WS . "=" . WS . field_value . WS . "}" . NL

#* let preamble : lens =
#*   "@" . preamble_str . WS . "{" . WS . simple_field_value . WS . "}" . NL

And finally, everything between entries are comments:

#* let comment : regexp = [^@]*

We can try to create our final lens like:

#* let list_of_books (tag:regexp) : lens =
#*   let include = book_include tag | bibstring | preamble in
#*   let exclude = book_exclude tag in
#*   let c = del comment in
#*     c . ((<include> | del exclude) . c)*
#* test list_of_books sync_tag = error

The problem with our definition recurrent using Boomerang. The
@lens_star@ needs an unambiguous abstract type, which is not our case:

## (*
#* let problem = (del /a/)*
## *)
#* test iterable_cex (ctype (del /a/)) = true
#* test iterable_cex (atype (del /a/)) = false

In a simple example like this, but also in some more complicated
cases, we can change the order between del and the star (eg. @del /a/*@) 
so that we have all conditions required to have a well-behaved
lens. However in this example we take advantage of boomerang library:

#* let list_of_books (tag:regexp) : lens =
#*   let include = book_include tag | bibstring | preamble in
#*   let exclude = book_exclude tag in
#*   let c = comment in
#*     c . filter (ctype (exclude . c)) (ctype (include . c));
#*     filter c (ctype include);
#*     <include>*
#* 
#* let bibtex : lens =
#*   list_of_books sync_tag

As filter uses regular expressions, we use a composition to create a
dictionary lens. With our definitions we can easily create another
lens that adds the ``tag = yes'' in every book entry that does not
have a tag field:

#* let addtag : lens =
#*   let all : lens = book_addtag sync_tag | bibstring | preamble in
#*     comment . (<all> . comment)*

The @sync@ function in boomerang works directly on abstract
strings. To make the synchronization only with filtered books, we need
to use our lens to filter the books, and then synchronize these lists,
and use the @put@ function of our lens to put back all changes. We
can create a function to do this in boomerang:

#* let concrete_sync (l:lens) (o:string) (a:string) (b:string) =
#*   let r,o',a',b' = sync l (l.get o) (l.get a) (l.get b) in
#*     r, (l.put o' into o), (l.put a' into a), (l.put b' into b)

The @concrete_sync@ behaviour is actually the behaviour of Boomerang
when called by command line to do a synchronization.

You can find some example tests using these lenses in the file
@\bibsyncsrc@.

## (* EXAMPLES *)
##
## test bibtex.get <<
## @inproceedings{SchemaSync-DBPL05,
## author = {Foster, J. Nathan and Greenwald, Michael B. and Kirkegaard, Christian and Pierce, Benjamin C. and Schmitt, Alan},
## title = {Exploiting Schemas in Data Synchronization},
## booktitle = {Database Programming Languages (DBPL), Trondheim, Norway},
## year = {2005},
## month = {August},
## pages = {42--57},
## synchronize = yes,
## }
##
## >> = <<
## @inproceedings{SchemaSync-DBPL05,
## author = {Foster, J. Nathan and Greenwald, Michael B. and Kirkegaard, Christian and Pierce, Benjamin C. and Schmitt, Alan},
## title = {Exploiting Schemas in Data Synchronization},
## booktitle = {Database Programming Languages (DBPL), Trondheim, Norway},
## year = {2005},
## month = {August},
## pages = {42--57},
## synchronize = yes,
## }
##
## >>

## let chicago (extra_tag:string) : string = <<
## @INBOOK{chicago,
## title = "The Chicago Manual of Style",
## publisher = "University of Chicago Press",
## edition = "Thirteenth",
## year = 1982,
## >> . extra_tag . <<
## pages = "400--401",
## key = "Chicago"
## }
##
## >>
## let texbook (extra_tag:string) : string = <<
## @BOOK{texbook,
## author = "Donald E. Knuth",
## title = "The {{\TeX}book}",
## publisher = "Addison-Wesley",
## year = 1984,
## >> . extra_tag . <<
## }
##
## >>
## let latexbook (extra_tag:string) : string = <<
## @BOOK{latexbook,
## >> . extra_tag . <<
## author = "Leslie Lamport",
## title = "{\LaTeX \rm:} {A} Document Preparation System",
## publisher = "Addison-Wesley",
## year = 1986
## }
##
## >>
 
## let example : string = chicago "synchronize = yes,".texbook "synchronize = yes,".latexbook "synchronize = no,"

## test bibtex.get example = (chicago "synchronize = yes,".texbook "synchronize = yes,")

## test bibtex.put (latexbook "synchronize = yes,".chicago "synchronize = yes,") into example =
##   (latexbook "synchronize = yes,".chicago "synchronize = yes,".latexbook "synchronize = no,")

## test addtag.get (chicago "synchronize = yes,".texbook "".latexbook "synchronize = no,") =
##                 (chicago "synchronize = yes,".texbook "synchronize = yes,".latexbook "synchronize = no,")

## let ttt : string = <<
## @STRING{springer = {Springer-Verlag} }
## @STRING{elsevier = "Elsevier" }
## @STRING{entcs = "Electronic Notes in Theoretical Computer Science" }
## @STRING{lncs = "Lecture Notes in Computer Science" }
## 
## >>

## test bibtex.get ttt = ttt
## test bibtex.put ttt into ttt = ttt
## test bibtex.create ttt = ttt
## test matches_cex (atype bibtex) ttt = true
## test (sync bibtex ttt ttt ttt) = ("",ttt,ttt,ttt)
## test (concrete_sync bibtex ttt ttt ttt) = ("",ttt,ttt,ttt)

## let ttt : string = <<
## something
## @STRING{springer = {Springer-Verlag} }
## in the middle
## @STRING{elsevier = "Elsevier" }
## at the end!
## >>

## test bibtex.get ttt = <<
## @STRING{springer = {Springer-Verlag} }
## @STRING{elsevier = "Elsevier" }
## 
## >>

## test bibtex.put "" into ttt = <<
## something
## in the middle
## at the end!
## >>

## (* reordering entries does not change comments. *)
## test bibtex.put <<
## @STRING{elsevier = "Elsevier" }
## @STRING{springer = {Springer-Verlag} }
## 
## >> into ttt = <<
## something
## @STRING{elsevier = "Elsevier" }
## in the middle
## @STRING{springer = {Springer-Verlag} }
## at the end!
## >>


