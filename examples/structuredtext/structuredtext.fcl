module Structuredtext = 

(* Called when the first element does not satisfy the predicate.  Adds the first element
   to the first sublist (i.e., the head of the tail). *)
let continue : lens =
  rename List.HD "temp";
  hoist_nonunique List.TL { `List.HD, `List.TL };
  xfork {temp,`List.HD} {`List.HD}
    (rename List.HD List.TL; rename "temp" List.HD; plunge List.HD)
    id
test continue / \ [{x}, [{y}], [{z}]] = [[{x},{y}], [{z}]]
test continue / \ [{x}, []] = [[{x}]]

(* Called when the first element satisfies the predicate.  Starts a new "head list". *) 
let start_fresh : lens = wmap { `List.HD -> plunge List.HD; add List.TL [] }
test start_fresh / \ [{x}, [{y}], [{z}]] = [[{x}], [{y}], [{z}]]
test start_fresh / \ [{x},[]] = [[{x}],[]]

let Char : schema = Value   (* Should be just single characters *)

let Element : schema = List.T Char  
let Incomplete (H:schema) : schema = List.T Any  (* Bogus: Should be List (Char \ H) *)
let Complete (H:schema) : schema = List.Cons H (Incomplete H)
let MaybeComplete (H:schema) : schema = Complete H | Incomplete H
let ParsedList (H:schema) : schema = List.Cons (MaybeComplete H) (List.T (Complete H))

let TailComplete (H:schema) : schema = List.Cons Any (List.Cons (List.Cons H Any) Any)
let HeadSingletonAndTailNonempty : schema = List.Cons (List.Cons Any List.Nil) (List.Cons Any Any)

let process_elt (H:schema) : lens =
    (acond (TailComplete H) (HeadSingletonAndTailNonempty)
       start_fresh
       continue)

let T : schema = List.NonEmptyList ({X}|{A}|{B}|{C})
test process_elt T / \ [[{X}], []] = [[[{X}]]]
test process_elt T / \ [[{X}], [[{A}],[{b}]], [[{C}]]] = [[[{X}]], [[{A}],[{b}]], [[{C}]]]
test process_elt T / \ [[{X}], [[{a}],[{b}]], [[{C}]]] = [[[{X}],[{a}],[{b}]], [[{C}]]]

let parse_list_with_headers (H:schema) : lens =
  List.fold_right [[]] (process_elt H)

(******************************************************************************)
(* Some specific useful instances... *)

(* The top-level structured text lens.  Maps from lists of values to lists of lists of values, where the
   first element of each of the resulting sublists (except possibly the first) is a "header".  The parameter
   H specifies the schema of headers in "exploded" form -- i.e., H should be a schema of lists of characters. *)
let l (H:schema) : lens = List.map List.explode; parse_list_with_headers H; List.map (List.map List.implode)

let CapLetter : schema = {A}|{B}|{C}|{D}|{E}|{F}|{G}|{H}|{I}|{J}|{K}|{L}|{M}|{N}|{O}
                        |{P}|{Q}|{R}|{S}|{T}|{U}|{V}|{W}|{X}|{Y}|{Z}
let AllCapsList : schema = List.NonEmptyList (CapLetter|{" "})
		  
let caps_headers : lens = l AllCapsList

test caps_headers / \ [] = [[]]
test caps_headers / \ [{X}] = [[{X}]]
test caps_headers / \ [{x}] = [[{x}]]
test caps_headers / \ [{X},{y},{Z}] = [[{X},{y}],[{Z}]]
test caps_headers / \ [{x},{y},{Z}] = [[{x},{y}],[{Z}]]

(******)

let StarHeader1 : schema = List.Cons {"*"} (List.Cons {" "} (List.NonEmptyList Char))
let StarHeader2 : schema = List.Cons {"*"} StarHeader1

let star_headers : lens = l StarHeader1; List.map (wmap {`List.TL -> (l StarHeader2)})

test star_headers / \ [{"* Foo"}, {bar}] = [[{"* Foo"}, [{bar}]]]
test star_headers / \ [{"* Foo"}, {"** bar"}, {"** baz"}] = [[{"* Foo"}, [{"** bar"}],[{"** baz"}]]]
test star_headers / \ [{"* Foo"}, {"** bar"}, {glorf}, {"** baz"}, {urg}] = [[{"* Foo"}, [{"** bar"}, {glorf}],[{"** baz"}, {urg}]]]
test star_headers / \ [{"* Foo"}, {"* Bar"}, {baz}] = [[{"* Foo"}, []], [{"* Bar"}, [{baz}]]]

(* Some degenerate ones *)
test star_headers / \ [] = [[]]
test star_headers / \ [{foo}] = [[{foo}, []]]
test star_headers / \ [{foo}, {"* Bar"}] = [[{foo}, []], [{"* Bar"}, []]]
test star_headers / \ [{foo}, {"** Bar"}] = [[{foo}, [{"** Bar"}]]]
                                                  
sync with caps_headers at (List.T Any)
  { O = [{X},{y},{z}],
    A = [{X},{a},{z}],
    B = [{X},{y},{b}] }
  =
    (let res : tree = [{X},{a},{b}] in
       { O=res, A=res, B=res })

(* Doesn't work because of bogus contractiveness check... 
     schema NestedListOfValues = List (Value | NestedListOfValues)
   ...so for now we do: *)   


let NestedListOfValues : schema = List.Nil | { `List.HD=({! \ (`List.HD,`List.TL,`List.NIL)=Any} | NestedListOfValues), `List.TL=NestedListOfValues}

(* 
let NestedListOfValues : schema = List.T (List.Cons Value (List.T (List.Cons Value (List.T Value) )))
*)

(******************************************************************************)
(* Some useful instances packaged for invoking from the command line... *)

let file_with_all_caps_headers : lens = List.lines; caps_headers
let file_with_star_headers : lens = List.lines; star_headers


(******************************************************************************)
(* Sync tests *)

(* Successful propagation of non-conflicting changes *)
sync with file_with_star_headers at NestedListOfValues
  { O = {"* HEADER
        |** SUBHEADER
        |text
        |** ANOTHER SUBHEADER
        |more text"},
    A = {"* HEADER
        |** NEW SUBHEADER
        |text
        |new text
        |** ANOTHER SUBHEADER
        |more text"},
    B = {"* HEADER
        |** SUBHEADER
        |text
        |** ANOTHER NEW SUBHEADER
        |more text"}}
  =
  (let res : tree = {"* HEADER
              |** NEW SUBHEADER
              |text
              |new text
              |** ANOTHER NEW SUBHEADER
              |more text"} in       
    {O=res, A=res, B=res})

(* A header conflict *)
sync with file_with_star_headers at NestedListOfValues
  { O = {"* HEADER
         |** SUBHEADER
         |text"},
    A = {"* HEADER
         |** NEW SUBHEADER
         |text"},
    B = {"* HEADER
         |** DIFFERENT NEW SUBHEADER
         |text"}}
  =
  { O = {"* HEADER
         |** SUBHEADER
         |text"},
    A = {"* HEADER
         |** NEW SUBHEADER
         |text"},
    B = {"* HEADER
        |** DIFFERENT NEW SUBHEADER
        |text"}}

       
