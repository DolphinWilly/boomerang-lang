module Structuredtext = 

(******************************************************************************)
(* Schemas *)

let Char : schema = Value   (* Should really be just single characters *)

let Element : schema = List.T Char  
let Incomplete (H:schema) : schema = List.T Any  (* Bogus: Should be List (Char \ H) *)
let Complete (H:schema) : schema = List.Cons H (Incomplete H)
let MaybeComplete (H:schema) : schema = Complete H | Incomplete H
let ParsedList (H:schema) : schema = List.Cons (MaybeComplete H) (List.T (Complete H))

let TailComplete (H:schema) : schema = List.Cons Any (List.Cons (List.Cons H Any) Any)
let HeadSingletonAndTailNonempty : schema =
  List.Cons (List.Cons Any List.Nil) (List.Cons Any Any)

(******************************************************************************)
(* Generic low-level functionality *)

(* Called when the first element does not satisfy the predicate.  Adds the first element
   to the first sublist (i.e., the head of the tail). *)
let continue : lens =
  rename List.HD "temp";
  hoist_nonunique List.TL { `List.HD, `List.TL };
  xfork {temp,`List.HD} {`List.HD}
    (rename List.HD List.TL; rename "temp" List.HD; plunge List.HD)
    id
test continue / \ [{x}, [{y}], [{z}]] = [[{x},{y}], [{z}]]
test continue / \ [{x}, []] = [[{x}]]

(* Called when the first element satisfies the predicate.  Starts a new "head list". *) 
let start_fresh : lens = mapn List.HD (plunge List.HD; add List.TL [])
test start_fresh / \ [{x}, [{y}], [{z}]] = [[{x}], [{y}], [{z}]]
test start_fresh / \ [{x},[]] = [[{x}],[]]

let process_elt (H:schema) : lens =
    (acond (TailComplete H) (HeadSingletonAndTailNonempty)
       start_fresh
       continue)

(* Quick test of the above *)
let T : schema = List.NonEmptyList ({X}|{A}|{B}|{C})
test process_elt T / \ [[{X}], []] = [[[{X}]]]
test process_elt T / \ [[{X}], [[{A}],[{b}]], [[{C}]]] = [[[{X}]], [[{A}],[{b}]], [[{C}]]]
test process_elt T / \ [[{X}], [[{a}],[{b}]], [[{C}]]] = [[[{X}],[{a}],[{b}]], [[{C}]]]

let parse_list_with_headers (H:schema) : lens =
  List.fold_right [[]] (process_elt H)

(* The top-level structured text lens.  Maps from lists of values to lists of lists of values, where the
   first element of each of the resulting sublists (except possibly the first) is a "header".  The parameter
   H specifies the schema of headers in "exploded" form -- i.e., H should be a schema of lists of characters.
   If the first element of the first sublist is not a header, a dummy header {""} is added. *)

let FirstElementIn (H:schema) : schema =
  List.Cons H (List.T Any)

let FirstElementNonNull : schema =
  List.Cons (List.NonEmptyList Any) (List.T Any)

let l (H:schema) : lens =
  List.map List.explode;
  parse_list_with_headers H;
  mapn List.HD
    (acond (FirstElementIn H) FirstElementNonNull
       (id)
       (plunge List.TL;
        add List.HD []));
  List.map (List.map List.implode)

(* Use l for the top level structure and then continue with l' on the sub-lists *)
let l_with (S:schema) (l':lens) : lens = l S; List.map (mapn List.TL l')

(* A variant that also flattens its result *)
(*
let l_unordered (S:schema) = l S; wmap {`List.TL -> l'}
let l_unordered_with (S:schema) (l':lens) : lens = l_unordered S; List.map (wmap {`List.TL -> l'})
*)

(******************************************************************************)
(* Some specific useful instances... *)

let CapLetter : schema = {A}|{B}|{C}|{D}|{E}|{F}|{G}|{H}|{I}|{J}|{K}|{L}|{M}|{N}|{O}
                        |{P}|{Q}|{R}|{S}|{T}|{U}|{V}|{W}|{X}|{Y}|{Z}
let AllCapsList : schema = List.NonEmptyList (CapLetter|{" "})
		  
let caps_headers : lens = l AllCapsList

test caps_headers / \ [] = [[{""}]]
test caps_headers / \ [{X}] = [[{X}]]
test caps_headers / \ [{x}] = [[{""}, {x}]]
test caps_headers / \ [{X},{y},{Z}] = [[{X},{y}],[{Z}]]
test caps_headers / \ [{x},{y},{Z}] = [[{""}, {x},{y}],[{Z}]]

(******)

let StarHeader1 : schema = List.Cons {"*"} (List.Cons {" "} (List.NonEmptyList Char))
let StarHeader2 : schema = List.Cons {"*"} StarHeader1
let StarHeader3 : schema = List.Cons {"*"} StarHeader2

let simple_star_headers : lens = l StarHeader1
(* let simple_star_headers_unordered : lens = l_unordered StarHeader1 *) 
let star_headers : lens = l_with StarHeader1 (l StarHeader2)

let combined_headers : lens = l_with StarHeader1 (l_with StarHeader2 (l_with StarHeader3 (l AllCapsList)))
(* let combined_headers_unordered : lens = l_unordered_with StarHeader1 (l_unordered_with StarHeader2 (l_unordered_with StarHeader3 (l AllCapsList))) *)

(* Tests *)
test star_headers / \ [{"* Foo"}, {bar}] = [[{"* Foo"}, [{""}, {bar}]]]
test star_headers / \ [{"* Foo"}, {"** bar"}, {"** baz"}] = [[{"* Foo"}, [{"** bar"}],[{"** baz"}]]]
test star_headers / \ [{"* Foo"}, {"** bar"}, {glorf}, {"** baz"}, {urg}] = [[{"* Foo"}, [{"** bar"}, {glorf}],[{"** baz"}, {urg}]]]
test star_headers / \ [{"* Foo"}, {"* Bar"}, {baz}] = [[{"* Foo"}, [{""}]], [{"* Bar"}, [{""}, {baz}]]]

(* Some degenerate ones *)
test star_headers / \ [] = [[{""}, [{""}]]]
test star_headers / \ [{""}] = [[{""}, [{""}, {""}]]]
test star_headers / \ [{foo}] = [[{""}, [{""}, {foo}]]]
test star_headers / \ [{foo}, {"* Bar"}] = [[{""}, [{""}, {foo}]], [{"* Bar"}, [{""}]]]
test star_headers / \ [{foo}, {"** Bar"}] = [[{""}, [{""}, {foo}], [{"** Bar"}]]]
                                                  
sync with caps_headers at (List.T Any)
  { O = [{X},{y},{z}],
    A = [{X},{a},{z}],
    B = [{X},{y},{b}] }
  =
    (let res : view = [{X},{a},{b}] in
       { O=res, A=res, B=res })

schema NonListValue = {! \ (`List.HD,`List.TL,`List.NIL) = {}}
schema NestedListOfValues = List.T (NonListValue | NestedListOfValues)


(******************************************************************************)
(* Some useful instances packaged for invoking from the command line... *)

let text_with_all_caps_headers : lens = List.lines; caps_headers
let text_with_star_headers : lens = List.lines; star_headers
let text_with_simple_star_headers : lens = List.lines; simple_star_headers
let text_with_combined_headers : lens = List.lines; combined_headers

(******************************************************************************)
(* Lens tests *)

test text_with_combined_headers / \
  {"* FOO
   |/home/bcpierce/1abcd/efgh
   |"}
= [[{"* FOO"}, [{""}, [{""}, [{""}, {"/home/bcpierce/1abcd/efgh"}, {""}]]]]]

(******************************************************************************)
(* Sync tests *)

(* Successful propagation of non-conflicting changes *)
sync with text_with_star_headers at NestedListOfValues
  { O = {"* HEADER
        |** SUBHEADER
        |text
        |** ANOTHER SUBHEADER
        |more text"},
    A = {"* HEADER
        |** NEW SUBHEADER
        |text
        |new text
        |** ANOTHER SUBHEADER
        |more text"},
    B = {"* HEADER
        |** SUBHEADER
        |text
        |** ANOTHER NEW SUBHEADER
        |more text"}}
  =
  (let res : view = {"* HEADER
              |** NEW SUBHEADER
              |text
              |new text
              |** ANOTHER NEW SUBHEADER
              |more text"} in       
    {O=res, A=res, B=res})

(* A header conflict *)
sync with text_with_star_headers at NestedListOfValues
  { O = {"* HEADER
         |** SUBHEADER
         |text"},
    A = {"* HEADER
         |** NEW SUBHEADER
         |text"},
    B = {"* HEADER
         |** DIFFERENT NEW SUBHEADER
         |text"}}
  =
  { O = {"* HEADER
         |** SUBHEADER
         |text"},
    A = {"* HEADER
         |** NEW SUBHEADER
         |text"},
    B = {"* HEADER
        |** DIFFERENT NEW SUBHEADER
        |text"}}


