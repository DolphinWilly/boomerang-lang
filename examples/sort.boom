module Sort =

let ctypes (ls:lens List.t) = List.map{lens}{regexp} ctype ls
let atypes (ls:lens List.t) = List.map{lens}{regexp} atype ls

let disjoint (Rs:regexp List.t) : bool =
  let disj (R:regexp) (Rs:regexp List.t) =
    List.fold_left{regexp}{bool}
      (fun (ok:bool) (R':regexp) ->
	 ok && not (equiv R R'))
      true Rs in
  let (ok,_) = List.fold_left{regexp}{bool * regexp List.t}
    (fun (acc:bool * regexp List.t) (R:regexp) ->
       let (ok,Rs) = acc in
       (ok && disj R Rs,List.Cons{regexp}(R,Rs)))
    (true,#{regexp}[]) Rs in
  ok

let concat_regexps (Rs:regexp List.t) : regexp =
  List.fold_left{regexp}{regexp} 
    (fun (acc:regexp) (R:regexp) -> acc . R) 
    EPSILON Rs

let union_regexps (Rs:regexp List.t) : regexp =
  List.fold_left{regexp}{regexp}
    (fun (acc:regexp) (R:regexp) -> acc | R)
    EMPTY Rs

let sortable (Rs:regexp List.t) : bool =
  let k = List.length{regexp} Rs in
  let sigmas = List.permutations k in
  let perm_Rs (sigma:int List.t) = List.permute{regexp} sigma Rs in
  let pRs = List.map{int List.t}{regexp List.t} perm_Rs sigmas in
  (List.for_all{regexp List.t} 
     (fun (Rs_perm:regexp List.t) -> concatable Rs_perm //) pRs) &&
  disjoint (List.map{regexp List.t}{regexp} concat_regexps pRs)

let concat_lenses (ls:lens List.t where (concatable (ctypes ls) //)
                                     && (concatable (atypes ls) //))
  : (lens in concat_regexps (ctypes ls)
         <-> concat_regexps (atypes ls))
  = List.fold_left{lens}{lens} 
      (fun (l_acc:lens) (l:lens) -> l_acc . l)
      (copy EPSILON) ls

test get (concat_lenses #{lens}[copy /a/;copy /b/;copy /c/]) "abc" = "abc"

let sort_concat (ls:lens List.t where (sortable (ctypes ls))
                                   && (concatable (atypes ls) //))  
  : (lens in (union_regexps (ctypes ls))*
         <-> concat_regexps (atypes ls))
  = left_quot (sort (ctypes ls)) (concat_lenses ls)  

let ls = sort_concat #{lens}[copy /a/;copy /b/;copy /c/]
test get ls "abc" = "abc"
test get ls "cba" = "abc"
test get ls "bca" = "abc"
test get ls "bba" = error
test get ls "dba" = error
test put ls "abc" "cba" = "abc"
test ctype ls = [a-c]* (* part of the laxness of canonizers!  
                          it's actually permutations of /abc/ *)

let perm_sort (ls:lens List.t where 
		 (sortable (ctypes ls)) &&
	         (concatable (atypes ls) //))
  : (lens in ? 
         <-> concat_regexps (atypes ls))
  =
  let k = List.length{lens} ls in
  let sigmas = List.permutations k in
  let sort_lenses (sigma:int List.t) = 
    permute sigma (List.permute{lens} (List.invert_permutation sigma) ls) in
  let sorted = List.map{int List.t}{lens} sort_lenses sigmas in
  List.fold_left{lens}{lens}
    (fun (l_acc:lens) (sort_l:lens) ->
       l_acc || sort_l)
    (copy EMPTY) sorted

(* note precise ctypes *)
test ctype (perm_sort #{lens}[(copy /a/);(copy /b/)]) = (/ab/ | /ba/)
test ctype (perm_sort #{lens}[(copy /a/);(copy /b/);(copy /c/)]) = (/abc/ | /acb/ | /bac/ | /bca/ | /cab/ | /cba/)
test atype (perm_sort #{lens}[(copy /a/);(copy /b/);(copy /c/)]) = /abc/
 
let l4 = perm_sort #{lens}[(copy "a");
			   (copy "b");
			   (copy "c");
			   (copy "d")]
      
test l4.get "abcd" = "abcd"
test l4.get "abdc" = "abcd"
test l4.get "acbd" = "abcd"
test l4.get "acdb" = "abcd"
test l4.get "adbc" = "abcd"
test l4.get "adcb" = "abcd"
test l4.get "bacd" = "abcd"
test l4.get "badc" = "abcd"
test l4.get "bcad" = "abcd"
test l4.get "bcda" = "abcd"
test l4.get "bdac" = "abcd"
test l4.get "bdca" = "abcd"
test l4.get "cabd" = "abcd"
test l4.get "cadb" = "abcd"
test l4.get "cbad" = "abcd"
test l4.get "cbda" = "abcd"
test l4.get "cdab" = "abcd"
test l4.get "cdba" = "abcd"
test l4.get "dabc" = "abcd"
test l4.get "dacb" = "abcd"
test l4.get "dbac" = "abcd"
test l4.get "dbca" = "abcd"
test l4.get "dcab" = "abcd"
test l4.get "dcba" = "abcd"
