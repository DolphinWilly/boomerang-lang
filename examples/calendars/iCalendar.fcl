module ICalendar =
 open Prelude

(*-------------------------------------------------------------------------*)
(* Concrete Schemas *)
let Bool : schema = {"#true" = {}} | {"#false" = {}}

let XPList : schema = List.T ({"name" = Value, val = List.T Value})
    
let Params : schema = { ?altrepparam = Value,
			?cnparam = Value,
			?cutypeparam = Value,
			?delfromparam = List.T Value,
			?deltoparam = List.T Value,
			?dirparam = Value,
			?encodingparam = Value, 
			?fmttypeparam = Value,
			?langparam = Value,
			?memberparam = List.T Value,
			?partstatparam = Value,
			?rangeparam = Value,
			?reltypeparam = Value,
			?roleparam = Value,
			?rsvpparam = Bool,
			?sentbyparam = Value,
			?trigrelparam = Value,
			?tzidparam = { global = Bool, val = Value},
			?valuetypeparam = Value,
			?xplist = XPList
		      }

let XPListPlusVal (T : schema) : schema = {val = T, ?xplist = XPList}
    
let ParamsPlusVal (T : schema) : schema = {val = T, ?params = Params}
	
schema ICalendar = [{calprops = CalProps, components = Any}] | []
    
and CalProps = {prodid = XPListPlusVal Value,
			  version = XPListPlusVal Value,
			  ?calscale = XPListPlusVal Value,
			  ?method = XPListPlusVal Value,
			    ?xprop = XProp}
    
and XProp = List.T {"name" = Value, val = Value, ?params = Params}
    
and Components = 
  let Timezonec : schema = CompProp in
  List.T ({val = Eventc | Timezonec | Todoc , type = ({Eventc} | {Timezonec} | {Todoc})})
    
and Eventc = {props = CompProp, ?alarms = List.T CompProp}

and Todoc = {props = CompProp, ?alarms = List.T CompProp}
	
and CompProp = 
      { ?action = XPListPlusVal Value,
	?attach = List.T (ParamsPlusVal ({ "AttUri" = Value } | { "AttBinary" = Value})),
	?attendee = List.T (ParamsPlusVal Value),
	?categories = List.T (ParamsPlusVal (List.T Value)),
	?"class" = XPListPlusVal Value,
	?comment = List.T (ParamsPlusVal Value),
	?completed = XPListPlusVal DateTime,
	?contact = List.T (ParamsPlusVal Value),
	?created = XPListPlusVal DateTime,
	?daylightc = List.T CompProp,
	?description = ParamsPlusVal Value,
	?dtend = ParamsPlusVal DtPval,
	?dtstamp = ParamsPlusVal DtPval,
	?dtstart = ParamsPlusVal DtPval,
	?due = ParamsPlusVal DtPval,
	?duration = XPListPlusVal Duration,
	?exdate = List.T (ParamsPlusVal (List.T DtPval)),
	?exrule = List.T (XPListPlusVal Recur),
	?geo = Geo,
	?lastmod = XPListPlusVal DateTime,
	?location = ParamsPlusVal Value,
	?organizer = ParamsPlusVal Value,
	?percent = XPListPlusVal Value,
	?priority = XPListPlusVal Value,
	?rdate = List.T (ParamsPlusVal (List.T DtPval)),
	?recurid = ParamsPlusVal DtPval,
	?related_to = List.T (ParamsPlusVal Value),
	?repeat = XPListPlusVal Value,
	?resources = List.T (ParamsPlusVal (List.T Value)),
	?rrule =  List.T (XPListPlusVal Recur),
	?rstatus = List.T RStatus,
	?seq = XPListPlusVal Value,
	?standardc = List.T CompProp,
	?status = XPListPlusVal Value,
	?summary = ParamsPlusVal Value,
	?transp = XPListPlusVal Value,
	?trigger = ParamsPlusVal DtPval,
	?tzid = TzID,
	?tzname = List.T (ParamsPlusVal Value),
	?tzoffsetto = XPListPlusVal OffsetTime,
	?tzoffsetfrom = XPListPlusVal OffsetTime,
	?tzurl = XPListPlusVal Value,
	?uid = XPListPlusVal Value,
	?url = XPListPlusVal Value,
	?xprop = XProp
      }	

and DateTime = 
      { date = {year = Value, month = Value, day = Value},
	time = {hour = Value, minute = Value, second = Value, zulu = Value}}
	
and DtPval = 
      { "DateTimeVal" = DateTime } |
      { "DateVal" = {year = Value, month = Value, day = Value}} |
      { "PeriodVal" = Period } |
      { "DurationVal" = Duration}
      
and Period = 
      { "PeriodExplicit" = { start = DateTime, "end" = DateTime}} |
      { "PeriodStart" = { start = DateTime, duration = Duration}}
	
and Duration = { negative = Bool, length = DurLength }

and DurLength = 
      { "DurWeek" = Value } |
      { "DurTime" = { hour = Value, minute = Value, second = Value}} |
      { "DurDate" = { "Day" = Value, 
		      ?"Time"= {hour = Value, minute = Value, second = Value }}}
	
and Recur = 
      { freq = Value,
	?interval = Value,
	?bysecond = List.T Value,
	?byminute = List.T Value,
	?byhour = List.T Value,
	?byday = List.T ByDayElt,
	?bymonthday = List.T Value, 
	?byyearday = List.T Value,
	?byweekno = List.T Value,
	?bymonth = List.T Value,
	?bysetpos = List.T Value,
	?wkstart = Value,
	?bytext = { "name" = Value, val= Value },
	?"end" = { count = Value } | { until = DtPval }
      }

and ByDayElt = { weekday = Value, ?which = Value}
	
and Geo = { latitude = Value, longitude = Value, ?xplist = XPList}
	
and RStatus = 
      { code = List.T Value, text = Value, ?extdata = Value, ?params = Params}
	
and TzID = { global = Bool, val = Value, ?xplist = XPList }
	
and OffsetTime = 
      { positive = Bool, hour = Value, minute = Value, second = Value }

(* (\* this is just a trick to temporary *not* use CompProps ('tis too slow) or Params *\) *)
(* and CompProp : schema = Any *)
(* and Params : schema = Any *)

(*-------------------------------------------------------------------------*)
(* Abstract Schemas *)
schema XPList_A = { * = { * = {} }}

schema Params_A = { ?altrepparam = Value,
		    ?cnparam = Value,
		    ?cutypeparam = Value,
		    ?delfromparam = { * = {} },
		    ?deltoparam = { * = {} },
		    ?dirparam = Value,
		    ?encodingparam = Value, 
		    ?fmttypeparam = Value,
		    ?langparam = Value,
		    ?memberparam = { * = {} },
		    ?partstatparam = Value,
		    ?rangeparam = Value,
		    ?reltypeparam = Value,
		    ?roleparam = Value,
		    ?rsvpparam = Bool,
		    ?sentbyparam = Value,
		    ?trigrelparam = Value,
		    ?tzidparam = { global = Bool, val = Value},
		    ?valuetypeparam = Value,
		    ?xplist = XPList_A
		  }

let XPListPlusVal_A (T : schema) : schema =
  { val = T, ?xplist = XPList_A} | {!\val,xplist = XPList_A}
    
let ParamsPlusVal_A (T : schema) : schema =
  { val = T, ?params = Params_A} | {!\val,params = {?params = Params_A}}
  
schema XProp_A = { * = {val = Value, ?params = Params_A}}

and Components_A = 
  let Timezonec_A : schema = CompProp_A in
  {?Eventc = { * = (CompProp_A + {?alarms = List.T CompProp_A})},
    ?Todoc = { * = (CompProp_A + {?alarms = List.T CompProp_A})},
    ?Timezonec = { * = Timezonec_A}}
    
and Eventc_A = { props = CompProp_A, ?alarms = List.T CompProp_A}

and Todoc_A = { props = CompProp_A, ?alarms = List.T CompProp_A}
    
and CompProp_A =
      { ?action = XPListPlusVal_A Value,
	?attach = List.T (ParamsPlusVal_A ({ "AttUri" = Value } | { "AttBinary" = Value})),
	?attendee = List.T (ParamsPlusVal_A Value),
	?categories = List.T (ParamsPlusVal_A { * = {} }),
	?"class" = XPListPlusVal_A Value,
	?comment = List.T (ParamsPlusVal_A Value),
	?completed = XPListPlusVal_A DateTime_A,
	?contact = List.T (ParamsPlusVal_A Value),
	?created = XPListPlusVal_A DateTime_A,
 	?daylightc = List.T CompProp_A,
	?description = ParamsPlusVal_A Value,
	?dtend = ParamsPlusVal_A DtPval_A,
	?dtstamp = (ParamsPlusVal_A DtPval_A) | {},
	?dtstart = ParamsPlusVal_A DtPval_A,
	?due = ParamsPlusVal_A DtPval_A,
	?duration = XPListPlusVal_A Duration_A,
	?exdate = List.T (ParamsPlusVal_A (List.T DtPval_A)),
	?exrule = List.T (XPListPlusVal_A Recur_A),
	?geo = Geo_A,
	?lastmod = (XPListPlusVal_A DateTime_A) | {},
	?location = ParamsPlusVal_A Value,
	?organizer = ParamsPlusVal_A Value,
	?percent = XPListPlusVal_A Value,
	?priority = XPListPlusVal_A Value,
	?rdate = List.T (ParamsPlusVal_A (List.T DtPval_A)),
	?recurid = ParamsPlusVal_A DtPval_A,
	?related_to = List.T (ParamsPlusVal_A Value),
	?repeat = XPListPlusVal_A Value,
	?resources = List.T (ParamsPlusVal_A { * = {}}),
	?rrule =  List.T (XPListPlusVal_A Recur_A),
	?rstatus = List.T RStatus_A,
	?seq = XPListPlusVal_A Value,
	?standardc = List.T CompProp_A,
	?status = XPListPlusVal_A Value,
	?summary = ParamsPlusVal_A Value,
	?transp = XPListPlusVal_A Value,
	?trigger = ParamsPlusVal_A DtPval_A,
	?tzid = TzID_A,
	?tzname = List.T (ParamsPlusVal_A Value),
	?tzoffsetto = XPListPlusVal_A OffsetTime_A,
	?tzoffsetfrom = XPListPlusVal_A OffsetTime_A,
	?tzurl = XPListPlusVal_A Value,
	?uid = XPListPlusVal_A Value,
	?url = XPListPlusVal_A Value,
	?xprop = XProp_A
      }

and DateTime_A = 
  { date = {year = (Value | {}), month = (Value | {}), day = (Value | {})},
    time = {hour = (Value | {}), minute = (Value | {}), second = (Value | {}), zulu = Value}}
	
and DtPval_A = 
  { "DateTimeVal" = DateTime_A } |
  { "DateVal" = {year = Value, month = Value, day = Value}} |
  { "PeriodVal" = Period_A } |
  { "DurationVal" = Duration_A }
      
and Period_A = 
      { "PeriodExplicit" = { start = DateTime_A, "end" = DateTime_A}} |
      { "PeriodStart" = { start = DateTime_A, duration = Duration_A}}
	
and Duration_A = { negative = Bool, length = DurLength_A }

and DurLength_A = 
      { "DurWeek" = Value } |
      { "DurTime" = { hour = Value, minute = Value, second = Value}} |
      { "DurDate" = { "Day" = Value, 
		      ?"Time"= {hour = Value, minute = Value, second = Value }}}
	
and Recur_A = 
      { freq = Value,
	?interval = Value,
	?bysecond = { * = {} },
	?byminute = { * = {} },
	?byhour = { * = {} },
	?byday = List.T ByDayElt_A,
	?bymonthday = { * = {} }, 
	?byyearday = { * = {} },
	?byweekno = { * = {} },
	?bymonth = { * = {} },
	?bysetpos = { * = {} },
	?wkstart = Value,
	?bytext = { "name" = Value, val= Value },
	?"end" = { count = Value } | { until = DtPval_A }
      }

and ByDayElt_A = { weekday = Value, ?which = Value}
	
and Geo_A = { latitude = Value, longitude = Value, ?xplist = XPList_A}
	
and RStatus_A = 
      { code = { * = {} }, text = Value, ?extdata = Value, ?params = Params_A}
	
and TzID_A = { ! = {}}
	
and OffsetTime_A = 
      { positive = Bool, hour = Value, minute = Value, second = Value }

schema ICalendar_A = Components_A

let domCompProp : view = 
  { "action", "attach", "attendee", "categories", "class",
    "comment", "completed", "contact", "created", "daylightc", 
    "description", "dtend", "dtstamp", "dtstart", "due", "duration",
    "exdate", "exrule", "geo", "lastmod", "location", "organizer",
    "percent", "priority", "rdate", "recurid", "related_to", "repeat",
    "resources", "rrule", "rstatus", "seq", "standardc", "status",
    "summary", "transp", "trigger", "tzid", "tzname", "tzoffsetto",
    "tzoffsetfrom", "tzurl", "uid", "url", "xprop"}

let domCompPropWoLastmod : view = 
  { "action", "attach", "attendee", "categories", "class",
    "comment", "completed", "contact", "created", "daylightc", 
    "description", "dtend", "dtstamp", "dtstart", "due", "duration",
    "exdate", "exrule", "geo", "location", "organizer",
    "percent", "priority", "rdate", "recurid", "related_to", "repeat",
    "resources", "rrule", "rstatus", "seq", "standardc", "status",
    "summary", "transp", "trigger", "tzid", "tzname", "tzoffsetto",
    "tzoffsetfrom", "tzurl", "uid", "url", "xprop"}

(* let ICalendar : schema = [{calprops = CalProps, components = Components}] | [] *)
let icalendar_lens (filtering: lens): lens =
  assert ICalendar;
  acond [] {}
    (const {} [])
    (List.hd []; (* assuming only one calendar object *)
     focus "components"
       { calprops = { prodid = { val = { "Harmony" }},
		      version = { val = { "2.0" }}}};
     protect (components_lens filtering));
  assert ICalendar_A
    
(* and XPListPlusVal (T : schema) : schema = {val = T, ?xplist = XPList} *)
and xplistplusval_lens (l: lens) : lens =
  assert (XPListPlusVal Any);
  mapn "val" l; mapn "xplist" (protect xplist_lens);
  acond { val = Value, ?xplist = Any } { ! = {?xplist = XPList_A}}
    (pivot "val")
    id;
  assert (XPListPlusVal_A Any)
    
(* and XPList : schema = List.T ({"name" = Value, val = List.T Value}) *)
and xplist_lens : lens =
  assert XPList;
  List.map 
    (pivot "name";
     map (hoist "val"; List.flatten; map (List.hd [])));
  List.flatten;
  map (List.hd []); (** check that !! this assumes that the same name does'nt 
		      appear twice in a xplist *)
  assert XPList_A
    
(* and XProp : schema = List.T {"name" = Value, val = Value, ?params = Params} *)
and xprop_lens : lens =
  assert XProp;
  List.map (pivot "name";
	    map (mapp {"params"} (protect params_lens)));
  List.flatten;
  map (List.hd []); (** same remark as above *)
  assert XProp_A

and params_lens : lens =
  assert Params;
  mapp {delfromparam, deltoparam, memberparam}
    (List.flatten; map (List.hd []));
  mapp {"xplist"} xplist_lens;
  assert Params_A
    
(* and Bool : schema = {"#true" = {}} | {"#false" = {}} *)
  
(* and ValueNotList : schema = { !\(`List.HD, `List.TL, `List.NIL) = {}} *)

(* and Components : schema =  *)
(*   List.T ({val = Eventc, type = {Eventc}} | {val = Timezonec, type = {Timezonec}}) *)
and components_lens (filtering: lens) : lens =
  assert Components;
  List.map
    (acond {val = Eventc, type = Any} {type = {Eventc}, val = Any}
       (mapp {val} (protect (eventc_lens filtering)))
       (acond {val = Todoc, type = Any} {type = {Todoc}, val = Any}
	  (mapp {val} (protect (todoc_lens filtering)))
	  (mapp {val} (protect (timezonec_lens filtering))));
     pivot "type"; map (hoist "val"));
  List.flatten;
  mapn "Eventc" (List.map (hoist_nonunique "props" domCompProp; pivot "uid");
		 List.flatten; map (List.hd []));
  mapn "Todoc" (List.map (hoist_nonunique "props" domCompProp; pivot "uid");
		List.flatten; map (List.hd []));
  mapn "Timezonec" (List.map (pivot "tzid"); List.flatten; map (List.hd []));
  assert Components_A
    
(* and Eventc : schema = {props = CompProp, ?alarms = List.T CompProp} *)
and eventc_lens (filtering: lens) : lens =
  assert Eventc;
  mapn "props" (compprop_lens filtering);
  mapn "alarms" (List.map (compprop_lens filtering));
  assert Eventc_A

(* and Todoc : schema = {props = CompProp, ?alarms = List.T CompProp} *)
and todoc_lens (filtering: lens) : lens =
  assert Todoc;
  mapn "props" (compprop_lens filtering);
  mapn "alarms" (List.map (compprop_lens filtering));
  assert Todoc_A
	
and compprop_lens (filtering: lens) : lens =
   assert CompProp;
   mapp {"description","location","organizer","summary"} (paramsplusval_lens id);
   mapp { "action","class","percent","priority","repeat","seq","status","transp","tzurl","uid","url"} (xplistplusval_lens id);
   mapp {"dtend","dtstamp","dtstart","due","recurid","trigger"} (paramsplusval_lens dtpval_lens);
   mapp {"completed","created","lastmod"} (xplistplusval_lens datetime_lens);
   mapp {"tzoffsetto","tzoffsetfrom"} (xplistplusval_lens offsettime_lens);
   mapn "duration" (xplistplusval_lens duration_lens);
   mapp {"attach","attendee","comment","contact","related_to","tzname"} (List.map (paramsplusval_lens id));
   mapp {"categories","resources"} (List.map (paramsplusval_lens (List.flatten; map (List.hd []))));
   mapp {"daylightc","standardc"} (List.map (compprop_lens filtering));
   mapp {"exdate","rdate"} (List.map (paramsplusval_lens (List.map dtpval_lens)));
   mapn "rstatus" (List.map rstatus_lens);
   mapp {"exrule","rrule"} (List.map (xplistplusval_lens recur_lens));
   mapn "geo" geo_lens;
   mapn "tzid" tzid_lens;
   mapn "xprop" xprop_lens;
   filtering;
   assert CompProp_A

(* and ParamsPlusVal (T : schema) : schema = { val = T, ?params = Params} *)
and paramsplusval_lens (l: lens) : lens =
  assert (ParamsPlusVal Any);
  mapn "val" l;
  mapn "params" (params_lens);
  acond {val = Value, ?params = Params} {! = {?params = Params_A}}
	(pivot "val")
	id;
  assert (ParamsPlusVal_A Any)
	
(* and DateTime : schema =  *)
(*       { date = {year = Value, month = Value, day = Value}, *)
(* 	time = {hour = Value, minute = Value, second = Value, zulu = Value}} *)
and datetime_lens : lens =
  assert DateTime;
  id;
  assert DateTime_A
	
(* and DtPval : schema =  *)
(*       { "DateTimeVal" = DateTime } | *)
(*       { "DateVal" = {year = Value, month = Value, day = Value}} | *)
(*       { "PeriodVal" = Period } | *)
(*       { "DurationVal" = Duration} *)
and dtpval_lens : lens =
  assert DtPval; 
  mapn "DateTimeVal" datetime_lens;
  mapn  "PeriodVal" (protect period_lens);
  mapn "DurationVal" (protect duration_lens);
  assert DtPval_A
(** rename everything to one single date here ?
   then I have to have different schemas inside
   to be able to put the right thing in the put way *)

(* and Period : schema =  *)
(*       { "PeriodExplicit" = { start = DateTime, "end" = DateTime}} | *)
(*       { "PeriodStart" = { start = DateTime, duration = Duration}} *)
and period_lens : lens =
  assert Period;
  mapn "PeriodExplicit" (map datetime_lens);
  mapn "PeriodStart" (mapn "Start" datetime_lens; mapn "duration" (protect duration_lens));
  assert Period_A
	
(* and Duration : schema = { negative = Bool, length = DurLength } *)
and duration_lens : lens =
  assert Duration;
  mapp {"length"} (protect durlength_lens);
  assert Duration_A

(* and DurLength : schema =  *)
(*       { "DurWeek" = Value } | *)
(*       { "DurTime" = { hour = Value, minute = Value, second = Value}} | *)
(*       { "DurDate" = { "Day" = Value,  *)
(* 		      ?"Time"= {hour = Value, minute = Value, second = Value }}} *)
and durlength_lens : lens =
  assert DurLength;
  id;
  assert DurLength_A

(* and Recur : schema =  *)
(*       { freq = Value, *)
(* 	?interval = Value, *)
(* 	?bysecond = List.T Value, *)
(* 	?byminute = List.T Value, *)
(* 	?byhour = List.T Value, *)
(* 	?byday = List.T ByDayElt, *)
(* 	?bymonthday = List.T Value,  *)
(* 	?byyearday = List.T Value, *)
(* 	?byweekno = List.T Value, *)
(* 	?bymonth = List.T Value, *)
(* 	?bysetpos = List.T Value, *)
(* 	?wkstart = Value, *)
(* 	?bytext = { "name" = Value, val= Value }, *)
(* 	?"end" = { count = Value } | { until = DtPval } *)
(*       } *)
and recur_lens : lens =
  assert Recur;
  mapp { "bysecond", "byminute", "byhour", "bymonthday",
	 "byyearday", "byweekno", "bymonth", "bysetpos"}
	(List.flatten; map (List.hd []));
  mapn "byday" (List.map (protect bydayelt_lens));
  mapn "bytext" (pivot "name"; map (hoist "val"));
  mapn "end" (acond {count=Value} {count=Value} id (map dtpval_lens));
  assert Recur_A

(* and ByDayElt : schema = { weekday = Value, ?which = Value} *)
and bydayelt_lens : lens =
  assert ByDayElt;
  id;
  assert ByDayElt_A
	
(* and Geo : schema = { latitude = Value, longitude = Value, ?xplist = XPList} *)
and geo_lens : lens =
  assert Geo;
  mapp {"xplist"} xplist_lens;
  assert Geo_A
	
(* and RStatus : schema =  *)
(*       { code = List.T Value, text = Value, ?extdata = Value, ?params = Params} *)
and rstatus_lens : lens =
  assert RStatus;
  mapn "code" (List.flatten; map (List.hd []));
  mapn "params" params_lens;
  assert RStatus_A
	
(* and TzID : schema = { global = Bool, val = Value, ?xplist = XPList } *)
and tzid_lens : lens =
  assert TzID;
  pivot "val"; map ( const {} {"global" = {"#true"}});
  assert TzID_A
	
(* and OffsetTime : schema =  *)
(*       { positive = Bool, hour = Value, minute = Value, second = Value } *)
and offsettime_lens : lens =
  assert OffsetTime;
  id;
  assert OffsetTime

(* and Timezonec : schema = CompProp *)
and timezonec_lens (filtering: lens) : lens =
  assert CompProp;
  compprop_lens filtering;
  assert CompProp_A

(*-------------------------------------------------------------------------*)
(* general lens, keeping everything in bushes *)
let l : lens = 
  icalendar_lens id

(* lens filtering away dtstamps and lastmods
   and updating them as appropriate on the putback *)
let dtstamp_lens : lens =
  mapn "val"
    (mapn "DateTimeVal" 
       (mapn "date"
	  (mapn "day" (fconst {} "date +%d");
	   mapn "month" (fconst {} "date +%m");
	   mapn "year" (fconst {} "date +%Y"))));
  mapn "time"
    (mapn "hour" (fconst {} "date +%H");
     mapn "minute" (fconst {} "date +%M");
     mapn "second" (fconst {} "date +%S"))

let lastmod_lens : lens =
  mapn "lastmod"
    ((focus "val" {}; hoist_nonunique "date" {"day", "month", "year"};
      hoist_nonunique "time" {"hour", "minute", "second", "zulu"};
      prune "zulu" {"#true"}));
  hoist_nonunique "lastmod" {"day", "month", "year", "hour", "minute", "second"};
  fmodify "day" "date +%d"; fmodify "month" "date +%m"; fmodify "year" "date +%Y";
  fmodify "hour" "date +%H"; fmodify "minute" "date +%M"; fmodify "second" "date +%S"
    
let l_stamps : lens =
    icalendar_lens (mapn "dtstamp" dtstamp_lens);
    map (map lastmod_lens)
