module Xml = 

(* [WS] and [WSP] are regexps denoting whitespace and "positive" whitespace. *)
let WS : regexp = [ \n]*
let WSP : regexp = [ \n]+
  
(* sorting lenses *)
let sort2 (l1:lens) (l2:lens) : lens = 
  ( l1 . l2 || l2 ~ l1)

test sort2 (copy "a") (copy "b").get "ab" = "ab"
test sort2 (copy "a") (copy "b").get "ba" = "ab"

let sort3 (l1:lens) (l2:lens) (l3:lens) : lens = 
  let s23 : lens = sort2 l2 l3 in 
  ( l1 . s23
    || (l2 ~ l1) . l3
    || l3 ~ (l1 . l2)
    || s23 ~ l1 )

let l3 = sort3 (copy "a") (copy "b") (copy "c")
test l3.get "abc" = "abc"
test l3.get "acb" = "abc"
test l3.get "bac" = "abc"
test l3.get "bca" = "abc"
test l3.get "cab" = "abc"
test l3.get "cba" = "abc"

(* sort4 requires that (l2,l4) and (l1,l3) be unambiguously
   concatenable, as an artifact of the way we implement it using a
   binary swap operator and composition. we wouldn't need this if we
   had a more powerful permutation operator on lenses. *)
let sort4 (l1:lens) (l2:lens) (l3:lens) (l4:lens) : lens = 
  let s12 : lens = sort2 l1 l2 in 
  let s23 : lens = sort2 l2 l3 in 
  let s34 : lens = sort2 l3 l4 in 
  let s123 : lens = sort3 l1 l2 l3 in 
  let s234 : lens = sort3 l2 l3 l4 in 
  let f1324 : lens = 
    copy (atype l1) . 
    (copy (atype l3) ~ (copy (atype l2))) . 
    copy (atype l4) in 
  ( l1 . s234 
  || s234 ~ l1
  || ((l2 . l3) ~ l1) . l4
  || (l2 ~ l1) . s34 
  || (l3 ~ s12) . l4
  || l4 ~ (l1 . s23)
  || l4 ~ ((l2 ~ l1) . l3)
  || l4 ~ (l3 ~ (l1 . l2))
  || (l3 . l4) ~ (l1 . l2) 
  || ( (l2 . l4) ~ (l1 . l3); f1324 )
  || ( (l3 ~ l1) . (l4 ~ l2); f1324 ) )

let l4 = sort4 (copy "a") (copy "b") (copy "c") (copy "d")
      
test l4.get "abcd" = "abcd"
test l4.get "abdc" = "abcd"
test l4.get "acbd" = "abcd"
test l4.get "acdb" = "abcd"
test l4.get "adbc" = "abcd"
test l4.get "adcb" = "abcd"
test l4.get "bacd" = "abcd"
test l4.get "badc" = "abcd"
test l4.get "bcad" = "abcd"
test l4.get "bcda" = "abcd"
test l4.get "bdac" = "abcd"
test l4.get "bdca" = "abcd"
test l4.get "cabd" = "abcd"
test l4.get "cadb" = "abcd"
test l4.get "cbad" = "abcd"
test l4.get "cbda" = "abcd"
test l4.get "cdab" = "abcd"
test l4.get "cdba" = "abcd"
test l4.get "dabc" = "abcd"
test l4.get "dacb" = "abcd"
test l4.get "dbac" = "abcd"
test l4.get "dbca" = "abcd"
test l4.get "dcab" = "abcd"
test l4.get "dcba" = "abcd"

(* --------------------------------------------------------------------------- *)
(* XML functions *)

(* [xml_esc_char ex] maps an XML symbol -- either a character or an
   escaped characeter -- to its equivalent representation in ASCII.
   o [ex] is the set of excluded characters
 *)
let esc_char (excl_chars:regexp) : lens = 
  ( copy ([^&<>\n""] - excl_chars)
  | "&gt;" <-> ">"
  | "&lt;" <-> "<"
  | "&amp;" <-> "&" 
  | "&quot;" <-> "\"" )

(* [esc_string_ends ex ends_ex] maps an XML-escaped string
   beginning and ending with characters not in [ex] or [ends_ex], to
   its equivalent representation in ASCII.
   o [ex] the set of excluded characters.       
   o [ends_ex] the set of excluded characters at the end points.
*)
let esc_string_ends (excl_chars:regexp) (ends_excl_chars:regexp) : lens = 
  let echar : lens = esc_char excl_chars in 
  let echar_ends : lens = esc_char (excl_chars | ends_excl_chars) in 
  echar_ends . (echar* . echar_ends)?

(* [esc_string ex] maps an XML-escaped string starting and
   beginning with a non-space character, to its equivalent
   representation in ASCII.
   o [ex] the set of excluded characters.  
*)
let esc_string (excl_chars:regexp) : lens = 
  esc_string_ends excl_chars [ ] 

(* [open sp t] recognizes and deletes a string consisting of
   whitespace and the start of an XML open tag.
   o [sp] is used to canonize the leading whitespace.
   o [t] is the tag.
*)
let raw_open (spaces:string) (tag:string) : lens = 
  qdel WS spaces . 
  del ("<" . tag) 

let simple_open_tag (tag:string) : lens = 
  del ("<" . tag . ">")

(* [close] recognizes and deletes the string ">" *)
let close : lens = 
  del ">"

(* [slash_close] recognizes and deletes strings consisting of
   whitespace followed by "/>", which is used to terminate XML
   elements whose children are all attributes.
*)
let slash_close : lens = 
  qdel (WS . /\/>/) "/>"

(* [open_tag sp t] recognizes and deletes a string consisting of
   whitespace followed by an XML open tag.
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let open_tag (spaces:string) (tag:string) : lens = 
  raw_open spaces tag . 
  close

(* [simple_close_tag t] recognizes and deletes a string consisting
   of an XML close tag.
   o [t] element tag.   
*)
let simple_close_tag (tag:string) : lens = 
  del ("</" . tag . ">")

(* [close_tag sp t] recognizes and deletes a string consisting of
   whitespace followed by an XML close tag. 
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let close_tag (spaces:string) (tag:string) : lens = 
  qdel WS spaces . 
  simple_close_tag tag

(* [simple_elt sp t l] proecesses a single-line XML element.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [l] lens for processing the children.
*)
let simple_elt (spaces:string) (tag:string) (body:lens) : lens = 
  open_tag spaces tag . 
  body . 
  simple_close_tag tag

(* [simple_elt_no_kids sp t] proecesses a single-line XML element 
   with no children.
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let simple_elt_no_kids (spaces:string) (tag:string) : lens = 
  open_tag spaces tag . 
  simple_close_tag tag


(* [elt sp t l] processes a multi-line XML element.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [l] lens for processing children.
*)
let elt (spaces:string) (tag:string) (body:lens) : lens = 
  open_tag spaces tag . 
  body . 
  close_tag spaces tag

let raw_simple_elt (tag:string) (body:lens) : lens = 
  simple_open_tag tag . 
  body . 
  simple_close_tag tag 
  
(* [attr n l] proceses a string consiting of whitespace and a
   single XML attribute. Leading whitespace is canonized to a single
   space.
   o [n] attribute name.
   o [l] lens for processing value.
*)
let attr (name:string) (value:lens) : lens = 
  qdel WSP " " . 
  del name . 
  del "=\"" . 
  value . 
  del "\""
    
(* [attr1_elt sp t n v l] processes a multi-line XML element with
   one attribute.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [n] attribute name.
   o [v] lens for processing attribute value.
   o [l] lens for processing element children.
*)
let attr1_elt (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  attr name value . 
  close . 
  body . 
  close_tag spaces tag 

let attr1_elt_swap (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  ( (attr name value) ~
    ( close . body ) ) . 
  close_tag spaces tag 
    
(* [attr1_simple_elt sp t n v l] processes a single-line XML element with
   one attribute.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [n] attribute name.
   o [v] lens for processing attribute value.
   o [l] lens for processing element children.
*)
let attr1_simple_elt (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  attr name value . 
  close . 
  body . 
  simple_close_tag tag 

let attr1_raw_simple_elt (tag:string)
    (name:string) (value:lens)
    (body:lens) = 
  del ("<" . tag) . 
  attr name value . 
  close . 
  body . 
  simple_close_tag tag 

(* [attr2_elt sp t n1 v1 n2 v2 l] processes a multi-line XML
   element with two attributes.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
   o [l] lens for processing element children.
*)
let attr2_elt (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  sort2 
    (attr name1 value1) 
    (attr name2 value2) . 
  close . 
  body . 
  close_tag spaces tag 

let attr2_raw_simple_elt_no_kids (tag:string)
    (name1:string) (value1:lens)
    (name2:string) (value2:lens) : lens = 
  del ("<" . tag) . 
  sort2 
    (attr name1 value1)
    (attr name2 value2) . 
  slash_close 

(* [attrk_elt_no_kids sp t n1 v1 .. nk vk] processes a single-line XML element with
   no children (other than its attributes.)
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
*)
let attrs_elt_no_kids (spaces:string) (tag:string) 
    (attrs:lens) : lens = 
  raw_open spaces tag . 
  attrs . 
  slash_close

let attr1_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) : lens = 
  attrs_elt_no_kids spaces tag 
    (attr name1 value1)
    
let attr2_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (sort2
    (attr name1 value1) 
    (attr name2 value2))

let attr3_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (sort3 
    (attr name1 value1) 
    (attr name2 value2)  
    (attr name3 value3))

let attr4_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
    (name4:string) (value4:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (sort4
    (attr name1 value1) 
    (attr name2 value2)  
    (attr name3 value3)
    (attr name4 value4))

(* [attrk_open sp t n1 v1 .. nk vk] opens a single-line XML element with k attributes.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
*)
let attrs_open (spaces:string) (tag:string) 
    (attrs:lens) : lens = 
  raw_open spaces tag . 
  attrs . 
  close  

let attr1_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) : lens = 
  attrs_open spaces tag 
    (attr name1 value1)

let attr2_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_open spaces tag 
    (sort2
       (attr name1 value1)
       (attr name2 value2))

let attr3_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_open spaces tag 
    ( sort3
        (attr name1 value1) 
        (attr name2 value2)  
        (attr name3 value3) )
    
let attr4_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) : lens = 
  attrs_open spaces tag 
    ( sort4
        (attr name1 value1) 
        (attr name2 value2)  
        (attr name3 value3) 
        (attr name4 value4) )

(* attrN_elt_swap2 *)
let attr2_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  (attr2_elt_open spaces tag 
     name1 value1 
     name2 value2 .
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2) ~ copy (atype body) ) )

let attr3_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (body:lens) : lens = 
  (attr3_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3) ~ copy (atype body) ) )

let attr4_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) 
    (body:lens) : lens = 
  (attr4_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3
     name4 value4 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3 . atype value4) ~ copy (atype body) ) )

