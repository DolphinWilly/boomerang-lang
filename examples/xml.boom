module Xml = 

  let WS = [ \n]*
  let WSP = [ \n]+ 

(* --------------------------------------------------------------------------- *)
(* XML functions *)

(* [unesc_char ex] maps an XML symbol -- either a character or an
   escaped characeter -- to its equivalent representation in ASCII.
   o [ex] is the set of excluded characters, and must be a cset

  By default, newlines and quotes are excluded (they are dealt with
  elsewhere).
*)

let xml_escs = #{char * string}['>',"&gt;";
				'<',"&lt;";
				'&',"&amp;";
				'"',"&quot;"]

let unesc_char (excl:regexp where is_cset excl) : lens 
  = Escaping.unescape_char ([^\n] - excl) (Escaping.restrict excl xml_escs)

(* [unesc_string_ends ex ends_ex] maps an XML-escaped string
   beginning and ending with characters not in [ex] or [ends_ex], to
   its equivalent representation in ASCII.
   o [ex] the set of excluded characters.       
   o [ends_ex] the set of excluded characters at the end points.
*)
let unesc_string_ends
    (excl:regexp where is_cset excl)
    (ends_excl:regexp where is_cset ends_excl) 
  : lens 
  = let middle = unesc_char excl in
    let ends = unesc_char (excl | ends_excl) in
    ends . (middle* . ends)?

(* [unesc_string ex] maps an XML-escaped string starting and
   beginning with a non-space character, to its equivalent
   representation in ASCII.
   o [ex] the set of excluded characters.  
*)
let unesc_string (excl:regexp where is_cset excl) : lens =
  unesc_string_ends excl [ ]

let OPEN (tag:string) : regexp = "<" . tag . ">"

(* [open sp t] recognizes and deletes a string consisting of
   whitespace and the start of an XML open tag.
   o [sp] is used to canonize the leading whitespace.
   o [t] is the tag.
*)
let raw_open (spaces:string) (tag:string) : (lens in (WS . "<" . tag) <=> "") = 
  qdel WS spaces . 
  del ("<" . tag) 

let simple_open_tag (tag:string) : (lens in OPEN tag <=> "") = 
  del ("<" . tag . ">")

(* [close] recognizes and deletes the string ">" *)
let close : (lens in ">" <-> "") = 
  del ">"

(* [slash_close] recognizes and deletes strings consisting of
   whitespace followed by "/>", which is used to terminate XML
   elements whose children are all attributes.
*)
(* Why is this bijective?  It's bijective "up to" canonization... *)
let slash_close : (lens in (WS . "/>") <=> "") = 
  qdel (WS . /\/>/) "/>"

(* [open_tag sp t] recognizes and deletes a string consisting of
   whitespace followed by an XML open tag.
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let open_tag (spaces:string) (tag:string) 
  : (lens in (WS . OPEN tag) <=> "") 
  = raw_open spaces tag . 
    close

let CLOSE (tag:string) : regexp = "</" . tag . ">"

(* [simple_close_tag t] recognizes and deletes a string consisting
   of an XML close tag.
   o [t] element tag.   
*)
let simple_close_tag (tag:string) : (lens in CLOSE tag <=> "") = 
  del ("</" . tag . ">")

(* [close_tag sp t] recognizes and deletes a string consisting of
   whitespace followed by an XML close tag. 
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let close_tag (spaces:string) (tag:string) 
  : (lens in (WS . CLOSE tag) <=> "") 
  = qdel WS spaces . 
    simple_close_tag tag

(* [simple_elt sp t l] proecesses a single-line XML element.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [l] lens for processing the children.
*)
let simple_elt (spaces:string) (tag:string) (body:lens) 
  : (lens in (WS . OPEN tag . ctype body . CLOSE tag) <-> atype body)
  = open_tag spaces tag . 
    body . 
    simple_close_tag tag

(* [simple_elt_no_kids sp t] proecesses a single-line XML element 
   with no children.
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let simple_elt_no_kids (spaces:string) (tag:string) 
  : (lens in (WS . OPEN tag . CLOSE tag) <-> "")
  = open_tag spaces tag . 
    simple_close_tag tag

(* [elt sp t l] processes a multi-line XML element.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [l] lens for processing children.
*)
let elt (spaces:string) (tag:string) (body:lens) 
  : (lens in (WS . OPEN tag . ctype body . WS . CLOSE tag) <-> atype body)
  = open_tag spaces tag . 
    body . 
    close_tag spaces tag

(* [top t l] processes a top-level multi-line XML element.
   o [t] element tag.
   o [l] lens for processing children.

  there is no spacing before the open tag, and there is a newline
  before the close tag
*)
let top (tag:string) (body:lens) 
  : (lens in (WS . OPEN tag . ctype body . WS . CLOSE tag) <-> atype body)
  = open_tag "" tag .
    body .
    close_tag NL0 tag

let raw_simple_elt (tag:string) (body:lens) 
  : (lens in (OPEN tag . ctype body . CLOSE tag) <-> atype body)
  = simple_open_tag tag . 
    body . 
    simple_close_tag tag 
  
let ATTR (name:string) (value:regexp) : regexp 
    = WSP . name . "=\"" . value . '"'

(* [attr n l] proceses a string consiting of whitespace and a
   single XML attribute. Leading whitespace is canonized to a single
   space.
   o [n] attribute name.
   o [l] lens for processing value.

   N.B. we should allow single quotes, too
*)
let attr (name:string) (value:lens) 
  : (lens in ATTR name (ctype value) <-> atype value)
  = qdel WSP " " . 
    del name . 
    del "=\"" . 
    value . 
    del "\""

(*
From W3C XML 1.1 Recommendation, 2nd Ed.
http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-prolog

prolog	     ::= XMLDecl  Misc* (doctypedecl  Misc* )?
XMLDecl	     ::=	'<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
VersionInfo  ::=	S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')
Eq	     ::=	S? '=' S?
VersionNum   ::=	'1.1'
Misc	     ::=	Comment | PI | S 
EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )
EncName      ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
*)

let optional (l : lens where rel_is_id (arel l)
		          && disjoint_cex "" (ctype l))
  : (lens in (ctype l)? <-> (atype l)?)
  = "" || l

let version : regexp = "1." . [01]
let enc_name : regexp = [A-Za-z] . ([A-Za-z0-9._]|'-')*

let xmldecl : (lens in ("<?xml" . (ATTR "version" version)
			        . (ATTR "encoding" enc_name)?
				. (ATTR "standalone" ("yes"|"no"))?
				. WS . "?>")
                   <-> "")
  = del "<?xml" . 
    (attr "version" (del version)) .
    optional (attr "encoding" (del enc_name)) .
    optional (attr "standalone" (del ("yes" | "no"))) .
    qdel WS "" .
    del "?>"

test xmldecl.get "<?xml version=\"1.0\" ?>" = ""
    
(* [attr1_elt sp t n v l] processes a multi-line XML element with
   one attribute.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [n] attribute name.
   o [v] lens for processing attribute value.
   o [l] lens for processing element children.
*)
let attr1_elt (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  attr name value . 
  close . 
  body . 
  close_tag spaces tag 

let attr1_elt_swap (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  ( (attr name value) ~
    ( close . body ) ) . 
  close_tag spaces tag 
    
(* [attr1_simple_elt sp t n v l] processes a single-line XML element with
   one attribute.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [n] attribute name.
   o [v] lens for processing attribute value.
   o [l] lens for processing element children.
*)
let attr1_simple_elt (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  attr name value . 
  close . 
  body . 
  simple_close_tag tag 

let attr1_raw_simple_elt (tag:string)
    (name:string) (value:lens)
    (body:lens) = 
  del ("<" . tag) . 
  attr name value . 
  close . 
  body . 
  simple_close_tag tag 

(* [attr2_elt sp t n1 v1 n2 v2 l] processes a multi-line XML
   element with two attributes.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
   o [l] lens for processing element children.
*)
let attr2_elt (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  Sort.sort_concat #{lens}[(attr name1 value1);(attr name2 value2)] . 
  close . 
  body . 
  close_tag spaces tag 

let slow_attr2_elt (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  raw_open spaces tag . 
  Sort.perm_sort_concat
    #{lens}[(attr name1 value1);
	    (attr name2 value2)] . 
  close . 
  body . 
  close_tag spaces tag 

let attr2_raw_simple_elt_no_kids (tag:string)
    (name1:string) (value1:lens)
    (name2:string) (value2:lens) : lens = 
  del ("<" . tag) . 
  Sort.sort_concat #{lens}[(attr name1 value1);(attr name2 value2)] . 
  slash_close 

(* [attrk_elt_no_kids sp t n1 v1 .. nk vk] processes a single-line XML element with
   no children (other than its attributes.)
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
*)
let attrs_elt_no_kids (spaces:string) (tag:string) 
    (attrs:lens) : lens = 
  raw_open spaces tag . 
  attrs . 
  slash_close

let attr1_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) : lens = 
  attrs_elt_no_kids spaces tag 
    (attr name1 value1)
    
let attr2_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (Sort.sort_concat #{lens}[(attr name1 value1);(attr name2 value2)])

let slow_attr2_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (Sort.perm_sort_concat
    #{lens}[(attr name1 value1);
	    (attr name2 value2)])

let attr3_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (Sort.sort_concat #{lens}[(attr name1 value1);
			    (attr name2 value2);
			    (attr name3 value3)])

let slow_attr3_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (Sort.perm_sort_concat
    #{lens}[(attr name1 value1);
	    (attr name2 value2);
	    (attr name3 value3)])

let attr4_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
    (name4:string) (value4:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (Sort.sort_concat #{lens}[(attr name1 value1);
			    (attr name2 value2);  
			    (attr name3 value3);
			    (attr name4 value4)])

let slow_attr4_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
    (name4:string) (value4:lens) : lens = 
  attrs_elt_no_kids spaces tag 
  (Sort.perm_sort_concat
    #{lens}[(attr name1 value1);
	    (attr name2 value2);
	    (attr name3 value3);
	    (attr name4 value4)])

(* [attrk_open sp t n1 v1 .. nk vk] opens a single-line XML element with k attributes.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
*)
let attrs_open (spaces:string) (tag:string) 
    (attrs:lens) : lens = 
  raw_open spaces tag . 
  attrs . 
  close  

let attr1_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) : lens = 
  attrs_open spaces tag 
    (attr name1 value1)

let attr2_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_open spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2)])

let slow_attr2_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_open spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
	       (attr name2 value2)])

let attr3_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_open spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2);
			      (attr name3 value3)])

let slow_attr3_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_open spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
               (attr name2 value2);
               (attr name3 value3)])
    
let slow_attr4_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) : lens = 
  attrs_open spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
               (attr name2 value2);
               (attr name3 value3);
               (attr name4 value4)])

let attr4_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) : lens = 
  attrs_open spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2);
			      (attr name3 value3);
			      (attr name4 value4)])

(* attrN_elt_swap2 *)
let attr2_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  (attr2_elt_open spaces tag 
     name1 value1 
     name2 value2 .
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2) ~ copy (atype body) ) )

let slow_attr2_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  (slow_attr2_elt_open spaces tag 
     name1 value1 
     name2 value2 .
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2) ~ copy (atype body) ) )

let attr3_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (body:lens) : lens = 
  (attr3_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3) ~ copy (atype body) ) )

let slow_attr3_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (body:lens) : lens = 
  (slow_attr3_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3) ~ copy (atype body) ) )

let attr4_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) 
    (body:lens) : lens = 
  (attr4_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3
     name4 value4 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3 . atype value4) ~ copy (atype body) ) )

let slow_attr4_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) 
    (body:lens) : lens = 
  (slow_attr4_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3
     name4 value4 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3 . atype value4) ~ copy (atype body) ) )

