module Xml = 

  let WS = [ \n]*
  let WSP = [ \n]+ 

(* --------------------------------------------------------------------------- *)
(* XML functions *)

(* [unesc_char ex] maps an XML symbol -- either a character or an
   escaped characeter -- to its equivalent representation in ASCII.
   o [ex] is the set of excluded characters, and must be a cset

  By default, newlines and quotes are excluded (they are dealt with
  elsewhere).
*)

let xml_escs = #{char * string}['>',"&gt;";
				'<',"&lt;";
				'&',"&amp;";
				'"',"&quot;"]

let unesc_char (excl:regexp where is_cset excl) : lens 
  = Escaping.unescape_char ([^\n] - excl) (Escaping.restrict excl xml_escs)

(* [unesc_string_ends ex ends_ex] maps an XML-escaped string
   beginning and ending with characters not in [ex] or [ends_ex], to
   its equivalent representation in ASCII.
   o [ex] the set of excluded characters.       
   o [ends_ex] the set of excluded characters at the end points.
*)
let unesc_string_ends
    (excl:regexp where is_cset excl)
    (ends_excl:regexp where is_cset ends_excl) 
  : lens 
  = let middle = unesc_char excl in
    let ends = unesc_char (excl | ends_excl) in
    ends . (middle* . ends)?

(* [unesc_string ex] maps an XML-escaped string starting and
   beginning with a non-space character, to its equivalent
   representation in ASCII.
   o [ex] the set of excluded characters.  
*)
let unesc_string (excl:regexp where is_cset excl) : lens =
  unesc_string_ends excl [ ]

let OPEN (tag:regexp) : regexp = "<" . tag . ">"
let OPEN_NOKIDS (tag:regexp) : regexp = "<" . tag . "/>"

(* [open sp t] recognizes and deletes a string consisting of
   whitespace and the start of an XML open tag.
   o [sp] is used to canonize the leading whitespace.
   o [t] is the tag.
*)
let raw_open (spaces:string) (tag:string) : (lens in (WS . "<" . tag) <=> "") = 
  qdel WS spaces . 
  del ("<" . tag) 

let simple_open_tag (tag:string) : (lens in OPEN tag <=> "") = 
  del (OPEN tag)

(* [close] recognizes and deletes the string ">" *)
let close : (lens in ">" <-> "") = 
  del ">"

(* [slash_close] recognizes and deletes strings consisting of
   whitespace followed by "/>", which is used to terminate XML
   elements whose children are all attributes.
*)
(* Why is this bijective?  It's bijective "up to" canonization... *)
let slash_close : (lens in (WS . "/>") <=> "") = 
  qdel (WS . /\/>/) "/>"

(* [open_tag sp t] recognizes and deletes a string consisting of
   whitespace followed by an XML open tag.
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let open_tag (spaces:string) (tag:string) 
  : (lens in (WS . OPEN tag) <=> "") 
  = raw_open spaces tag . 
    close

let CLOSE (tag:regexp) : regexp = "</" . tag . ">"

(* [simple_close_tag t] recognizes and deletes a string consisting
   of an XML close tag.
   o [t] element tag.   
*)
let simple_close_tag (tag:string) : (lens in CLOSE tag <=> "") = 
  del (CLOSE tag)

(* [close_tag sp t] recognizes and deletes a string consisting of
   whitespace followed by an XML close tag. 
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let close_tag (spaces:string) (tag:string) 
  : (lens in (WS . CLOSE tag) <=> "") 
  = qdel WS spaces . 
    simple_close_tag tag

(* [simple_elt sp t l] proecesses a single-line XML element.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [l] lens for processing the children.
*)
let simple_elt (spaces:string) (tag:string) (body:lens) 
  : (lens in (WS . OPEN tag . ctype body . CLOSE tag) <-> atype body)
  = open_tag spaces tag . 
    body . 
    simple_close_tag tag

(* [simple_elt_no_kids sp t] proecesses a single-line XML element 
   with no children.
   o [sp] canonical leading whitespace.
   o [t] element tag.
*)
let simple_elt_no_kids (spaces:string) (tag:string) 
  : (lens in (WS . OPEN tag . CLOSE tag) <-> "")
  = open_tag spaces tag . 
    simple_close_tag tag

(* [elt sp t l] processes a multi-line XML element.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [l] lens for processing children.
*)
let elt (spaces:string) (tag:string) (body:lens) 
  : (lens in (WS . OPEN tag . ctype body . WS . CLOSE tag) <-> atype body)
  = open_tag spaces tag . 
    body . 
    close_tag spaces tag

(* [top t l] processes a top-level multi-line XML element.
   o [t] element tag.
   o [l] lens for processing children.

  there is no spacing before the open tag, and there is a newline
  before the close tag
*)
let top (tag:string) (body:lens) 
  : (lens in (WS . OPEN tag . ctype body . WS . CLOSE tag) <-> atype body)
  = open_tag "" tag .
    body .
    close_tag NL0 tag

let raw_simple_elt (tag:string) (body:lens) 
  : (lens in (OPEN tag . ctype body . CLOSE tag) <-> atype body)
  = simple_open_tag tag . 
    body . 
    simple_close_tag tag 
  
(* this is a little to relaxed, as it calls "this' and 'this" well
   formed

   but ("'" . E . "'") | ('"' . E . '"') won't work as a lens (since
   the atypes are the same).  it won't work to use ||, either, since
   E's equivalence class may not be the identity relation
*)
let QUOTED (E:regexp) : regexp =
  [''""] . E . [''""]

let quoted (l:lens) : (lens in QUOTED (ctype l) <-> atype l)
  = del [''""] . l . del [''""]

let ATTR (name:string) (VALUE:regexp) : regexp 
    = WSP . name . "=" . QUOTED VALUE

(* [attr n l] proceses a string consiting of whitespace and a
   single XML attribute. Leading whitespace is canonized to a single
   space.
   o [n] attribute name.
   o [l] lens for processing value.

   N.B. we should allow single quotes, too
*)
let attr (name:string) (value:lens) 
  : (lens in ATTR name (ctype value) <-> atype value)
  = qdel WSP " " . 
    del name . 
    del "=" . 
    quoted value

(*
From W3C XML 1.1 Recommendation, 2nd Ed.
http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-prolog

prolog       ::= XMLDecl  Misc* (doctypedecl  Misc* )?

XMLDecl      ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
VersionInfo  ::= S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')
Eq           ::= S? '=' S?
VersionNum   ::= '1.1'
EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )
EncName      ::= [A-Za-z] ([A-Za-z0-9._] | '-')*

Misc         ::= Comment | PI | S 

Comment	     ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'

PI           ::= '<?' PITarget (S (Char* - (Char* '?>' Char* )))? '?>'
PITarget     ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))

S            ::= whitespace
*)

let VERSION : regexp = "1." . [01]

(* this is really EncName, and not name...but this is a conservative
   approximation *)
let NAME : regexp = [A-Za-z] . ([A-Za-z0-9._]|'-')*

let XMLDECL : regexp =
  "<?xml" . (ATTR "version" VERSION)
          . (ATTR "encoding" NAME)?
          . (ATTR "standalone" ("yes"|"no"))?
          . WS . "?>"

let COMMENT : regexp = "<!--" . (not_containing "--") . "-->"
let PI : regexp = "<?" . (NAME - ([Xx] . [Mm] . [Ll])) . WSP . 
	                 (not_containing "?>") . "?>"
let MISC = COMMENT | PI | [ \n\t]

let PUBIDCHAR : regexp  = [ \n\ta-zA-Z0-9'()+,./:=?;!*#@$_%] | '-'
let PUBID : regexp      = '"' . PUBIDCHAR* . '"' | /'/ . (PUBIDCHAR - /'/) . /'/
let SYSTEMID : regexp   = '"' . [^""]* . '"' | /'/ . [^'']* . /'/
let EXTERNALID : regexp = "SYSTEM" . WSP . SYSTEMID | "PUBLIC" . WSP . PUBID . WSP . SYSTEMID

(* FIXME unsupported!  you can put a subset of a DTD in your
   doctype...these can get long. *)
let INTERNAL : regexp = EPSILON

let DOCTYPE_full 
    (name : regexp where subset name NAME) 
    (id : regexp where subset id EXTERNALID)
    (internal : regexp)
    : regexp
    = "<!DOCTYPE" . WSP . name . (WSP . id)? . WS . (internal . WS)? . '>'

let DOCTYPE
    (name : regexp where subset name NAME) 
    (id : regexp where subset id EXTERNALID)
    : regexp
    = DOCTYPE_full name id INTERNAL

let ANYDOCTYPE : regexp =
  DOCTYPE NAME EXTERNALID

let prolog (DT : regexp where subset DT ANYDOCTYPE)
  : (lens in (XMLDECL . MISC* . (DT . MISC* )?) <-> "")
  = const (XMLDECL . MISC* . (DT . MISC* )?) "" "<?xml version=\"1.0\" ?>"

test (prolog ANYDOCTYPE).get "<?xml version=\"1.0\" ?>" = ""
test (prolog ANYDOCTYPE).create "" = "<?xml version=\"1.0\" ?>"
test (prolog ANYDOCTYPE).put "" into "<?xml version=\"1.0\" standalone=\"yes\" ?>"
     = "<?xml version=\"1.0\" standalone=\"yes\" ?>"

(* [attr1_elt sp t n v l] processes a multi-line XML element with
   one attribute.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [n] attribute name.
   o [v] lens for processing attribute value.
   o [l] lens for processing element children.
*)
let attr1_elt (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens where splittable_cex (atype value) (atype body)) 
  : (lens in (WS . OPEN (tag . ATTR name (ctype value)) . ctype body . WS . CLOSE tag)
	 <-> (atype value . atype body))
  = raw_open spaces tag . 
    attr name value . 
    close . 
    body . 
    close_tag spaces tag 

let attr1_elt_swap (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens where splittable_cex (atype body) (atype value)) 
  : (lens in (WS . OPEN (tag . ATTR name (ctype value)) . ctype body . WS . CLOSE tag)
	 <-> (atype body . atype value))
  = raw_open spaces tag . 
    ( (attr name value) ~
      ( close . body ) ) . 
    close_tag spaces tag 
    
(* [attr1_simple_elt sp t n v l] processes a single-line XML element with
   one attribute.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [n] attribute name.
   o [v] lens for processing attribute value.
   o [l] lens for processing element children.
*)
let attr1_simple_elt (spaces:string) (tag:string) 
    (name:string) (value:lens) 
    (body:lens where splittable_cex (atype value) (atype body))
  : (lens in (WS . OPEN (tag . ATTR name (ctype value)) . (ctype body) . CLOSE tag)
	 <-> (atype value . atype body))
  = raw_open spaces tag . 
    attr name value . 
    close . 
    body . 
    simple_close_tag tag 

let attr1_raw_simple_elt (tag:string)
    (name:string) (value:lens)
    (body:lens where splittable_cex (atype value) (atype body)) 
  : (lens in (OPEN (tag . ATTR name (ctype value)) . (ctype body) . CLOSE tag)
	 <-> (atype value . atype body))
  = del ("<" . tag) . 
    attr name value . 
    close . 
    body . 
    simple_close_tag tag 

let ATTRS (spec:(string*regexp) List.t) : regexp List.t = 
  List.map{string*regexp}{regexp} 
    (fun (p:string*regexp) ->
       let name,VALUE = p in
	 ATTR name VALUE)
    spec

let ALL_ATTRS (spec:(string*regexp) List.t) : regexp =
  union_regexps (Sort.perm_regexps (ATTRS spec))

let ANY_ATTRS (spec:(string*regexp) List.t) : regexp =
  (union_regexps (ATTRS spec))*  

(* [attr2_elt sp t n1 v1 n2 v2 l] processes a multi-line XML
   element with two attributes.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
   o [l] lens for processing element children.
*)
let attr2_elt (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens where splittable_cex (atype value1) (atype value2)) 
    (body:lens where splittable_cex (atype value1 . atype value2) (atype body)) 
  : (lens in (WS . OPEN (tag . ALL_ATTRS #{string*regexp}[name1,ctype value1;name2,ctype value2]) . 
	      ctype body . CLOSE tag)
         <-> (atype value1 . atype value2 . atype body))
  = raw_open spaces tag . 
    Sort.sort_concat #{lens}[attr name1 value1; attr name2 value2] . 
    close . 
    body . 
    close_tag spaces tag 

let slow_attr2_elt (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens where splittable_cex (atype value1) (atype value2)) 
    (body:lens where splittable_cex (atype value1 . atype value2) (atype body)) 
  : (lens in (WS . OPEN (tag . ALL_ATTRS #{string*regexp}[name1,ctype value1; name2,ctype value2]) . 
	      ctype body . WS . CLOSE tag)
         <-> (atype value1 . atype value2 . atype body))
  = raw_open spaces tag . 
    Sort.perm_sort_concat #{lens}[attr name1 value1; attr name2 value2] . 
    close . 
    body . 
    close_tag spaces tag 

let attr2_raw_simple_elt_no_kids (tag:string)
    (name1:string) (value1:lens)
    (name2:string) (value2:lens where splittable_cex (atype value1) (atype value2)) 
  : (lens in OPEN_NOKIDS (tag . ANY_ATTRS #{string*regexp}[name1,ctype value1; name2,ctype value2] . WS)
	 <-> (atype value1 . atype value2))
  = del ("<" . tag) . 
    Sort.sort_concat #{lens}[attr name1 value1; attr name2 value2] . 
    slash_close 

test (attr2_raw_simple_elt_no_kids "foo" "a1" "5" "a2" "6").get "<foo a1='5' a2='6' />" = "56"
test (attr2_raw_simple_elt_no_kids "foo" "a1" "5" "a2" "6").get "<foo a1='5'   />" = error

(* [attrk_elt_no_kids sp t n1 v1 .. nk vk] processes a single-line XML element with
   no children (other than its attributes.)
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
*)
let attrs_elt_no_kids (spaces:string) (tag:string) (attrs:lens) 
  : (lens in (WS . OPEN_NOKIDS (tag . ctype attrs . WS)) <-> atype attrs)
  = raw_open spaces tag . 
    attrs . 
    slash_close

let attr1_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
  : (lens in (WS . OPEN_NOKIDS (tag . ATTR name1 (ctype value1) . WS)) <-> atype value1)
  = attrs_elt_no_kids spaces tag (attr name1 value1)
    
let attr2_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
  : (lens in (WS . OPEN_NOKIDS (tag . ANY_ATTRS #{string*regexp}[name1,ctype value1; name2,ctype value2] . WS))
         <-> (atype value1 . atype value2))
  = attrs_elt_no_kids spaces tag 
      (Sort.sort_concat #{lens}[attr name1 value1; attr name2 value2])

test (attr2_elt_no_kids "" "foo" "a1" "5" "a2" "6").get "<foo a1='5' a2='6' />" = "56"
test (attr2_elt_no_kids "" "foo" "a1" "5" "a2" "6").get "<foo a1='5'   />" = error

let slow_attr2_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens)
  : (lens in (WS . OPEN_NOKIDS (tag . ALL_ATTRS #{string*regexp}[name1,ctype value1; name2,ctype value2] . WS))
         <-> (atype value1 . atype value2))
  = attrs_elt_no_kids spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
	       (attr name2 value2)])

let attr3_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
  : (lens in (WS . OPEN_NOKIDS (tag . 
                                ANY_ATTRS #{string*regexp}[name1,ctype value1;
							   name2,ctype value2;
							   name3,ctype value3] . 
                                WS))
         <-> (atype value1 . atype value2 . atype value3))
  = attrs_elt_no_kids spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2);
			      (attr name3 value3)])

let slow_attr3_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
  : (lens in (WS . OPEN_NOKIDS (tag . 
                                ALL_ATTRS #{string*regexp}[name1,ctype value1;
							   name2,ctype value2;
							   name3,ctype value3] . 
                                WS))
         <-> (atype value1 . atype value2 . atype value3))
  = attrs_elt_no_kids spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
	       (attr name2 value2);
	       (attr name3 value3)])

let attr4_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
    (name4:string) (value4:lens)
  : (lens in (WS . OPEN_NOKIDS (tag . 
                                ANY_ATTRS #{string*regexp}[name1,ctype value1;
							   name2,ctype value2;
							   name3,ctype value3;
							   name4,ctype value4] . 
                                WS))
         <-> (atype value1 . atype value2 . atype value3 . atype value4))
  = attrs_elt_no_kids spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2);  
			      (attr name3 value3);
			      (attr name4 value4)])

let slow_attr4_elt_no_kids (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens)
    (name4:string) (value4:lens)
  : (lens in (WS . OPEN_NOKIDS (tag . 
                                ALL_ATTRS #{string*regexp}[name1,ctype value1;
							   name2,ctype value2;
							   name3,ctype value3;
							   name4,ctype value4] . 
                                WS))
         <-> (atype value1 . atype value2 . atype value3 . atype value4))
  = attrs_elt_no_kids spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
	       (attr name2 value2);
	       (attr name3 value3);
	       (attr name4 value4)])

(* [attrk_open sp t n1 v1 .. nk vk] opens a single-line XML element with k attributes.
   o [sp] canonical leading whitespace.
   o [t] element tag.
   o [ni] ith attribute name.
   o [vi] lens for processing ith attribute value.
*)
let attrs_open (spaces:string) (tag:string) 
    (attrs:lens) : lens = 
  raw_open spaces tag . 
  attrs . 
  close  

let attr1_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) : lens = 
  attrs_open spaces tag 
    (attr name1 value1)

let attr2_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_open spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2)])

let slow_attr2_elt_open (spaces:string) (tag:string)
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) : lens = 
  attrs_open spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
	       (attr name2 value2)])

let attr3_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_open spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2);
			      (attr name3 value3)])

let slow_attr3_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) : lens = 
  attrs_open spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
               (attr name2 value2);
               (attr name3 value3)])
    
let slow_attr4_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) : lens = 
  attrs_open spaces tag 
    (Sort.perm_sort_concat
       #{lens}[(attr name1 value1);
               (attr name2 value2);
               (attr name3 value3);
               (attr name4 value4)])

let attr4_elt_open (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) : lens = 
  attrs_open spaces tag 
    (Sort.sort_concat #{lens}[(attr name1 value1);
			      (attr name2 value2);
			      (attr name3 value3);
			      (attr name4 value4)])

(* attrN_elt_swap2 *)
let attr2_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  (attr2_elt_open spaces tag 
     name1 value1 
     name2 value2 .
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2) ~ copy (atype body) ) )

let slow_attr2_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (body:lens) : lens = 
  (slow_attr2_elt_open spaces tag 
     name1 value1 
     name2 value2 .
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2) ~ copy (atype body) ) )

let attr3_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (body:lens) : lens = 
  (attr3_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3) ~ copy (atype body) ) )

let slow_attr3_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (body:lens) : lens = 
  (slow_attr3_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3) ~ copy (atype body) ) )

let attr4_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) 
    (body:lens) : lens = 
  (attr4_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3
     name4 value4 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3 . atype value4) ~ copy (atype body) ) )

let slow_attr4_elt_swap2 (spaces:string) (tag:string) 
    (name1:string) (value1:lens) 
    (name2:string) (value2:lens) 
    (name3:string) (value3:lens) 
    (name4:string) (value4:lens) 
    (body:lens) : lens = 
  (slow_attr4_elt_open spaces tag 
     name1 value1 
     name2 value2 
     name3 value3
     name4 value4 . 
   body . 
   close_tag spaces tag); 
  ( copy (atype value1) . 
    ( copy (atype value2 . atype value3 . atype value4) ~ copy (atype body) ) )

