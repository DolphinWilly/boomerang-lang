module Escaping = 

(* FIRST TRY:

let unrender_quotedstr =
    "\"" <-> "" 
  . copy ANY
  . "\"" <-> "" 

let unescape_quotedstr_char =
    "\\\"" <-> "\""
  || "\\\\" <-> "\\"
  || copy (ANYCHAR - [\\"])

let unescape_quotedstr = unescape_quotedstr_char*

test get unescape_quotedstr
    <<
        <hello\"world>
    >> 
  = 
    <<
        <hello"world>
    >> 

let tester = unrender_quotedstr ; unescape_quotedstr
(* DOESN'T WORK!! *)
*)

let unrender_quotedstr (R : regexp where (splittable_cex '"' R) && (splittable_cex R '"')) =
    ('"' <-> "") . 
    copy R . 
    ('"' <-> "")

let unescape_quotedstr_char =
     ("\\\"" <-> '"')
  || ("\\\\" <-> '\')
  || copy (ANYCHAR - '\')

let unescape_quotedstr 
  : (lens in (('\' . ('"' | '\')) | [^\\])* <-> ANY) 
  = unescape_quotedstr_char*

test get unescape_quotedstr
    <<
        <hello\"\"world>
    >>
  = 
    <<
        <hello""world>
    >> 

let test1 = unrender_quotedstr (ctype unescape_quotedstr) ; unescape_quotedstr

(* Does this transformation work in general? *)

(* Making the example harder: Make the ASCII into a CSV... *)

let escape_xml_char = 
     ('<' <-> "&lt;")
  || ('>' <-> "&gt;")
  || ('&' <-> "&amp;")
  || copy (ANYCHAR - [<>&])

let escape_xml 
  : (lens in ANY <-> (('&' . ("lt"|"gt"|"amp") . ';') | [^&<>])* )
  = escape_xml_char*

let render_tag (R : regexp where splittable_cex "<tag>" R &&
		                 splittable_cex R "</tag>") 
  : (lens in R <-> ("<tag>" . R . "</tag>"))
  = ("" <-> "<tag>") .
    copy R .
    ("" <-> "</tag>")

let test2 = escape_xml; render_tag (atype escape_xml) 

test get test2
    <<
        <hello""world>
    >> 
  = 
    <<
        <tag>&lt;hello""world&gt;</tag>
    >> 


    
let l = test1 ; test2

test get l
    <<
        " <hello\"\"world> "
    >> 
  = <<
        <tag> &lt;hello""world&gt; </tag>
    >>

(*************************************************)
(* That works.  So let's make it more generic... *)

(* regex -> str -> str -> lens
   no possibility of failure, can give complete return type
*)
let render (R : regexp)
           (before : string where splittable_cex before R) 
	   (after : string where splittable_cex after R)
  : (lens in R <-> (before . R . after))
  = ("" <-> before) .
    copy R .
    ("" <-> after)

let render_xml (R : regexp where splittable_cex "<tag>" R &&
                                 splittable_cex R "</tag>") 
  : (lens in R <-> ("<tag>" . R . "</tag>"))
  = render R "<tag>" "</tag>"

(* safe, since render is safe; can we pass the buck without 
   repeating the contract? 

   in essence, can we instrument render_tag but not install blame on its 
   arguments?
*)
let tagged (R : regexp) (tag : string) = 
  '<' . tag . '>' . R . ("</" . tag) . '>'

let render_tag (R : regexp) (tag : string) 
  : (lens in R <-> tagged R tag)
  = render R ("<" . tag . ">") ("</" . tag . ">")

test (render_tag ANY "foo").atype = ("<foo>" . ANY . "</foo>")

(* as above *)
let quoted (R : regexp) = ["] . R . ["]

let render_str (R : regexp) : (lens in R <-> quoted R) = render R "\"" "\""

(* is bijectivity guaranteed?  yes, but we need buck-passing *)
let unrender_str (R : regexp) : (lens in quoted R <-> R) = invert (render_str R)

(* this function already existed inside escape, but we had to 
   pull it out *)
let unescaped (pairs : (char * string) List.t) : regexp =
  List.fold_left{char * string}{regexp}
    (fun (r : regexp) (p : char * string) ->
       let from,to = p in
       from | r)
    []
    pairs

(* this function didn't exist before, but we need it to 
   talk about the atype of the lens produced by escape *)
let escaped (pairs : (char * string) List.t) : regexp =
  List.fold_left{char * string}{regexp}
    (fun (r : regexp) (p : char * string) ->
       let from,to = p in
       to | r)
    []
    pairs

(* it's an interesting exercise to start with "naive" ass-covering and lead up to
   this relatively concise and understandable contract

   1) escaped chars are arbitrary strings, contract is "hell on wheels"
   2) change to single characters
   3) observe that the iterability constraint on the domain is satisfied by construction
   4) rewrite the codomain, making it nice and concise
*)

let lens_iterable (l:lens) : bool = iterable_cex (ctype l) && iterable_cex (atype l)

(* given a set of chars to be escaped and escape codes, valid escaped "bits" are:
     (a) an escape code, or
     (b) a character that didn't need to be escaped
*)
let char_or_escaped (pairs : (char * string) List.t) : regexp =
  escaped pairs | (ANYCHAR - (unescaped pairs))

let mutually_distinct (strs : string List.t) : bool =
  let r,_ = 
    List.fold_left{string}{bool * (string List.t)}
      (fun (acc : bool * (string List.t)) (s : string) ->
	 let md_sofar,l_sofar = acc in
	   (md_sofar && not (List.member{string} s l_sofar),List.Cons{string} (s,l_sofar)))
      (true,List.Nil{string})
      strs in
  r

let no_repeated_escape_codes (pairs : (char * string) List.t) : bool =
  mutually_distinct (List.map{char * string}{string} snd{char}{string} pairs)

(*
  any string goes to a sequence of char_or_escaped bits
*)
let escape 
  (pairs : (char * string) List.t where
             no_repeated_escape_codes pairs &&
             lens_iterable (char_or_escaped pairs))
  : (lens in ANY <-> (char_or_escaped pairs)* )
  =
  let escape_char =
    List.fold_left{string * string}{lens}
      (fun (l : lens) (p : string * string) -> 
	 let from = fst{string}{string} p in
	 let to = snd{string}{string} p in
         (from <-> to) || l)
      (copy (ANYCHAR - (unescaped pairs)))
      pairs
  in
    escape_char*

let char_or_escaped2 (esc : char) (pairs : (char * string) List.t) =
  let esc_p (p : char * string) = 
    let from = fst{char}{string} p in
    let to = snd{char}{string} p in
    (from,esc . to)
  in
  let escs = List.map{char * string}{char * string} esc_p pairs in
  (escaped escs) | (ANYCHAR - (unescaped pairs))

(* How can this be equivalent to escape?  We seem to be missing some sort of 
   iterability requirement... --MMG *)
let escape2
  (esc : char)
  (pairs : (char * string) List.t where
             List.exists{string * string} 
	       (fun (p : string * string) -> (fst{string}{string} p) = esc)
	       pairs &&
             no_repeated_escape_codes pairs)
  : (lens in ANY <-> (char_or_escaped2 esc pairs)* )
  =
  let escape_char =
    List.fold_left{char * string}{lens}
      (fun (l : lens) (p : char * string) -> 
	 let from = fst{char}{string} p in
	 let to = snd{char}{string} p in
        (from <-> (esc . to)) || l)
      (copy (ANYCHAR - (unescaped pairs)))
      pairs
  in
    escape_char*

let xml_escs : (char * string) List.t =
  List.Cons{char * string}(('>',"gt;"),
  List.Cons{char * string}(('<',"lt;"),
  List.Cons{char * string}(('&',"amp;"), 
  List.Nil{char * string})))

(* again, do we want lens, or can/should we somehow 
   say "specialize this"?  
*)
let escape_xml 
  : (lens in ANY <-> (('&' . ("gt"|"lt"|"amp") . ';') | [^<>&])* )
  = escape2 '&' xml_escs

let str_escs : (char * string) List.t =
  List.Cons{char * string}(('"',"\""),
  List.Cons{char * string}(('\\',"\\"),
  List.Nil{char * string}))

(* per above *)
(* yeesh, this is way over-parenthesized... --MMG *)
let escape_str 
  : (lens in ANY <-> ((('\' . ('"'|'\')) | [^"\\])* ))
   = escape2 '\\' str_escs

(* ditto *)
let unescape_str 
  : (lens in ((('\' . ('"'|'\')) | [^"\\])* ) <-> ANY)
  = invert escape_str

let l2 = 
  unrender_str (ctype unescape_str) ; unescape_str ; 
  escape_xml ; render_xml (atype escape_xml)

test get l2
    <<
        " <hello\"\"world> "
    >> 
  = <<
        <tag> &lt;hello""world&gt; </tag>
    >>


let intersperse ('a) (ls : 'a List.t) (sep : 'a) : 'a List.t =
  List.reverse{'a}
      (List.fold_left{'a}{'a List.t}
        (fun (acc:'a List.t) (vi:'a) -> 
           List.Cons{'a}
             (match acc with 
               | List.Nil     -> (vi,acc)
               | List.Cons(_) -> (vi,List.Cons{'a}(sep,acc)) 
              : ('a * 'a List.t)))
        #{'a}[] ls)

let lens_concatable (ls : lens List.t) (sep : lens) : bool = 
  let ls' : lens List.t = intersperse{lens} ls sep in
  (concatable (ctypes ls')) && (concatable (atypes ls'))
 
(* to cover our asses, we need the concatable refinement
   do we want the specific return type?
*)
let intersperse_lenses 
      (lenses : lens List.t) 
      (sep : lens where lens_concatable lenses sep) 
  : (lens in (concat_regexps (ctypes (intersperse{lens} lenses sep)))
         <-> (concat_regexps (atypes (intersperse{lens} lenses sep))))
  = concat_lenses (intersperse{lens} lenses sep)

let field_to_xml (field : string) 
  : (lens in (quoted (('\' . ('"'|'\')) | [^"\\])* )
         <-> (tagged (('&' . ("lt"|"gt"|"amp") . ';') | [^&<>])* ) field)
  = unrender_str (ctype unescape_str) ; unescape_str ;
    escape_xml ; render_tag (atype escape_xml) field

(* as above -- do we want the strict return type?  do we want to pass the buck? *)
let csv_to_xml (fields : string List.t where lens_concatable fields (del ",")) = 
  intersperse_lenses (List.map{string}{lens} field_to_xml fields) (del ",")

let l3 = csv_to_xml (List.Cons{string}("first",List.Cons{string}("last",List.Nil{string})))

test get l3
    <<
        "Michael \"The Autominator\"","Greenberg, Jr. &c"
    >>
  = <<
        <first>Michael "The Autominator"</first><last>Greenberg, Jr. &amp;c</last>
    >>
