(* First useful use of copy ;-)
   When some information needs to be duplicated in an abstract tree
   (for instance a "display name" and the name of a contact in an address
   book entry), this information may already be duplicated and different
   in the concrete format. This lens does the following:
   - if the information is duplicated in the concrete tree, it is passed unchanged
   - if the information is not duplicated in the concrete tree, it is copied
   - on the way back, if:
     - exact copy in abstract and one entries in concrete -> one entries in concrete
     - exact copy in abstract and two entries in concrete -> two entries in concrete
     - different in abstract -> two entries in concrete
     - exact copy in abstract and concrete tree missing -> two entries in concrete
       FIX: we would like to have only one entry in the previous case, but this
            requires a "not" type for the cond
     - different in abstract and concrete tree missing -> two entries in concrete
     *)

module Copy =

let Equal : schema = {a={x},b={x}} | {a={y},b={y}} | {a={z},b={z}}

let C : schema = {a = ({x} | {y} | {z})}

let Full : schema = C + {b = ({x} | {y} | {z})}

let l : lens =
  cond_wf C Equal Full
    (copy "a" "b")   
    (copy "a" "b")
    id

test l / {a={x}} = {a={x},b={x}}
test l / {a={x},b={x}} = {a={x},b={x}}
test l / {a={x},b={y}} = {a={x},b={y}}

test l \ {a={x},b={x}} {a={y},b={y}} = {a={x},b={x}}
test l \ {a={x},b={x}} {a={y}} = {a={x}}
test l \ {a={x},b={y}} {a={y}} = {a={x},b={y}}
test l \ {a={x},b={x}} missing = {a={x},b={x}}
test l \ {a={x},b={y}} missing = {a={x},b={y}}
