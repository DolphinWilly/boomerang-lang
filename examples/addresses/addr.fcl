(* Things to think about:
     - how to write an abstract schema where all the bits are optional
       without hurting performance too much
     - how to massage the name as discussed
         concrete format (xcard)
           either just <n>last</n>
           or else <n><given>first</given><family>last</family></n>
              (with both components optional but at least one needed)
         abstract format: last;first
*)

module Addr =

(*******************************************************************)
(* List hackery (perhaps it belongs in list.src?) *)                          

let add_to_list (n:name) (l:name) : lens =
  xfork { `n, `l } { `l }
    (rename n List.HD;
     rename l List.TL;
     plunge l)
    id

let add_to_list_if_present (n:name) (l:name) : lens =
  acond {`n={""}, `l=[], *\`n,`l=Any}  {`l=[], *\`n,`l=Any}
    (prune n {""})
    (add_to_list n l)

test add_to_list_if_present "n" "l" / {n={5}, l=[]} = {l=[{5}]}
test add_to_list_if_present "n" "l" / {n={""}, l=[]} = {l=[]}
test add_to_list_if_present "n" "l" / {n={6}, l=[{5}]} = {l=[{6},{5}]}
test add_to_list_if_present "n" "l" / {n={""}, l=[{5}]} = {l=[{""},{5}]}

test add_to_list_if_present "n" "l" \ {l=[]} missing = {n={""}, l=[]}
test add_to_list_if_present "n" "l" \ {l=[{5}]} missing = {n={5}, l=[]}
test add_to_list_if_present "n" "l" \ {l=[{5},{4}]} missing = {n={5}, l=[{4}]}

test add_to_list_if_present "n" "l" \ {l=[]} {n={""},l=[]} = {n={""}, l=[]}
test add_to_list_if_present "n" "l" \ {l=[{5}]} {n={""},l=[]} = {n={5}, l=[]}
test add_to_list_if_present "n" "l" \ {l=[{5},{4}]} {n={""},l=[]} = {n={5}, l=[{4}]}

test add_to_list_if_present "n" "l" \ {l=[]} {n={5},l=[]} = {n={""}, l=[]}
test add_to_list_if_present "n" "l" \ {l=[{6}]} {n={5},l=[]} = {n={6}, l=[]}
test add_to_list_if_present "n" "l" \ {l=[{6}]} {n={""},l=[{5}]} = {n={6}, l=[]}


(*******************************************************************)
(* Abstract schema *)                          

let Addr : schema =
  {
    Company = Value,
    Title = Value,
    Phone = { Home=List.T Value,
              Work=List.T Value,
              Email=List.T Value,
              Fax=List.T Value,
              Mobile=List.T Value,
              Other=List.T Value},
    Address = Value,
    City = Value,
    Note = Value,
    State = Value,
    Zip = Value,
    Country = Value,
    Category = Value
  }

let AddrBook : schema = {* = {* = List.T Addr}}
  (* {last={first=[addr1, addr2, ...]}} *)


(*******************************************************************)
(* XCard format *)                          

let Element (x:name) (attrs:schema) (content:schema) : schema =
  { `x = ({`Xml.CHILDREN = content} + attrs) }

(* Interesting lens programming note...  We would *like* to write this:

      let FnLn : schema =
          [Element "family" {} [Xml.Pcdata], Element "given" {} [Xml.Pcdata]]
      let LnFn : schema =
          [Element "given" {} [Xml.Pcdata], Element "family" {} [Xml.Pcdata]]
      let Ln : schema =
          [Element "family" {} [Xml.Pcdata]]
      let Fn : schema =
          [Element "given" {} [Xml.Pcdata]]

      let Name : schema =
        Element "n" {} ([Xml.Pcdata] | FnLn | LnFn | Ln | Fn)

   ... but we can't because Name is not projectable.  Instead, we write a more
   permissive schema and convince ourselves informally that, when inputs are presented
   in the format above, our lenses behave as we expect.


  JNF: you can write this now, I believe...  14 Juin 2006
*)

let NameComponent : schema =
      Element "family" {} [Xml.Pcdata]
    | Element "given" {} [Xml.Pcdata]
    | Xml.Pcdata

let Name : schema =
  Element "n" {} ([] | (NameComponent :: ([] | [NameComponent])))

let Field : schema =
    Element "note" {} ([Xml.Pcdata] | [])
  | Element "tel-cell" {} ([Xml.Pcdata] | [])
  | Element "tel-work" {} ([Xml.Pcdata] | [])
  | Element "tel-home" {} ([Xml.Pcdata] | [])
  | Element "email" {} ([Xml.Pcdata] | [])
  | Element "category" {} ([Xml.Pcdata] | [])

let VCard : schema =
  Element "vcard" {} (Name :: (List.T Field))

let XCard : schema =
  [Element "xcard" {} (List.T VCard)]

let massage_name : lens =
   hoist Xml.PCDATA

(* NOTES TOWARD A FANCIER VERSION...
let massage_name : lens =
  acond { `Xml.PCDATA = Any } NoCommas
    (hoist Xml.PCDATA; explode)
    (hoist "family"; hoist Xml.PCDATA; explode)
*)

let handle_unique_field (f:name) (defval:name) : lens =
  fork {`f}
    (Xml.squash_flattened;
     map Xml.hoist_pcdata;
     acond {`f={!\`defval={}}} {`f={!\`defval={}}}
       id
       (* WAS: (ccond {} (add f {""}) id)) *)
       (add f {`defval}))
    id

test handle_unique_field "a" "" / \ {} = {a={""}}
test handle_unique_field "a" "" / \ {a=[{`Xml.PCDATA = [{hello}]}]} = {a={hello}}
test handle_unique_field "a" "" \ {a={hello}} {} = {a=[{`Xml.PCDATA = [{hello}]}]}
test handle_unique_field "a" "" \ {a={""}} {a=[{`Xml.PCDATA = [{hello}]}]} = {}

let handle_nonunique_field (f:name) (present:lens) : lens =
  fork {`f}
    (acond {} {`f=[]}
       (add f [])
        present)
    id

test handle_nonunique_field "a" id / \ {} = {a = []}
test handle_nonunique_field "a" id / \ {a= [{hello}]} = {a=[{hello}]}
test handle_nonunique_field "a" id \ {a=[{hello}]} {} = {a=[{hello}]}
test handle_nonunique_field "a" id \ {a=[]} {a=[{hello}]} = {}

let FAMILY : name = "&family"

let use_name_as_key : lens =
  assert VCard;
  hoist "vcard";
  hoist Xml.CHILDREN;
  mapp {`List.HD}
    (Xml.flatten_elt;
     hoist "n";
     ccond {`Xml.PCDATA = (List.T NonNullValue)}
       (plunge List.HD; add List.TL []; plunge "family")
       id;
     rename_if_present "family" FAMILY;
     handle_unique_field FAMILY "";
     handle_unique_field "given" "");
  hoist_nonunique List.HD {`FAMILY,given};
  fork {`FAMILY}
    id
    (pivot "given");
  pivot FAMILY;
  map (map (hoist List.TL));
  assert {! = {! = List.T Field}}

(*
let add_if_missing (n:name) (nullval:view) : lens =
  acond {*\`n=Any} {*\`n=Any, `n=nullval}
    (add n nullval)
    id
*)

let handle_fields : lens =
  let unique (nc:name) (na:name) : lens =
    handle_unique_field nc ""; rename nc na in
  let nonunique (nc:name) (na:name) : lens =
    handle_nonunique_field nc (map (List.flatten; hoist Xml.PCDATA; List.map (List.hd []))); rename nc na in
  unique "company" "Company";
  unique "title" "Title";
  unique "address" "Address";
  unique "city" "City";
  unique "state" "State";
  unique "zip" "Zip";
  unique "country" "Country";
  unique "note" "Note";
  handle_unique_field "category" "Unfiled"; rename "category" "Category";
  nonunique "tel-home" "Home";
  nonunique "tel-work" "Work";
  nonunique "email" "Email";
  nonunique "fax" "Fax";
  nonunique "tel-cell" "Mobile";
  nonunique "other" "Other";
  xfork {Home,Work,Email,Fax,Mobile,Other} {Phone}
    (plunge "Phone")
    id

let xcard : lens =
  assert XCard;   (* I was worried this would be slow
                     because the structure may be large, but actually it takes
                     about .1 second for a 1250-record file!  Ditto the one below. *)
  List.hd [];
  hoist "xcard";
  hoist Xml.CHILDREN;
  List.flatten_op use_name_as_key;
  map (List.flatten; map (List.map (Xml.flatten; handle_fields)));
  assert AddrBook

(* Note that unit tests involving creation will fail unless the fields
   within each xcard are given in sorted order... *)

(* Test empty name *)
test xcard / \
   (load "xml" 
     "<xcard>
     | <vcard>
     |   <n></n>
     |   <note>hello world</note>
     | </vcard>
     |</xcard>
     |")
  =
    {"" =
      {"" =
        [{Address = {""},
          Category = {Unfiled},
          City = {""},
          Company = {""},
          Country = {""},
          Note = {"hello world"},
          Phone =
           {Email = [], Fax = [], Home = [], Mobile = [], Other = [], Work = []},
          State = {""},
          Title = {""},
          Zip = {""}}]}}

test xcard \
   {Doe =
     {John =
       [{Address = {""},
         Category = {Unfiled},
         City = {""},
         Company = {""},
         Country = {""},
         Note = {"hello world"},
         Phone =
          {Email = [], Fax = [], Home = [{792-8134}, {732-4684}], Mobile = [], Other = [], Work = []},
         State = {""},
         Title = {""},
         Zip = {""}}]},
    "" =
      {"" =
        [{Address = {""},
          Category = {Unfiled},
          City = {""},
          Company = {""},
          Country = {""},
          Note = {"empty"},
          Phone =
           {Email = [], Fax = [], Home = [], Mobile = [], Other = [], Work = []},
          State = {""},
          Title = {""},
          Zip = {""}}]}}
   (load "xml" 
     "<xcard>
     | <vcard>
     |   <n>Charles Addams</n>
     |   <note>goodbye world</note>
     | </vcard>
     | <vcard>
     |   <n><family>Doe</family><given>John</given></n>
     |   <note>hello world</note>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     | </vcard>
     |</xcard>
     |")
  =
   (load "xml" 
     "<xcard>
     | <vcard>
     |   <n><family>Doe</family><given>John</given></n>
     |   <note>hello world</note>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     | </vcard>
     | <vcard>
     |   <n></n>
     |   <note>empty</note>
     | </vcard>
     |</xcard>
     |")

test xcard / \
   (load "xml" 
     "<xcard>
     | <vcard>
     |   <n><family>Doe</family><given>John</given></n>
     |   <note>hello world</note>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     | </vcard>
     |</xcard>
     |")
  =
    {Doe =
      {John =
        [{Address = {""},
          Category = {Unfiled},
          City = {""},
          Company = {""},
          Country = {""},
          Note = {"hello world"},
          Phone =
           {Email = [], Fax = [], Home = [{792-8134}, {732-4684}], Mobile = [], Other = [], Work = []},
          State = {""},
          Title = {""},
          Zip = {""}}]}}

(************************************************************************)
(* CSV format *)

let alpha_labels : lens =
  rename_if_present "01" "Last name";
  rename_if_present "02" "First name";
  rename_if_present "03" "Title";
  rename_if_present "04" "Company";
  rename_if_present "05" "Phone1";
  rename_if_present "06" "Phone2";
  rename_if_present "07" "Phone3";
  rename_if_present "08" "Phone4";
  rename_if_present "09" "Phone5";
  rename_if_present "10" "Address";
  rename_if_present "11" "City";
  rename_if_present "12" "State";
  rename_if_present "13" "Zip Code";
  rename_if_present "14" "Country";
  rename_if_present "15" "Custom 1";
  rename_if_present "16" "Custom 2";
  rename_if_present "17" "Custom 3";
  rename_if_present "18" "Custom 4";
  rename_if_present "19" "Note";
  rename_if_present "20" "Private";
  rename_if_present "21" "Category"

let prune_if_null (n:name) (nullval:view) : lens =
  acond {`n=nullval, *\`n=Any}  {*\`n=Any}  
    (prune n nullval)
    id

let prune_null_entries : lens = 
id
  (* Handled elsewhere: prune_if_null "Private" {0} *)
  (* We remove all Custom fields for the moment, so this is not needed
  prune_if_null "Custom 1" {""};
  prune_if_null "Custom 2" {""};
  prune_if_null "Custom 3" {""};
  prune_if_null "Custom 4" {""}
  *)
(* We'd like to get rid of all these, but it will make the abstract schema
   run real slow at the moment...!
  prune_if_null "Phone" []; 
  prune_if_null "Address" {""};
  prune_if_null "City" {""};
  prune_if_null "Company" {""};
  prune_if_null "Note" {""};
  prune_if_null "State" {""};
  prune_if_null "Title" {""};
  prune_if_null "Zip" {""};
  prune_if_null "Country" {""};
  prune_if_null "Category" {Unfiled};  
*)

let format_phone : lens =
  acond {""} {Garbage}
    (const {Garbage} {""})
    (List.split ";";
     pivot List.HD;
     map (hoist List.TL; List.hd []))

let extract_csv_name : lens =
  alpha_labels;
  pivot "Last name";
  map (pivot "First name")

let format_csv_addr : lens =
  add "Phone" [];
  add_to_list_if_present "Phone5" "Phone";
  add_to_list_if_present "Phone4" "Phone";
  add_to_list_if_present "Phone3" "Phone";
  add_to_list_if_present "Phone2" "Phone";
  add_to_list_if_present "Phone1" "Phone";
  mapn "Phone" (List.map format_phone; List.flatten;
                fork {Garbage} (const {} {}) id;
                rename_if_present "E-mail" "Email";
                handle_nonunique_field "Email" id;
                handle_nonunique_field "Fax" id;
                handle_nonunique_field "Home" id;
                handle_nonunique_field "Mobile" id;
                handle_nonunique_field "Other" id;
                handle_nonunique_field "Work" id);
  rename_if_present "Zip Code" "Zip";
  prune "Custom 1" {""};
  prune "Custom 2" {""};
  prune "Custom 3" {""};
  prune "Custom 4" {""};
  prune "Private"  {0};
  prune_null_entries

let csv : lens =
  List.map extract_csv_name;
  (* never do anything that removes information before the aligning flatten*)
  List.flatten;  (* Flatten last names *)
  map List.flatten;  (* Flatten first names *)
  map (map (List.map format_csv_addr));
  assert AddrBook
