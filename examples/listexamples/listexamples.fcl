(* Unit tests for diff3 sync algorithm *)

module Listexamples =

let noconflict (t:tree) : tree =
  {O = t, A = t, B = t}

(* ------------------------------------------------------------------- *)
(* Some counter-intuitive test cases *)

(* Overlapping deletions (this result is a bit non-intuitive and doesn't match
   the regular sync algorithm's behavior on overlapping deletions --
   should be fixed!) *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {acde},
     B = {ade} }
  = {A = {acde},
     B = {ade},
     O = {abcde}}

(* Conflicting additions (because different lengths) *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {Xabcde},
     B = {XXabcde} }
  = {A = {Xabcde},
     B = {XXabcde},
     O = {abcde}}

(* ------------------------------------------------------------------- *)
(* Some intuitive ones *)

(* No changes *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {abcde},
     B = {abcde} }
  = noconflict {abcde}

(* Non-overlapping additions *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {abcXXXXXde},
     B = {abYYYYYcde} }
  = {A = {abYYYYYcXXXXXde}, B = {abYYYYYcXXXXXde}, O = {abYYYYYcXXXXXde}}

(* Non-conflicting additions *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {XXabcde},
     B = {XXabcde} }
  = noconflict {XXabcde}

(* An addition and a deletion *)
sync with List.explode at (List.T Value)
   { O = {abcdefg},
     A = {abxxcdefg},
     B = {abcfg} }
  = noconflict {abxxcfg}

(* Combination of changes and conflicts *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {XbHELLOcdE},
     B = {YbcdE} }
  = {A = {XbHELLOcdE},
     B = {YbHELLOcdE},
     O = {abHELLOcdE}}
      
(* More like that *)
sync with List.explode at (List.T Value)
   { O = {abcde},
     A = {DbCde},
     B = {EbcdE}}
  = {O = {abCdE},
     A = {DbCdE},
     B = {EbCdE}}

