module Safari =

(* --------------- schemas -------------- *)
schema URIDict = { "BLANK" = Value, 
                         "title" = Value, 
                         *\("BLANK","title") = Any }

schema Link = { "URIDictionary" = URIDict, 
                      "URLString" = Value, 
                      * \ ("URIDictionary","URLString") = Any }
    
schema Folder = { "Children" = (List.T Item), 
                        "Title" = Value, 
                        * \ ("Children","Title") = Any }
                    | { "Title" = Value, 
                        * \ ("Children","Title") = Any }

and Item = { "folder" = Folder } 
                  | { "link" = Link } 
                  | { "proxy" = Any }
      
schema SafAbstract = List.T Item

(* --------------- lenses --------------- *)    
(* recursively applies item to all children, and    *)
(* puts the data under a link, folder, or proxy key *)
let children : lens =   
  List.map (protect item; 
            pivot "WebBookmarkType";
            rename_if_present "WebBookmarkTypeLeaf" "link";
            rename_if_present "WebBookmarkTypeList" "folder";
            rename_if_present "WebBookmarkTypeProxy" "proxy")
    
and item : lens = 
  hoist "dict";
  
  (* if the item is a dict and does not have children, we add an empty list of children *)
  acond 
    { * \ ("Children" ,"URIDictionary","BLANK") = Any}
    { "Children" = { "array" = [] }, * \ ("Children") = Any} 
    (add "Children" {"array"=[]}) 
    id;

  (* hoist values and recursively applies children or item if needed *)
  mapn "Children" (protect children);
  mapn "URIDictionary" (protect item);
  mapp {"URLString", "WebBookmarkType",
        "title", "Title", "BLANK" } (hoist "string")
    
(* l is for homogeneous synchronization of safari bookmarks *)
let l : lens =
  (** We lack an assert SafConcrete here :( *)
  Plist.l;
  hoist "dict";
  (* discard all the other meta info *)
  focus "Children" 
    {WebBookmarkFileVersion = {integer = {`Xml.CHILDREN = [{`Xml.PCDATA = {1}}]}},
     WebBookmarkType = {string = {WebBookmarkTypeList}},
     WebBookmarkUUID = {string = {00000000-0000-0000-0000-000000000000}}};
  children;
  assert SafAbstract

(* tidy removes from the tree the safari-specific contents  *)
(* and returns a tree following the Bookmarks.Abstract schema *)
let tidy : lens =  
  let tidy_folder : lens = 
    rename "Children" "contents"; 
    mapn "contents" (protect tidy);
    rename "Title" "name"; 
    filter {"name", "contents"} {} in  
  let tidy_link : lens =
    rename "URLString" "url";
    mapn "URIDictionary" (rename "title" "name"; filter {"BLANK", "name"} {});
    hoist_nonunique "URIDictionary" {"name", "BLANK"};
    merge "url" "BLANK";
    filter {"name", "url"} {} in
  
  let skip_proxies : lens =
    ccond ({"proxy"=Any}::Any) 
      (mapn List.TL (protect skip_proxies); List.tl {"proxy"={}})
      (mapn List.TL (protect skip_proxies))
  in
    skip_proxies;
    List.map (mapn "folder" tidy_folder;
              mapn "link" tidy_link;
              acond { "link" = Any } { "link" = Any }
                id
                (hoist "folder"))
    
(* l2 is for heterogeneous synchronization of safari bookmarks *)    
let l2 : lens = l; tidy; 
  xfork { `List.HD } { "toolbar" }
    (hoist List.HD; 
     focus "contents" { "name" = { "BookmarksBar" } };
     plunge "toolbar")
    (hoist List.TL;
     List.hd [];
     focus "contents" { "name" = { "BookmarksMenu" }};
     plunge "bookmarks")

(* l3 uses the unordered schema Bookmarks.BushAbstract *)
let l3 : lens = l2; Bookmarks.flatten_bookmarks


