module Plist =

(* nesting *)
let indent (spaces:string in Xml.WS) : (string in Xml.WS) = spaces . "  "

let kill_ws : (lens in Xml.WS <-> "") = qdel Xml.WS ""
let pvalue (spaces:string in Xml.WS) (tag:string) (l:lens where lens_splittable l kill_ws)
  : (lens in Xml.ELT tag (ctype l) <-> atype l)
  = Xml.simple_elt spaces tag (l . kill_ws)

(* DTD taken from http://www.apple.com/DTDs/PropertyList-1.0.dtd *)

(* Primitive types

   <!ELEMENT string (#PCDATA)>
   <!ELEMENT data (#PCDATA)> <!-- Contents interpreted as Base-64 encoded -->
 
   <!ELEMENT date (#PCDATA)> 
   <!-- Contents should conform to a subset of ISO 8601 (in particular,
   YYYY '-' MM '-' DD 'T' HH ':' MM ':' SS 'Z'.  Smaller units may be
   omitted with a loss of precision) -->
*)

let pstring (spaces:string in Xml.WS) (l:lens)
    : (lens in Xml.ELT "string" (ctype l) <-> atype l)
    = pvalue spaces "string" l

let BASE64 : regexp = [A-Za-z0-9+/]

let pdata (spaces:string in Xml.WS) (l:lens where subset (ctype l) BASE64)
    : (lens in Xml.ELT "string" (ctype l) <-> atype l)
    = Xml.elt spaces "data" l

(* TODO ISO 8601 calls 19 valid way to refer to the 20th century, etc. *)
let PLUSMINUS : regexp = '+' | '-'
let NUM2 : regexp = DIGIT{2}
let ISO8601_DATE : regexp = PLUSMINUS? . DIGIT? . NUM2{2}."-".NUM2."-".NUM2."T".NUM2.":".NUM2.":".NUM2."Z"

let pdate (spaces:string in Xml.WS) (l:lens where subset (ctype l) ISO8601_DATE)
  : (lens in Xml.ELT "date" (ctype l) <-> atype l)
  = pvalue spaces "date" l

(* Numerical primitives

   <!ELEMENT true EMPTY>  <!-- Boolean constant true -->
   <!ELEMENT false EMPTY> <!-- Boolean constant false -->
   <!ELEMENT real (#PCDATA)> 
   <!-- Contents should represent a floating point number matching ("+" | "-")? 
   d+ ("."d* )? ("E" ("+" | "-") d+)? where d is a digit 0-9.  -->
   <!ELEMENT integer (#PCDATA)> 
   <!-- Contents should represent a (possibly signed) integer number in base 10 -->
*)

let ptrue (spaces:string in Xml.WS)
  : (lens in (Xml.WS . Xml.EMPTYELT "true") <-> "")
  = Xml.simple_elt_no_kids spaces "true"

let pfalse (spaces:string in Xml.WS)
  : (lens in (Xml.WS . Xml.EMPTYELT "false") <-> "")
  = Xml.simple_elt_no_kids spaces "false"

(* is there another way to do this, e.g., using ptrue and pfalse?

   it seems like we keep having to lift conditionals all the way to the top...
*)
let pbool (spaces:string in Xml.WS) (strue:string) (sfalse:string where not (strue = sfalse))
  : (lens in (Xml.WS . (Xml.EMPTYELT "true" | Xml.EMPTYELT "false")) <-> (strue | sfalse))
  = qdel Xml.WS spaces . (Xml.EMPTYELT "true" <-> strue || Xml.EMPTYELT "false" <-> sfalse)

test (pbool "" "yes" "no").get "<true/>" = "yes"
test (pbool "" "yes" "no").put "no" into "<true/>" = "<false/>"

let REAL : regexp = PLUSMINUS? . DIGIT+ . ( '.' . DIGIT* )? . ("E" . PLUSMINUS . DIGIT+)?
let preal (spaces:string in Xml.WS) (l:lens where subset (ctype l) REAL)
  : (lens in Xml.ELT "real" (ctype l) <-> atype l)
  = pvalue spaces "real" l

test (preal "  " REAL).get "<real>+3.01E-10</real>" = "+3.01E-10"
test (preal "  " REAL).create "-1" = "  <real>-1</real>"

let INTEGER : regexp = PLUSMINUS? . DIGIT+
let pinteger (spaces:string in Xml.WS) (l:lens where subset (ctype l) INTEGER)
  : (lens in Xml.ELT "integer" (ctype l) <-> atype l)
  = pvalue spaces "integer" l

test (pinteger "  " INTEGER).get "<integer>120</integer>" = "120"
test (pinteger "  " INTEGER).put "5" into "<integer>0 </integer>" = "  <integer>5</integer>"
test (pinteger "  " INTEGER).create "120" = "  <integer>120</integer>"

(* Collections

   <!ELEMENT array (%plistObject;)*>
   <!ELEMENT dict (key, %plistObject;)*>
   <!ELEMENT key (#PCDATA)>

   "When encoding the contents of a CFDictionary object, each member is
   encoded by placing the dictionary key in a <key> tag and immediately
   following it with the corresponding value"

   http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFPropertyLists/Articles/XMLTags.html
*)

let EMPTY_ARRAY : regexp = Xml.WS . Xml.EMPTYELT "array"

let empty_array (spaces:string in Xml.WS)
    : (lens in EMPTY_ARRAY <-> "")
    = Xml.simple_elt_no_kids spaces "array"

let NONEMPTY_ARRAY (R:regexp) : regexp = Xml.ELT "array" R+

let nonempty_array (spaces:string in Xml.WS) (l:lens where lens_iterable l)
  : (lens in NONEMPTY_ARRAY (ctype l) <-> (atype l)+ )
  = Xml.elt spaces "array" <l>+

let ARRAY (R:regexp) : regexp = EMPTY_ARRAY | NONEMPTY_ARRAY R

let parray (spaces:string in Xml.WS) (l:lens where lens_iterable l)
    : (lens in ARRAY (ctype l) <-> (atype l)* )
    = empty_array spaces | nonempty_array spaces l

let larray = parray "" (pinteger "" (copy INTEGER . ins ";"))
test larray.get "<array>\n <integer>1</integer></array>" = "1;"
test larray.create "" = "<array/>"
test larray.put "5;4;3;" into "<array/>" =
  "<array><integer>5</integer><integer>4</integer><integer>3</integer></array>"

let EMPTY_DICT = Xml.WS . Xml.EMPTYELT "dict"

let empty_dict (spaces:string in Xml.WS)
    : (lens in EMPTY_DICT <-> "")
    = Xml.simple_elt_no_kids spaces "dict"

(* first, homogenous dictionaries *)
let KEY (K:regexp) : regexp = Xml.ELT "key" K

let pkey (spaces:string in Xml.WS) (K:regexp)
  : (lens in KEY K <-> K)
  = pvalue spaces "key" (key K)

let KVELT (K:regexp) (V:regexp) : regexp =
  KEY K . V

let KV (K:regexp) (V:regexp) : regexp =
  K . V

let VALID_KV (spaces:string in Xml.WS) (K:regexp) (v:lens) : bool =
  lens_splittable (pkey spaces K) v &&
  lens_iterable (pkey spaces K . v)

let kvpair (spaces:string in Xml.WS) (K:regexp) (v:lens where lens_splittable (KEY K) v)
  : (lens in KVELT K (ctype v) <-> KV K (atype v))
  = pkey spaces K . v

let NONEMPTY_HDICT (K:regexp) (V:regexp) : regexp =
  Xml.ELT "dict" (KVELT K V)+

let nonempty_hdict (spaces:string in Xml.WS) (KEYS:regexp) 
    (v:lens where VALID_KV (indent spaces) KEYS v)
  : (lens in NONEMPTY_HDICT KEYS (ctype v) <-> (KV KEYS (atype v))+)
  = let kv = kvpair (indent spaces) KEYS v in
    Xml.elt spaces "dict" <kv>+

let HDICT (K:regexp) (V:regexp) : regexp = EMPTY_DICT | NONEMPTY_HDICT K V

let phdict (spaces:string in Xml.WS) (KEYS:regexp) 
    (v:lens where VALID_KV (indent spaces) KEYS v)
  : (lens in HDICT KEYS (ctype v) <-> (KV KEYS (atype v))* )
  = empty_dict spaces | nonempty_hdict spaces KEYS v

(* precomputed indentation *)
let field (l:lens) = ins "=" . l . ins ";"
let lhdict = 
  phdict "\n" ("foo"|"bar"|"baz") (pinteger (indent "\n") (field INTEGER))
test lhdict.get "<dict>\n<key>foo</key><integer>5</integer>\n</dict>" = "foo=5;"
test lhdict.get "<dict/>" = ""
test lhdict.put "bar=5;foo=4;" into "<dict/>" =
  <<
    
    <dict>
      <key>bar</key>
      <integer>5</integer>
      <key>foo</key>
      <integer>4</integer>
    </dict>
  >>

(* automatically managed indentation -- would be much less ugly with anaphora 

   also, this would be more elegant if spaces were always the _last_
   argument.  then we could pass around partially applied elements, etc.
*)
let nonempty_hsdict (spaces:string in Xml.WS) (KEYS:regexp)
    (mk_v:(spaces2:(string in Xml.WS) -> (v:lens where VALID_KV spaces2 KEYS v)))
  : (lens in NONEMPTY_HDICT KEYS (ctype (mk_v (indent spaces))) <-> (KV KEYS (atype (mk_v (indent spaces))))+)
  = let inner_spaces = indent spaces in
    let kv = kvpair inner_spaces KEYS (mk_v inner_spaces) in
    Xml.elt spaces "dict" <kv>+

let phsdict (spaces:string in Xml.WS) (KEYS:regexp)
    (mk_v:(spaces2:(string in Xml.WS) -> 
	  (v:lens where VALID_KV spaces2 KEYS v)))
  : (lens in HDICT KEYS (ctype (mk_v (indent spaces))) <-> (KV KEYS (atype (mk_v (indent spaces))))* )
  = empty_dict spaces | nonempty_hsdict spaces KEYS mk_v

let lhsdict = 
  phsdict "\n" ("foo"|"bar"|"baz") 
    (fun (spaces:string in Xml.WS) -> pinteger spaces (field INTEGER))
test lhsdict.get "<dict>\n<key>foo</key><integer>5</integer>\n</dict>" = "foo=5;"
test lhsdict.get "<dict/>" = ""
test lhsdict.put "bar=5;foo=4;" into "<dict/>" =
  <<
    
    <dict>
      <key>bar</key>
      <integer>5</integer>
      <key>foo</key>
      <integer>4</integer>
    </dict>
  >>

let KVELTS (spec:(regexp*lens) List.t) : regexp List.t = 
  List.map{regexp*lens}{regexp}
    (fun (p:regexp*lens) ->
       let k,v = p in
       KVELT k (ctype v))
    spec

let KVS (spec:(regexp*lens) List.t) : regexp List.t =
  List.map{regexp*lens}{regexp}
    (fun (p:regexp*lens) ->
       let k,v = p in
       KV k (atype v))
    spec       

let VALID_KVS (spec:(regexp*lens) List.t) =
  concatable (KVELTS spec) &&
  concatable (KVS spec)

(* TODO this pattern keeps coming up...we should have
   concat_lenses_ne, etc. for nonempty lists *)
let kvpairs (spaces:string in Xml.WS)
    (spec:(regexp*lens) List.t where List.nonempty{regexp*lens} spec
                                  && VALID_KVS spec)
  : (lens in concat_regexps (KVELTS spec) <-> concat_regexps (KVS spec))
  = let (Some(l)) = 
      List.fold_left{regexp*lens}{lens option}
	(fun (lo:lens option) (p:regexp*lens) ->
	   let k,v = p in
	   let l = kvpair spaces k v in
	   match lo with
	     | None -> Some{lens}(l)
	     | Some(l2) -> Some{lens}(l2 . l)
		 : lens option)
	None{lens} spec in
    l

let NONEMPTY_ODICT (spec:(regexp*lens) List.t) : regexp =
  Xml.ELT "dict" (concat_regexps (KVELTS spec))

let nonempty_odict (spaces:string in Xml.WS) 
    (spec:(regexp*lens) List.t where List.nonempty{regexp*lens} spec
                                  && VALID_KVS spec)
  : (lens in NONEMPTY_ODICT spec <-> concat_regexps (KVS spec))
  = let kv = kvpairs (indent spaces) spec in
    Xml.elt spaces "dict" kv

let ODICT (spec:(regexp*lens) List.t) : regexp 
  =  match List.empty{regexp*lens} spec with
      | true -> EMPTY_DICT
      | false -> NONEMPTY_ODICT spec
    : regexp

let podict (spaces:string in Xml.WS) 
    (spec:(regexp*lens) List.t where VALID_KVS spec)
  : (lens in ODICT spec <-> concat_regexps (KVS spec))
  = match List.empty{regexp*lens} spec with
      | true -> empty_dict spaces
      | false -> nonempty_odict spaces spec
    : lens

let LINECHAR = [a-zA-Z,.]
let LINE = (LINECHAR . ((LINECHAR | " ")* . LINECHAR)?)?

let lodict =
  podict "\n" 
    #{regexp*lens}["Author",pstring "\n  " (field LINE) . ins '\n';
		   "Lines",ins "=" . 
                           parray "\n  " 
			     (pstring "\n    " (LINE . ins " / ")) .
			   ins '\n';
		   "Birthdate",pinteger "\n  " (field INTEGER)]

let sample = 
  <<
   
    <dict>
      <key>Author</key>
      <string>William Shakespeare</string>
      <key>Lines</key>
      <array>
        <string>It is a tale told by an idiot,</string>
        <string>Full of sound and fury, signifying nothing.</string>
      </array>
      <key>Birthdate</key>
      <integer>1564</integer>
    </dict>
  >>

test lodict.get sample = 
  <<
    Author=William Shakespeare;
    Lines=It is a tale told by an idiot, / Full of sound and fury, signifying nothing. / 
    Birthdate=1564;
  >>

test lodict.create 
  <<
    Author=William Carlos Williams;
    Lines=so much depends / upon /  / a red wheel / barrow /  / glazed with rain / water /  / beside the white / chickens. / 
    Birthdate=1883;
  >> =
  <<
   
   <dict>
     <key>Author</key>
     <string>William Carlos Williams</string>
     <key>Lines</key>
     <array>
       <string>so much depends</string>
       <string>upon</string>
       <string></string>
       <string>a red wheel</string>
       <string>barrow</string>
       <string></string>
       <string>glazed with rain</string>
       <string>water</string>
       <string></string>
       <string>beside the white</string>
       <string>chickens.</string>
     </array>
     <key>Birthdate</key>
     <integer>1883</integer>
   </dict>
  >>

test lodict.put
  <<
    Author=Michael Greenberg;
    Lines=so much depends / upon /  / a red sail / boat /  / glazed with delaware / water /  / beside the white / chickens. / 
    Birthdate=1984;
  >> into
  <<

   <dict>
     <key>Author</key>
     <string>Michael Greenberg</string>
     <key>Lines</key>
     <array>
       <string>so much depends</string>
       <string>upon</string>
       <string></string>
       <string>a red wheel</string>
       <string>barrow</string>
       <string></string>
       <string>glazed with rain</string>
       <string>water</string>
       <string></string>
       <string>beside the white</string>
       <string>chickens.</string>
     </array>
     <key>Birthdate</key>
     <integer>1984</integer>
   </dict>
  >>
  =
  <<
   
   <dict>
     <key>Author</key>
     <string>Michael Greenberg</string>
     <key>Lines</key>
     <array>
       <string>so much depends</string>
       <string>upon</string>
       <string></string>
       <string>a red sail</string>
       <string>boat</string>
       <string></string>
       <string>glazed with delaware</string>
       <string>water</string>
       <string></string>
       <string>beside the white</string>
       <string>chickens.</string>
     </array>
     <key>Birthdate</key>
     <integer>1984</integer>
   </dict>
  >>

(* TODO

   nonhomogenous dictionaries

   -- ordered finite mappings

   -- sorted, finite mappings

   even better dictionaries

   -- sorted finite mappings, optional elements, homogenous (or simply regular?) tails
*)

(* Top level element

   <!ELEMENT plist %plistObject;>
   <!ATTLIST plist version CDATA "1.0" >
*)

(* we allow any local DTD, but if you use a public DTD, it has to be
   the right one. *)
let DTD_ID : regexp =
  Xml.DOCTYPE "plist"
    (("SYSTEM" . Xml.WSP . Xml.SYSTEMID) |
     ("PUBLIC" . Xml.WSP . 
	"\"-//Apple Computer//DTD PLIST 1.0//EN\"" . Xml.WSP .
	"\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\""))

let PLIST (BODY:regexp) : regexp = 
  Xml.ATTR_ELT "plist" (Xml.ATTR "version" "1.0") BODY
    
let plist (l:lens)
  : (lens in ((Xml.PROLOG DTD_ID)? . PLIST (ctype l)) <-> atype l)
  = del (Xml.PROLOG DTD_ID)? .
    Xml.attr1_elt_open "" "plist" "version" (del "1.0") . 
    l . 
    Xml.close_tag "\n" "plist"

let llist = plist lhsdict
test llist.get 
  <<
    <plist version="1.0">
      <dict>
        <key>foo</key><integer>5</integer>
      </dict>
    </plist>
  >> = "foo=5;"
test llist.get "<plist version='1.0'><dict/></plist>" = ""
test llist.put "bar=5;foo=4;" into "<plist version='1.0'><dict/></plist>" =
  <<
    <plist version='1.0'>
    <dict>
      <key>bar</key>
      <integer>5</integer>
      <key>foo</key>
      <integer>4</integer>
    </dict>
    </plist>
  >>

(* from http://developer.apple.com/documentation/Cocoa/Conceptual/PropertyLists/UnderstandXMLPlist/UnderstandXMLPlist.html *)
let llist2 = plist lodict
test llist2.get
  <<
    <?xml version="1.0" encoding="UTF-8"?>
    
    <!DOCTYPE plist SYSTEM "file://localhost/System/Library/DTDs/PropertyList.dtd">
    
    <plist version="1.0">
    
    <dict>
    
        <key>Author</key>
    
        <string>William Shakespeare</string>
    
        <key>Lines</key>
    
        <array>
    
            <string>It is a tale told by an idiot,</string>
    
            <string>Full of sound and fury, signifying nothing.</string>
    
        </array>
    
        <key>Birthdate</key>
    
        <integer>1564</integer>
    
    </dict>
    
    </plist>
  >> = 
  <<
    Author=William Shakespeare;
    Lines=It is a tale told by an idiot, / Full of sound and fury, signifying nothing. / 
    Birthdate=1564;
  >>

let llist3 =
  plist (podict "\n  "
	   #{regexp*lens}["booleanKey",field (pbool "\n    " "#t" "#f");
			  "dateKey",field (pdate "\n    " DATE);
			  "listKey",empty_array "\n    " . ";";
			  "recordKey",empty_dict "\n    " . ";";
			  "stringKey",field (pstring "\n    " LINE)])
			  
