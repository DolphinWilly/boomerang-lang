module Units = 

  let qc (v:string) (E:regexp) (D:regexp) (u:string) = 
    left_quot (canonizer_of_lens (const E v v))
      (right_quot (v <-> u)
         (canonizer_of_lens (const D u u)))

  test (qc "x" [a-z] [0-9] "1").create "9" = ?


(* ---- dup --- *)
test get (dup1 (copy [A-Z]) (get (copy [A-Z])) [A-Z]) "N" = "NN"
test get (dup2 (copy [A-Z]) (get (copy [A-Z])) [A-Z]) "N" = "NN"
test create (dup1 (copy [A-Z]) (get (copy [A-Z])) [A-Z]) "NM" = "N"
test create (dup2 (copy [A-Z]) (get (copy [A-Z])) [A-Z]) "NM" = "M"

(* permute *)
let l : lens = 
  permute
    #{int}[1;0;2] 
    #{lens}[copy [A-Z];key [0-9]; copy [a-z]]

test ctype l = ([A-Z] . [0-9] . [a-z])
test atype l = ([0-9] . [A-Z] . [a-z])
test l.get "A5z" = "5Az"
test l.create "0Az" = "A0z"

let l : lens = copy [a] ~ copy [b]
test l.get "ab" = "ba"
test l.create "ba" = "ab"

let l : lens = (copy [a])* ~ (copy [b])*
test l.create "bbaaaaa" = ?

(* sort *)
let q : canonizer = sort #{regexp}[[0-9];[A-Z];[a-z]]

test canonize q "f7N" = "7Nf"

let sort3 (r1:regexp) (r2:regexp) (r3:regexp) = sort #{regexp}[r1;r2;r3] 
let l3 = 
  let r1,r2,r3 = "a","b","c" in 
  left_quot (sort3 r1 r2 r3) (copy (r1 . r2 . r3))

test l3.get "abc" = "abc"
test l3.get "abc" = "abc"
test l3.get "acb" = "abc"
test l3.get "acb" = "abc"
test l3.get "abc" = "abc"
test l3.get "acb" = "abc"
test l3.get "bac" = "abc"
test l3.get "bac" = "abc"
test l3.get "bca" = "abc"
test l3.get "bca" = "abc"
test l3.get "bac" = "abc"
test l3.get "bca" = "abc"
test l3.get "cab" = "abc"
test l3.get "cab" = "abc"
test l3.get "cba" = "abc"
test l3.get "cba" = "abc"
test l3.get "cab" = "abc"
test l3.get "cba" = "abc"
test l3.get "abc" = "abc"
test l3.get "acb" = "abc"
test l3.get "bac" = "abc"
test l3.get "bca" = "abc"
test l3.get "cab" = "abc"
test l3.get "cba" = "abc"

