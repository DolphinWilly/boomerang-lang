module Coqsplit =

let ident = [a-zA-Z] . [a-zA-Z0-9_']*

let ending_in (R:regexp) = ANY . R

let def_kw = "Definition" | "Fixpoint" | "Inductive"
let pf_kw = "Theorem" | "Lemma"
let kw = pf_kw | "Example" | def_kw | "Notation" | "Require" | "Eval"

let until (R:regexp) (ex:regexp) = not_containing (R|ex) . R
let untilP (R:regexp) (ex:regexp) = not_containingP (R|ex) . R

let dotdnl = ".\n\n"
let until_dotdnl = until dotdnl kw
let until_tohere = until "...TO HERE *)\n" EMPTY

let nowsp (R:regexp) = R - (WSP . ANY)

let def_markers = "EXERCISE" | "EXERCISEOPT"
let def_marker : lens =
  (  ("(* EXERCISE *)" . until_dotdnl) <-> "(* FILL IN HERE *)\n\n"
  || ("(* EXERCISEOPT *)" . until_dotdnl) <-> "(* FILL IN HERE (OPTIONALLY) *)\n\n")

let pf_markers = def_markers|"ELIDEPROOFINLECTURE"|"ADMITTED"|"ADMITTEDOPT"
let pf_marker : lens =
  (  ("(* ELIDEPROOFINLECTURE *)\n" . until_dotdnl) <-> "(* Proof elided. *) Admitted.\n\n"
  || ("(* ADMITTED *)" . until_dotdnl) <-> "(* FILL IN HERE (and delete \"Admitted\") *) Admitted.\n\n"
  || ("(* ADMITTEDOPT *)" . until_dotdnl) <-> "(* OPTIONAL EXERCISE *) Admitted.\n\n")

let markers = def_markers | pf_markers | "EX" | "HIDE" | "COMMENT IN LECTURE" | "* <<" | "FILL IN HERE"

let marked_comment =
  (  ("(* EXERCISE..." . until_tohere) <-> "(* FILL IN HERE *)\n\n"
  || ("(* EXERCISEOPT..." . until_tohere) <-> "(* FILL IN HERE (OPTIONALLY) *)\n\n"
  || "(* OPEN COMMENT IN LECTURE *)\n" <-> "(** <<\n"
  || ("(* HIDE..." . until_tohere) <-> " " (* we would del, but then we're no longer iterable... *)
  || "(* CLOSE COMMENT IN LECTURE *)\n" <-> ">> **)\n")

let comment_markers = "EX" | "FILL IN HERE" | "COMMENT IN LECTURE" | "HIDE" | "<<" | ">>" | "Exercise:"

let comment_line : lens =
  (  until "\n" (comment_markers|"*)")
  || [ ]* . (("(* EXERCISE... *)" . until_tohere) <-> "(* FILL IN HERE *)\n")
  || [ ]* . (("(* EXERCISEOPT... *)" . until_tohere) <-> "(* FILL IN HERE (OPTIONALLY) *)\n"))

test lens_iterable comment_line = true

let difficulty =
  let modifier = 
    (  "?" <-> ", optional"
    || "!" <-> ", challenge problem"
    || "+" <-> ", recommended") in
  let stars =
    (  "1" <-> "1 star"
    || [2-5] . ins " stars") in
  let name = " (" . key ident . ")" in
  "(* " . ("EX" <-> "Exercise: ") . stars . modifier{0,3} . name? . " *)"

let comment =
  (  marked_comment
  || difficulty
  || "(*" . comment_line* . until "*)" (comment_markers|"\n"))

test lens_iterable comment = true

let until_eq = until ":=" (kw|dotdnl|markers)
let until_proof = until "Proof." (kw|dotdnl|markers)

let command =
  (  "Notation" . until_dotdnl
  || "Eval" . until ".\n" (kw|markers)
  || "Require" . (WSP . ("Export"|"Import"))? . WSP . 
      (ident - (ending_in "sol")) . ("(* SOL *)" <-> "sol" | "") . WS . dotdnl
  || def_kw . WSP . key ident . WSP . nowsp until_eq . WSP . (def_marker || nowsp (until dotdnl (kw|markers)))
  || pf_kw . WSP . key ident . WS . /:/ . WS . nowsp until_proof . WSP . (pf_marker || nowsp (until dotdnl (kw|markers)))
  || "Example" . WSP . key ident . WS . /:/ . WS . nowsp until_proof . [ ]+ . nowsp (until "Qed.\n" ("\n"|kw|markers))
  || comment
  || "\n")

test lens_iterable command = true

test command.get "Require Export While(* SOL *).\n\n" = "Require Export Whilesol.\n\n"
test command.put "Require Export Whilefsol.\n\n" 
            into "Require Export While(* SOL *).\n\n" 
               = "Require Export Whilef(* SOL *).\n\n"
test command.create "Require Export Whilesol.\n\n" 
  = "Require Export While(* SOL *).\n\n"

test command.get 
  <<
    Inductive day : Set :=
      | monday : day
      | tuesday : day
      | wednesday : day
      | thursday : day
      | friday : day
      | saturday : day
      | sunday : day.


  >> =    
  <<
    Inductive day : Set :=
      | monday : day
      | tuesday : day
      | wednesday : day
      | thursday : day
      | friday : day
      | saturday : day
      | sunday : day.


  >>

test command.get "Notation \"x + y\" := (plus x y)  (at level 50, left associativity).\n\n"
  = "Notation \"x + y\" := (plus x y)  (at level 50, left associativity).\n\n"

test command.get
  <<
    Fixpoint minus (n m : nat) {struct m} : nat :=
      match m with
        | O => n
        | S m' => minus (pred n) m'
      end.


  >> =
  <<
    Fixpoint minus (n m : nat) {struct m} : nat :=
      match m with
        | O => n
        | S m' => minus (pred n) m'
      end.


  >>

test command.get
  <<
    Fixpoint minus (n m : nat) {struct m} : nat :=
      (* EXERCISE *)
      match m with
        | O => n
        | S m' => minus (pred n) m'
      end.


  >> =
  <<
    Fixpoint minus (n m : nat) {struct m} : nat :=
      (* FILL IN HERE *)


  >>

test command.get
  <<
    Example test_andb31:                 (andb3 true true true) = true.
    Proof. simpl. reflexivity.  Qed.

  >> =
  <<
    Example test_andb31:                 (andb3 true true true) = true.
    Proof. simpl. reflexivity.  Qed.

  >>


test command.get
  <<
    Theorem plus_id_exercise : forall n m o : nat,
      n = m -> m = o -> plus n m = plus m o.
    Proof.
      (* ADMITTED *)
      intros m n o.
       intros EQmn.
       intros EQno.
       rewrite -> EQmn.
       rewrite -> EQno.
       reflexivity.  Qed.


  >> =
  <<
    Theorem plus_id_exercise : forall n m o : nat,
      n = m -> m = o -> plus n m = plus m o.
    Proof.
      (* FILL IN HERE (and delete "Admitted") *) Admitted.


  >>

test command.get 
  <<
    (* EXERCISE... *)
    
    Fixpoint forallb (X : Set) (test : X -> bool) (l : list X) {struct l} : bool :=
      match l with
        | [] => true
        | x :: l' => andb (test x) (forallb _ test l')
      end.
    
    Implicit Arguments forallb [X].
        
    Fixpoint existsb (X : Set) (test : X -> bool) (l : list X) {struct l} : bool :=
      match l with
        | [] => false
        | x :: l' => orb (test x) (existsb _ test l')
      end.
    
    Implicit Arguments existsb [X].
        
    Definition existsb' (X : Set) (test : X -> bool) (l : list X) : bool :=
      negb (forallb (fun x => negb (test x)) l).
    
    Implicit Arguments existsb' [X].
    
    Theorem existsb_existsb' : forall (X : Set) (test : X -> bool) (l : list X),
      existsb test l = existsb' test l.
    Proof.
      intros. induction l as [| x l'].
      Case "l = []".
        unfold existsb'. simpl. reflexivity.
      Case "l = x :: l'".
        unfold existsb'. simpl.
        destruct (test x).
        SCase "test x = true".
          simpl. reflexivity.
        SCase "test x = false".
          simpl.
          rewrite -> IHl'.
          unfold existsb'. reflexivity.
    Qed.
    
    (* ...TO HERE *)

  >> = 
  <<
    (* FILL IN HERE *)


  >>

test command.get 
  <<
    (* HIDE... *)
    Don't tell anyone!
    It's a secret!


    Top secret!
    (* ...TO HERE *)

  >> = " "


test command.get "(* OPEN COMMENT IN LECTURE *)\n" = "(** <<\n"
test command.get "(* CLOSE COMMENT IN LECTURE *)\n" = ">> **)\n"

test command.get "(* this is just a comment *)" = "(* this is just a comment *)"

let today = exec "date +%-m/%-d/%Y | tr -d '\\n'"

let timestamp = 
  let m = [1-9] | '1' . [1-2] in
  let d = [1-9] | [12] . [0-9] | "30" | "31" in
  let y = [1-9] . [0-9]{3} in
  let marker = "TIMESTAMP" in
  "Version of " . qconst marker (m.'/'.d.'/'.y) today marker

let header = "(*" . (not_containing (ctype timestamp | "*)")) . timestamp . "\n*)\n"

test header.get
  <<
    (* Basic programming and reasoning about programs in Coq
       Version of TIMESTAMP
    *)

  >> = 
  (<<
     (* Basic programming and reasoning about programs in Coq
        Version of 
   >> . today . "\n" .
   <<
     *)

   >>)

let file = header . <command>+

test file.get
  <<
    (* Basic programming and reasoning about programs in Coq
       Version of TIMESTAMP
    *)
    
    (* HOMEWORK INSTRUCTIONS:
    
       Submit homeworks using Blackboard:
         <https://courseweb.library.upenn.edu/>
       
       Solution files that Coq rejects will NOT be graded.
       You should be able to run CoqIDE/ProofGeneral to the
       end of the file, or run coqc without any errors.  If
       you can't solve one of the problems, leave an
       [Admitted] in the file.  Style, readability, and
       elegance count.
    
       If you have any questions about the homework, please
       e-mail the TAs.
    
       Have fun!
    *)
    
    (* HIDE... It might be better to introduce +, -, and * as
       notations.  This will make some expressions look a
       little cleaner, but more importantly it will give an
       opportunity for discussing the Notation mechanism,
       especially precedence, which was a persistent confusion
       among some people.  Really doing the
       discussion (drawing ASTs, discussing parsing,
       parentheses, etc.) would help this, I think. ...TO HERE *)
    
    (* ------------------------------------------------------- *)
    (* Days of the week *)
    
    Inductive day : Set :=
      | monday : day
      | tuesday : day
      | wednesday : day
      | thursday : day
      | friday : day
      | saturday : day
      | sunday : day.
    
    Definition next_weekday (d:day) : day :=
      match d with
      | monday => tuesday
      | tuesday => wednesday
      | wednesday => thursday
      | thursday => friday
      | friday => monday
      | saturday => monday
      | sunday => monday
      end.
    
    Eval simpl in (next_weekday friday).
    Eval simpl in (next_weekday (next_weekday saturday)).
    
    Example test_next_weekday:
      (next_weekday (next_weekday saturday)) = tuesday.
    Proof. simpl. reflexivity.  Qed.
    
    (* -------------------------------------------------------------- *)
    (* Booleans *)
    
    Inductive bool : Set :=
      | true : bool
      | false : bool.
    
    Definition negb (b:bool) := 
      match b with
      | true => false
      | false => true
      end.
    
    Definition ifb (b1 b2 b3:bool) : bool :=
      match b1 with
        | true => b2
        | false => b3
      end.
    
    Definition andb (b1:bool) (b2:bool) : bool := ifb b1 b2 false.
    
    Definition orb (b1:bool) (b2:bool) : bool := ifb b1 true b2.
    
    Example test_orb1:  (orb true  false) = true. 
    Proof. simpl. reflexivity.  Qed.
    Example test_orb2:  (orb false false) = false.
    Proof. simpl. reflexivity.  Qed.
    Example test_orb3:  (orb false true ) = true.
    Proof. simpl. reflexivity.  Qed.
    Example test_orb4:  (orb true  true ) = true.
    Proof. simpl. reflexivity.  Qed.
    
    (* EX1 (nandb_andb3) *)
    (* Uncomment and then complete the definitions of the
       following functions, making sure that the assertions
       below each can be verified by Coq. *)
    (* This function should return [true] if either or both of
       its inputs are [false]. *)
    Definition nandb (b1:bool) (b2:bool) : bool :=
      (* EXERCISE *)
      match b1 with
      | true => negb b2
      | false => true
      end.

    (* EX2 (plus_comm_informal) *)
    (* As an exercise, try translating your solution for
    plus_comm into an informal proof. *)
    (* Informal proof:
    Theorem: plus is commutative.
    Proof:
       (* EXERCISE... *)
       Let natural numbers n and m be given.  We show plus n m = plus m n
       by induction on m.
         - First, suppose m = 0.  By the definition of plus, plus 0 n = 0.
           More, we have already shown (lemma plus_n_0) that plus n 0 = 0.
           Thus, plus n 0 = plus 0 n.
    
         - Next, suppose m = S m' for some m' such that plus n m' = plus m' n.
           By the definition of plus and the inductive hypothesis, 
           plus (S m') n = S (plus m' n) = S (plus n m').  It
           remains to show plus n (S m') = S (plus n m') as well, but
           this is precisely lemma plus_n_Sm.
       (* ...TO HERE *)
    *)


  >> = 
  (<<
     (* Basic programming and reasoning about programs in Coq
        Version of 
   >> . today . "\n" .
   <<
     *)
     
     (* HOMEWORK INSTRUCTIONS:
     
        Submit homeworks using Blackboard:
          <https://courseweb.library.upenn.edu/>
        
        Solution files that Coq rejects will NOT be graded.
        You should be able to run CoqIDE/ProofGeneral to the
        end of the file, or run coqc without any errors.  If
        you can't solve one of the problems, leave an
        [Admitted] in the file.  Style, readability, and
        elegance count.
     
        If you have any questions about the homework, please
        e-mail the TAs.
     
        Have fun!
     *)
     
      
     (* ------------------------------------------------------- *)
     (* Days of the week *)
     
     Inductive day : Set :=
       | monday : day
       | tuesday : day
       | wednesday : day
       | thursday : day
       | friday : day
       | saturday : day
       | sunday : day.
     
     Definition next_weekday (d:day) : day :=
       match d with
       | monday => tuesday
       | tuesday => wednesday
       | wednesday => thursday
       | thursday => friday
       | friday => monday
       | saturday => monday
       | sunday => monday
       end.
     
     Eval simpl in (next_weekday friday).
     Eval simpl in (next_weekday (next_weekday saturday)).
     
     Example test_next_weekday:
       (next_weekday (next_weekday saturday)) = tuesday.
     Proof. simpl. reflexivity.  Qed.
     
     (* -------------------------------------------------------------- *)
     (* Booleans *)
     
     Inductive bool : Set :=
       | true : bool
       | false : bool.
     
     Definition negb (b:bool) := 
       match b with
       | true => false
       | false => true
       end.
     
     Definition ifb (b1 b2 b3:bool) : bool :=
       match b1 with
         | true => b2
         | false => b3
       end.
     
     Definition andb (b1:bool) (b2:bool) : bool := ifb b1 b2 false.
     
     Definition orb (b1:bool) (b2:bool) : bool := ifb b1 true b2.
     
     Example test_orb1:  (orb true  false) = true. 
     Proof. simpl. reflexivity.  Qed.
     Example test_orb2:  (orb false false) = false.
     Proof. simpl. reflexivity.  Qed.
     Example test_orb3:  (orb false true ) = true.
     Proof. simpl. reflexivity.  Qed.
     Example test_orb4:  (orb true  true ) = true.
     Proof. simpl. reflexivity.  Qed.
     
     (* Exercise: 1 star (nandb_andb3) *)
     (* Uncomment and then complete the definitions of the
        following functions, making sure that the assertions
        below each can be verified by Coq. *)
     (* This function should return [true] if either or both of
        its inputs are [false]. *)
     Definition nandb (b1:bool) (b2:bool) : bool :=
       (* FILL IN HERE *)
     
     (* Exercise: 2 stars (plus_comm_informal) *)
     (* As an exercise, try translating your solution for
     plus_comm into an informal proof. *)
     (* Informal proof:
     Theorem: plus is commutative.
     Proof:
        (* FILL IN HERE *)
     *)
    
    
   >>)
