module Conflin =

(* ---------------------------------------------------------------- *)
(*                           definitions                            *)

let if 'a (b:bool) (t:'a) (f:'a) =
  match b with
  | true -> t
  | false -> f
  :'a
let id 'a (x:'a) = x
let drop_string (n:int) (s:string where n lt (length s)) =
  sub_string n (length s - n) s
let end_with (s:string) (e:string) =
  let ns = length s in
  let ne = length e in
  match ns geq ne with
  | true -> (drop_string (ns - ne) s = e)
  | false -> false
  :bool
let ambiguous_lens_concat_contract (a:lens) (b:lens) =
  is_basic a && is_basic b && splittable_cex (stype a) (stype b)
let ambiguous_lens_concat (a:lens) (b:lens where ambiguous_lens_concat_contract a b) =
  Native.Prelude.lens_concat a b
let ambiguous_lens_partition_one_contract (a:lens) (b:lens) =
  lens_star_contract b && lens_swap_contract b* a
  && ambiguous_lens_concat_contract (lens_swap b* a) b*
let ambiguous_lens_partition_one (a:lens) (b:lens where ambiguous_lens_partition_one_contract a b) =
  ambiguous_lens_concat (lens_swap b* a) b*
let positional (name:string) = Tag (Positional, Threshold 0, name)
let diffy (first:bool) (name:string) = Tag (Diffy first, Threshold 0, name)
let show_list 'a (l:'a List.t) =
  "[" . fst {string} {bool} (
    List.fold_left {'a} {string * bool} (
      fun (sb:string * bool) (x:'a) ->
        match sb with
        | s, b -> (s . if {string} b ";" "" . show {'a} x, true)
            :string * bool
    ) ("", false) l
  ) . "]"
let mk_error (message:string) = "Error: " . message
let identifier = [a-zA-Z] . [ a-zA-Z0-9_\-@]*
let printLn 'a (x:'a) = write '-' (show {'a} x . newline)
let is_lens (l:lens) = rel_is_id (sequiv l) && rel_is_id (vequiv l)

(* ---------------------------------------------------------------- *)
(*                        File_pref module                         *)

module File_pref =
  type t = T of regexp * (string * string) * (string * string) * string
  let make (values:regexp)
      (comment_prefix:string) (comment_suffix:string)
      (command_prefix:string) (command_suffix:string)
      (view_prefix:string) =
    T (values,
       (comment_prefix, comment_suffix),
       (command_prefix, command_suffix),
       view_prefix)
  let shell_like = T (identifier, ("#", "\n"), ("@", ""), "view: ")
  let c_like = T (identifier, ("//", "\n"), ("@", ""), "view: ")
  let cpp_like = T (identifier, ("/*", "*/"), ("@", ""), "view: ")
  let ocaml_like = T (identifier, ("(*", "*)"), ("@", ""), "view: ")
  let debug_like = T ([a-z], ("(", ")"), ("", ""), "")
  let set_command_prefix (x:string) (t:t) =
    match t with
    | T (values, comments, (_, command_suffix), view_prefix) ->
        T (values, comments, (x, command_suffix), view_prefix)
    :t
  let set_command_suffix (x:string) (t:t) =
    match t with
    | T (values, comments, (command_prefix, _), view_prefix) ->
        T (values, comments, (command_prefix, x), view_prefix)
    :t
  let values (t:t) =
    match t with
    | T (values, _, _, _) -> values
    :regexp
  let comments (t:t) =
    match t with
    | T (_, comments, _, _) -> comments
    :string * string
  let commands (t:t) =
    match t with
    | T (_, _, commands, _) -> commands
    :string * string
  let view_prefix (t:t) =
    match t with
    | T (_, _, _, view_prefix) -> view_prefix
    :string
end

(* ---------------------------------------------------------------- *)
(*                         exception type                           *)

type exception = Exit | Failure of string

(* ---------------------------------------------------------------- *)
(*                            main lens                             *)

let main_lens (prefs:File_pref.t) (value:string) :(l:lens where is_lens l) =
  (* read prefs *)
  let values = File_pref.values prefs in
  let comment_prefix, comment_suffix = File_pref.comments prefs in
  let command_prefix, command_suffix = File_pref.commands prefs in
  let view_prefix = File_pref.view_prefix prefs in
  (* shortcuts *)
  let comment_signs = comment_prefix | comment_suffix in
  let c_prefix = comment_prefix . command_prefix in
  let c_suffix = command_suffix . comment_suffix in
  let no_comments = not_containing comment_signs in
  let real_commands = c_prefix . values? . c_suffix in
  let commands = c_prefix . no_comments . c_suffix in
  let data = not_containing commands in
  (* we check that the informations are useable *)
  let _:(string where
           is_empty (diff (view_prefix? . values?) no_comments)) =
    mk_error "Your values and/or view_prefix contain comments."
  in
  let _:(string where
           not (matches values "")) =
    mk_error "Your values should NOT contain the empty string."
  in
  let _:(string where
           matches values? value) =
    mk_error ("The value " . show {string} value . " does not match " . show {regexp} values? . ".")
  in
  (* tools *)
  let c_exact (value:string) = c_prefix . value . c_suffix in
  let c_other (value:string) = c_prefix . diff values value . c_suffix in
  let c_all = c_prefix . values . c_suffix in
  let c_stop = c_exact "" in
  let factor (format:bool) (value:string) =
    match format with
    | true ->
        c_stop . data
        . (
          match value = "" with
          | true -> (c_all . data)*
          | false ->
              ( (c_other value . data)*
              | ambiguous_lens_partition_one (c_exact value . data) (c_other value . data)
              )
          :lens)
    | false -> (
        let data_tag = positional "data" in
        let siblings_tag = positional "siblings" in
        let csd = c_stop . data in
        let cevd = c_exact value . data in
        let covd = c_other value . data in
        let siblings = <siblings_tag: del (c_other value . data)* > in
        match value = "" with
        | true -> csd . del covd*
        | false ->
            ( <data_tag: copy csd >            
            | <data_tag: del  csd > . copy cevd
            ) . siblings
        :lens
      )
    :lens
  in
  (* to check the value for put *)
  let value_check (value:string) = ins (c_exact (view_prefix . value)) in
  let main (format:bool) =
    data
    . (match format with
       | true -> (factor true value)*
       | false -> value_check value . <diffy true "factor": factor false value >*
       :lens
      )
  in
  main true ; align ( main false )

(* ---------------------------------------------------------------- *)
(*                          main function                           *)

(* command line arguments *)
let help_pref = Prefs.create_bool "-help" false "print this help"
let _ = Prefs.alias_bool help_pref "h"
let extension_pref = Prefs.create_string "-extension" "factor" "extension of source (default: factor)"
let _ = Prefs.alias_string extension_pref "e"
let value_pref = Prefs.create_string "-value" "" "value of the view"
let _ = Prefs.alias_string value_pref "v"
let default_pref = Prefs.create_string_list "-default" "mandatory: shell, c, cpp or ocaml"
let _ = Prefs.alias_string_list default_pref "d"
let command_prefix_pref = Prefs.create_string_list "-command-prefix" "identify a command from a comment"
let _ = Prefs.alias_string_list command_prefix_pref "ap"
let command_suffix_pref = Prefs.create_string_list "-command-suffix" "identify a command from a comment"
let _ = Prefs.alias_string_list command_suffix_pref "as"
let rest_pref = Prefs.extern_rest ()

(* usage message *)
let usage:string = ""

(* main code *)
let main (x:unit) =
  (* shortcuts *)
  let print_usage (code:int) =
    let _ = Prefs.print_usage usage in
    code
  in
  let fail (exn:exception) =
    match exn with
    | Exit -> 0
    | Failure message -> (
        let _ = put_str (message . newline) in 1)
    :int
  in
  let seq 'i 'j 'k
      (f:forall 'a => (exception -> 'a) -> ('j -> 'a) -> 'i -> 'a)
      (g:forall 'a => (exception -> 'a) -> ('k -> 'a) -> 'j -> 'a)
      'a (fail:exception -> 'a) (ok:'k -> 'a) (x:'i)
      = f {'a} fail (g {'a} fail ok) x
  in
  (* parsing the commandline *)
  let read_help 'a (fail:exception -> 'a) (ok:unit -> 'a) (u:unit) =
    match Prefs.read_bool help_pref with
    | true -> (let _ = Prefs.print_usage usage in fail Exit)
    | false -> ok ()
    :'a
  in
  let extension = Prefs.read_string extension_pref in
  let value = Prefs.read_string value_pref in
  let read_default 'a (fail:exception -> 'a) (ok:File_pref.t -> 'a) (u:unit) =
    match Prefs.read_string_list default_pref with
    | pref::[] -> (
        match pref with
        | "shell" -> ok File_pref.shell_like
        | "c" -> ok File_pref.c_like
        | "cpp" -> ok File_pref.cpp_like
        | "ocaml" -> ok File_pref.ocaml_like
        | _ -> fail (Failure (show {string} pref . " is not a valid file preference."))
        :'a)
    | _ -> fail (Failure "You need to define exactly one file preference.")
    :'a
  in
  let read_command_prefix 'a (fail:exception -> 'a) (ok:File_pref.t -> 'a) (default:File_pref.t) =
    match Prefs.read_string_list command_prefix_pref with
    | [] -> ok default
    | pref::[] -> ok (File_pref.set_command_prefix pref default)
    | _ -> fail (Failure "You can define at most one command-prefix preference.")
    :'a
  in
  let read_command_suffix 'a (fail:exception -> 'a) (ok:File_pref.t -> 'a) (default:File_pref.t) =
    match Prefs.read_string_list command_suffix_pref with
    | [] -> ok default
    | pref::[] -> ok (File_pref.set_command_suffix pref default)
    | _ -> fail (Failure "You can define at most one command-suffix preference.")
    :'a
  in
  let do_action 'a (fail:exception -> 'a) (ok:int -> 'a) (prefs:File_pref.t) =
    match Prefs.read_string_list rest_pref with
    | [] -> ok 0
    | file::[] -> (
        let mlpv = main_lens prefs value in
        match end_with file extension with
        | true -> (
            let _ = put_str (get mlpv (read file)) in
            ok 0)
        | false -> (
            let _ = put_str (put mlpv (read file) (read (file . "." . extension))) in
            ok 0)
        :'a
      )
    | _ -> fail (Failure "Too much files.")
    :'a
  in
  let seq_uui = seq {unit} {unit} {int} in
  let seq_upi = seq {unit} {File_pref.t} {int} in
  let seq_upp = seq {unit} {File_pref.t} {File_pref.t} in
  let seq_ppp = seq {File_pref.t} {File_pref.t} {File_pref.t} in
  let read_prefs = seq_upp read_default (seq_ppp read_command_prefix read_command_suffix) in
  let run = seq_uui read_help (seq_upi read_prefs do_action) in
  run {int} fail id {int} ()

(* ---------------------------------------------------------------- *)
(*                            unit tests                            *)

let mld = main_lens File_pref.debug_like

let mldv = mld ""
test get mldv (  "()d0(a)a0(b)b0()d1(b)b1()d2")
            = ("()()d0"       ."()d1"  ."()d2")
test create mldv ("()()d0()d1()d2")
               = (  "()d0()d1()d2")
test put mldv ("()" ."()d1()d2()d3")
              (  "()d0()d1()d2"    )
            = (      "()d1()d2()d3")

let mldv = mld "a"
test get mldv (   "()d0(a)a0(b)b0()d1(b)b1()d2")
            = ("(a)" ."(a)a0"  ."()d1"  ."()d2")
test create mldv ("(a)"."(a)a0()d1()d2"  ."(a)a3")
               = (    "()(a)a0()d1()d2"."()(a)a3")
test put mldv ("(a)"  ."(a)a0()d1()d2")
              (    "()d0"  ."()d1()d2")
            = (    "()d0(a)a0()d1()d2")
test put mldv ("(a)"  ."(a)a0" ."()d2")
              (    "()d0"  ."()d1()d2")
            = (    "()d0(a)a0" ."()d2")
test put mldv ("(a)"."(a)a0()d0()d1()d2")
              (           "()d0()d1()d2")
            = (    "()(a)a0()d0()d1()d2")
test put mldv ("(a)"."(a)a0()d0" ."()d2")
              (           "()d0()d1()d2")
            = (    "()(a)a0()d0" ."()d2")
