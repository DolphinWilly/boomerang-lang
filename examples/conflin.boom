module Conflin =

(* ---------------------------------------------------------------- *)
(*                           definitions                            *)

let if 'a (b:bool) (t:'a) (f:'a) =
  match b with
  | true -> t
  | false -> f
  :'a
let id 'a (x:'a) = x
let put_str_ln (x:string) = put_str (x . newline)
let drop_string (n:int) (s:string where n leq (length s)) =
  sub_string n (length s - n) s
let rdrop_string (n:int) (s:string where n leq (length s)) =
  sub_string 0 (length s - n) s
let take_string (n:int) (s:string where n leq (length s)) =
  sub_string 0 n s
let rtake_string (n:int) (s:string where n leq (length s)) =
  sub_string (length s - n) n s
let end_with (s:string) (e:string) =
  let ns = length s in
  let ne = length e in
  match ns geq ne with
  | true -> (rtake_string ne s = e)
  | false -> false
  :bool
let ambiguous_lens_concat_contract (a:lens) (b:lens) =
  is_basic a && is_basic b && splittable_cex (stype a) (stype b)
let ambiguous_lens_concat (a:lens) (b:lens where ambiguous_lens_concat_contract a b) =
  Native.Prelude.lens_concat a b
let ambiguous_lens_partition_one_contract (a:lens) (b:lens) =
  lens_star_contract b && lens_swap_contract b* a
  && ambiguous_lens_concat_contract (lens_swap b* a) b*
let ambiguous_lens_partition_one (a:lens) (b:lens where ambiguous_lens_partition_one_contract a b) =
  ambiguous_lens_concat (lens_swap b* a) b*
let positional (name:string) = Tag (Positional, Threshold 0, name)
let diffy (first:bool) (name:string) = Tag (Diffy first, Threshold 0, name)
let show_list 'a (l:'a List.t) =
  "[" . fst {string} {bool} (
    List.fold_left {'a} {string * bool} (
      fun (sb:string * bool) (x:'a) ->
        match sb with
        | s, b -> (s . if {string} b ";" "" . show {'a} x, true)
            :string * bool
    ) ("", false) l
  ) . "]"
let mk_error (message:string) = "Error: " . message
let identifier = [a-zA-Z] . [ a-zA-Z0-9_\-@]*
let print_ln 'a (x:'a) = write '-' (show {'a} x . newline)
let is_lens (l:lens) = rel_is_id (sequiv l) && rel_is_id (vequiv l)

(* ---------------------------------------------------------------- *)
(*                        File_pref module                         *)

module File_pref =
  type t = T of regexp * (string * string) * (string * string) * string
  let make (values:regexp)
      (comment_prefix:string) (comment_suffix:string)
      (command_prefix:string) (command_suffix:string)
      (view_prefix:string) =
    T (values,
       (comment_prefix, comment_suffix),
       (command_prefix, command_suffix),
       view_prefix)
  let default_view_prefix = "view: "
  let default_commands = "@", ""
  let shell_like = T (identifier, ("#", "\n"), default_commands, default_view_prefix)
  let c_like = T (identifier, ("//", "\n"), default_commands, default_view_prefix)
  let cpp_like = T (identifier, ("/*", "*/"), default_commands, default_view_prefix)
  let ocaml_like = T (identifier, ("(*", "*)"), default_commands, default_view_prefix)
  let debug_like = T ([a-z], ("(", ")"), ("", ""), "")
  let set_command_prefix (x:string) (t:t) =
    match t with
    | T (values, comments, (_, command_suffix), view_prefix) ->
        T (values, comments, (x, command_suffix), view_prefix)
    :t
  let set_command_suffix (x:string) (t:t) =
    match t with
    | T (values, comments, (command_prefix, _), view_prefix) ->
        T (values, comments, (command_prefix, x), view_prefix)
    :t
  let values (t:t) =
    match t with
    | T (values, _, _, _) -> values
    :regexp
  let comments (t:t) =
    match t with
    | T (_, comments, _, _) -> comments
    :string * string
  let commands (t:t) =
    match t with
    | T (_, _, commands, _) -> commands
    :string * string
  let view_prefix (t:t) =
    match t with
    | T (_, _, _, view_prefix) -> view_prefix
    :string
end

(* ---------------------------------------------------------------- *)
(*                            main lens                             *)

let main_lens (prefs:File_pref.t) (value:string) :(l:lens where is_lens l) =
  (* read prefs *)
  let values = File_pref.values prefs in
  let comment_prefix, comment_suffix = File_pref.comments prefs in
  let command_prefix, command_suffix = File_pref.commands prefs in
  let view_prefix = File_pref.view_prefix prefs in
  (* shortcuts *)
  let comment_signs = comment_prefix | comment_suffix in
  let c_prefix = comment_prefix . command_prefix in
  let c_suffix = command_suffix . comment_suffix in
  let no_comments = not_containing comment_signs in
  let real_commands = c_prefix . values? . c_suffix in
  let commands = c_prefix . no_comments . c_suffix in
  let data = not_containing commands in
  (* we check that the informations are useable *)
  let _:(string where
           is_empty (diff (view_prefix? . values?) no_comments)) =
    mk_error "Your values and/or view_prefix contain comments."
  in
  let _:(string where
           not (matches values "")) =
    mk_error "Your values should NOT contain the empty string."
  in
  let _:(string where
           matches values? value) =
    mk_error ("The value " . show {string} value . " does not match " . show {regexp} values? . ".")
  in
  (* tools *)
  let c_exact (value:string) = c_prefix . value . c_suffix in
  let c_other (value:string) = c_prefix . diff values value . c_suffix in
  let c_all = c_prefix . values . c_suffix in
  let c_stop = c_exact "" in
  let factor (format:bool) (value:string) =
    match format with
    | true ->
        c_stop . data
        . (
          match value = "" with
          | true -> (c_all . data)*
          | false ->
              ( (c_other value . data)*
              | ambiguous_lens_partition_one (c_exact value . data) (c_other value . data)
              )
          :lens)
    | false -> (
        let data_tag = positional "data" in
        let siblings_tag = positional "siblings" in
        let csd = c_stop . data in
        let cevd = c_exact value . data in
        let covd = c_other value . data in
        let siblings = <siblings_tag: del (c_other value . data)* > in
        match value = "" with
        | true -> csd . del covd*
        | false ->
            ( <data_tag: copy csd >            
            | <data_tag: del  csd > . copy cevd
            ) . siblings
        :lens
      )
    :lens
  in
  (* to check the value for put *)
  let value_check (value:string) = ins (c_exact (view_prefix . value)) in
  let main (format:bool) =
    data
    . (match format with
       | true -> (factor true value)*
       | false -> value_check value . <diffy true "factor": factor false value >*
       :lens
      )
  in
  main true ; align ( main false )

(* ---------------------------------------------------------------- *)
(*                          main function                           *)

type 'a w = Value of 'a | Error of unit -> int
type 'a io = IO of unit -> 'a

let fmap_w 'a 'b (f:'a -> 'b) (x:'a w) =
  match x with
  | Value v -> Value {'b} (f v)
  | Error e -> Error {'b} e
  :'b w
let fmap_io 'a 'b (f:'a -> 'b) (x:'a io) =
  match x with
  | IO x -> IO {'b} (fun (u:unit) -> f (x ()))
  :'b io

let join_w 'a (x:('a w) w) =
  match x with
  | Value (Value v) -> Value {'a} v
  | Value (Error e) -> Error {'a} e
  | Error e -> Error {'a} e
  :'a w
let join_io 'a (x:('a io) io) =
  match x with
  | IO x -> IO {'a} (
      fun (u:unit) ->
        match x () with
        | IO y -> y ()
        :'a)
  :'a io

let bind_w 'a 'b (x:'a w) (f:'a -> 'b w) =
  join_w {'b} (fmap_w {'a} {'b w} f x)
let bind_io 'a 'b (x:'a io) (f:'a -> 'b io) =
  join_io {'b} (fmap_io {'a} {'b io} f x)

let rbind_w 'a 'b (f:'a -> 'b w) (x:'a w) =
  bind_w {'a} {'b} x f
let rbind_io 'a 'b (f:'a -> 'b io) (x:'a io) =
  bind_io {'a} {'b} x f

let seq_w 'a (x:unit w) (y:'a w) =
  bind_w {unit} {'a} x (fun (u:unit) -> y)
let seq_io 'a (x:unit io) (y:'a io) =
  bind_io {unit} {'a} x (fun (u:unit) -> y)

let return_w 'a (x:'a) = Value {'a} x
let return_io 'a (x:'a) = IO {'a} (fun (u:unit) -> x)

let ok 'a (x:'a) = Value {'a} x
let fail 'a (f:unit -> int) = Error {'a} f
let failwith 'a (message:string) = fail {'a} (fun (u:unit) -> let _ = put_str ("Failure: " . message . newline) in 1)

let okfailwith 'a = ok {'a}, fail {'a}, failwith {'a}

let bind_w_pp = bind_w {File_pref.t} {File_pref.t}
let bind_w_piI = bind_w {File_pref.t} {int io}
let bind_w_siI = bind_w {string} {int io}
let bind_w_sOiI = bind_w {string option} {int io}
let seq_w_iI = seq_w {int io}

(* command line arguments *)
let help_pref = Prefs.create_bool "-help" false "print this help"
let _ = Prefs.alias_bool help_pref "h"
let extension_pref = Prefs.create_string "-extension" "conflin" "extension of source (default: 'conflin')"
let _ = Prefs.alias_string extension_pref "e"
let value_pref = Prefs.create_string "-value" "" "value of the view"
let _ = Prefs.alias_string value_pref "v"
let output_pref = Prefs.create_string_list "-output" "output file (default: <file> with or without <extension>)"
let _ = Prefs.alias_string_list output_pref "o"
let default_pref = Prefs.create_string_list "-default" "mandatory: shell, c, cpp or ocaml"
let _ = Prefs.alias_string_list default_pref "d"
let command_prefix_pref = Prefs.create_string_list "-command-prefix" "identify a command from a comment"
let _ = Prefs.alias_string_list command_prefix_pref "ap"
let command_suffix_pref = Prefs.create_string_list "-command-suffix" "identify a command from a comment"
let _ = Prefs.alias_string_list command_suffix_pref "as"
let rest_pref = Prefs.extern_rest ()

(* TODO: write a --documentation *)

(* usage message *)
let usage:string = "Usage: " . Prefs.get_prog_name () . " --default <file_type> <file>"

(* main code *)
let main (x:unit) =
  (* shortcuts *)
  let print_usage (code:int) (u:unit) =
    let _ = Prefs.print_usage usage in
    code
  in
  (* parsing the commandline *)
  let help =
    let ok, fail, failwith = okfailwith {unit} in
    match Prefs.read_bool help_pref with
    | true -> fail (print_usage 0)
    | false -> ok ()
    :unit w
  in
  let extension = "." . Prefs.read_string extension_pref in
  let value = Prefs.read_string value_pref in
  let output =
    let ok, fail, failwith = okfailwith {string option} in
    match Prefs.read_string_list output_pref with
    | [] -> ok None {string}
    | output::[] -> ok (Some {string} output)
    | _ -> failwith "You can define at most one output file."
    :(string option) w
  in
  let default =
    let ok, fail, failwith = okfailwith {File_pref.t} in
    match Prefs.read_string_list default_pref with
    | "shell"::[] -> ok File_pref.shell_like
    | "c"::[] -> ok File_pref.c_like
    | "cpp"::[] -> ok File_pref.cpp_like
    | "ocaml"::[] -> ok File_pref.ocaml_like
    | pref::[] -> failwith (show {string} pref . " is not a valid file preference.")
    | _ -> failwith "You need to define exactly one file preference."
    :File_pref.t w
  in
  let command_prefix (default:File_pref.t) =
    let ok, fail, failwith = okfailwith {File_pref.t} in
    match Prefs.read_string_list command_prefix_pref with
    | [] -> ok default
    | pref::[] -> ok (File_pref.set_command_prefix pref default)
    | _ -> failwith "You can define at most one command-prefix preference."
    :File_pref.t w
  in
  let command_suffix (default:File_pref.t) =
    let ok, fail, failwith = okfailwith {File_pref.t} in
    match Prefs.read_string_list command_suffix_pref with
    | [] -> ok default
    | pref::[] -> ok (File_pref.set_command_suffix pref default)
    | _ -> failwith "You can define at most one command-suffix preference."
    :File_pref.t w
  in
  let main (prefs:File_pref.t) =
    let ok, fail, failwith = okfailwith {int io} in
    let io = IO {int} in
    match Prefs.read_string_list rest_pref with
    | [] -> fail (print_usage 1)
    | file::[] -> (
        let mlpv = main_lens prefs value in
        match end_with file extension with
        | true -> (  (* TODO: check file *)
            bind_w_sOiI output (fun (output:string option) ->
            ok (io (fun (u:unit) ->
            let output =
              match output with
              | None -> rdrop_string (length extension) file
              | Some output -> output
              :string
            in
            let _ = write output (get mlpv (read file)) in
            0))))
        | false -> (  (* Warning: only outputs are in IO *)
            let view =
              let ok, fail, failwith = okfailwith {string} in
              let view = read file in
              match matches (vtype mlpv) view with
              | true -> ok view
              | false -> failwith (
                  "File " . show {string} file . " is not a valid view.\n\n"
                  . "You might want to check these:\n"
                  . "* The expanding value " . show {string} value . " is the one in prefix view\n"
                  . "* The file_type is the right one")
              :string w
            in
            let source =
              let ok, fail, failwith = okfailwith {string} in
              let file = file . extension in
              let source = read file in
              match matches (stype mlpv) source with
              | true -> ok source
              | false -> failwith (
                  "File " . show {string} file . " is not a valid source.\n\n"
                  . "You might want to check these:\n"
                  . "* The file_type is the right one"
                  . "* The extension " . show {string} (drop_string 1 extension) . " is the right one\n")
              :string w
            in
            bind_w_siI view (fun (view:string) ->
            bind_w_siI source (fun (source:string) ->
            bind_w_sOiI output (fun (output:string option) ->
            ok (io (fun (u:unit) ->
            let output =
              match output with
              | None -> file . extension
              | Some output -> output
              :string
            in
            let _ = write output (put mlpv view source) in
            0))))))
        :(int io) w
      )
    | _ -> failwith "You can factorize/expand at most one file."
    :(int io) w
  in
  let prefs = bind_w_pp (bind_w_pp default command_prefix) command_suffix in
  let result = seq_w_iI help (bind_w_piI prefs main) in
  match result with
  | Value (IO io) -> io ()
  | Error fail -> fail ()
  :int

(* ---------------------------------------------------------------- *)
(*                            unit tests                            *)

(* --- Debug --- *)

let mld = main_lens File_pref.debug_like

let mldv = mld ""
test get mldv (  "()d0(a)a0(b)b0()d1(b)b1()d2")
            = ("()()d0"       ."()d1"  ."()d2")
test create mldv ("()()d0()d1()d2")
               = (  "()d0()d1()d2")
test put mldv ("()" ."()d1()d2()d3")
              (  "()d0()d1()d2"    )
            = (      "()d1()d2()d3")

let mldv = mld "a"
test get mldv (   "()d0(a)a0(b)b0()d1(b)b1()d2")
            = ("(a)" ."(a)a0"  ."()d1"  ."()d2")
test create mldv ("(a)"."(a)a0()d1()d2"  ."(a)a3")
               = (    "()(a)a0()d1()d2"."()(a)a3")
test put mldv ("(a)"  ."(a)a0()d1()d2")
              (    "()d0"  ."()d1()d2")
            = (    "()d0(a)a0()d1()d2")
test put mldv ("(a)"  ."(a)a0" ."()d2")
              (    "()d0"  ."()d1()d2")
            = (    "()d0(a)a0" ."()d2")
test put mldv ("(a)"."(a)a0()d0()d1()d2")
              (           "()d0()d1()d2")
            = (    "()(a)a0()d0()d1()d2")
test put mldv ("(a)"."(a)a0()d0" ."()d2")
              (           "()d0()d1()d2")
            = (    "()(a)a0()d0" ."()d2")

(* --- Exemples --- *)

let mls = main_lens File_pref.shell_like

let source =
<<
  #@
  # Define the specific parts of PATH for each machine
  #@
  # This is the default
  SPATH=""
  #@upenn
  # If we are in UPenn
  SPATH="/home/harmony/bin:/home/harmony/boomerang/bin"
  #@
  
  # This is the common part of PATH
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
  # We concatenate both parts
  PATH="$PATH:$SPATH"
  
  # We finally export the PATH
  export PATH
>>

test get (mls "") source =
<<
  #@view: 
  #@
  # Define the specific parts of PATH for each machine
  #@
  # This is the default
  SPATH=""
  #@
  
  # This is the common part of PATH
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
  # We concatenate both parts
  PATH="$PATH:$SPATH"
  
  # We finally export the PATH
  export PATH
>>

test get (mls "upenn") source =
<<
  #@view: upenn
  #@
  # Define the specific parts of PATH for each machine
  #@upenn
  # If we are in UPenn
  SPATH="/home/harmony/bin:/home/harmony/boomerang/bin"
  #@
  
  # This is the common part of PATH
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
  # We concatenate both parts
  PATH="$PATH:$SPATH"
  
  # We finally export the PATH
  export PATH
>>

test get (mls "X") source =
<<
  #@view: X
  #@
  # Define the specific parts of PATH for each machine
  #@
  # This is the default
  SPATH=""
  #@
  
  # This is the common part of PATH
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
  # We concatenate both parts
  PATH="$PATH:$SPATH"
  
  # We finally export the PATH
  export PATH
>>

test put (mls "X")
<<
  #@view: X
  #@
  # Define the specific parts of PATH for each machine
  #@X
  # For Polytechnique
  SPATH="$HOME/bin"
  #@
  
  # This is the common part of PATH
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
  # We concatenate both parts
  PATH="$PATH:$SPATH"
  
  # We finally export the PATH
  export PATH
>> source =
<<
  #@
  # Define the specific parts of PATH for each machine
  #@
  # This is the default
  SPATH=""
  #@X
  # For Polytechnique
  SPATH="$HOME/bin"
  #@upenn
  # If we are in UPenn
  SPATH="/home/harmony/bin:/home/harmony/boomerang/bin"
  #@
  
  # This is the common part of PATH
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
  # We concatenate both parts
  PATH="$PATH:$SPATH"
  
  # We finally export the PATH
  export PATH
>>
