module QuickStart = 

#{@}

\section{Installation}

\begin{enumerate}
\item Download or build the Boomerang binary:
\begin{itemize}
\item Pre-compiled binaries for Linux (x86), Mac OS X (x86), and
  Windows (Cygwin) are available on the Boomerang webpage.
\item Alternatively, to build Boomerang from source, grab the most
  recent tarball and follow the instructions in boomerang/INSTALL.txt
\end{itemize}

\item Add the directory containing trunk/bin to your @PATH@
  environment variable.
\begin{itemize}   
\item In Bash:
\begin{progeg}
> export PATH=$PATH:/path/to/trunk/bin
\end{progeg}
\item In Csh
\begin{progeg}
> setenv PATH {$PATH}:/path/to/trunk/bin
\end{progeg}
\end{itemize}
\end{enumerate}

\section{Simple Lens Programming}

Now letâ€™s roll up our sleeves and write a few lenses. We will start
with some very simple lenses that demonstrate how to interact with the
Boomerang system. The source file we will work with is this very text
file, which is literate Boomerang code. Every line in this file that
begins with @#*@ marks a piece of Boomerang code, and all other lines
are ignored by the Boomerang interpreter.

You can run the Boomerang interpreter from the command line like this:
\begin{progeg}
> boomerang QuickStart.src
\end{progeg}
You should see several lines of output beginning like this
\begin{progeg}
Test result:
"Hello World"
Test result:
"HELLO WORLD"
...
\end{progeg}
\noindent Let's define the lens that was used to generate this text.

#* let l : lens = copy [A-Za-z ]+

This line declares a lens named 'l' using syntax based on
explicitly-typed OCaml (for the functional parts, like the let
declaration) and POSIX (for regular expressions). Its $\GET$ and $\PUT$
components both copy non-empty strings of alphabetic characters or
spaces.

\subsection{Unit Tests}

An easy way to interact with Boomerang is using its syntax for running
unit tests (other modes of interaction, such as batch processing of
files via the command line, are discussed below). For example, the
following test:

#* test l.get "Hello World" = ?

instructs the Boomerant interpreter to calculate the result obtained
by applying the $\GET$ component of @l@ to the string literal
@Hello World@ and print the result to the terminal 
(in fact, this unit test generated the output in the display above).

\begin{example}
  Try changing the @?@ above to @Hello World@. This changes the unit
  test from a calculation to an assertion, which silently succeeds.
\end{example}
\begin{example}
  Try changing the @?@ above to @HelloWorld@ instead. Now the
  assertion fails. You should see:
\begin{progeg}
File "./quickStart.src", line 68, characters 3-32: Unit test failed  
Expected "HelloWorld" but found "Hello World"
\end{progeg}
\end{example}
\noindent When you are done with this exercise, reinsert the space to
make the unit test succeed again.

Now let's examine the behavior of @l@'s $\PUT$ component.

#* test (l.put "HELLO WORLD" into "Hello World") = ?

You should see the following output printed to the terminal:
\begin{progeg}
Test Result:
HELLO WORLD
\end{progeg}
which reflects the change made to the abstract string.

\subsection{Type Checking}

The $\GET$ and $\PUT$ components of lenses check that their arguments have
the expected type. We can test this by passing an ill-typed string to
@l@'s GET component:

#* test (l.get "Hello World!!") = error

\begin{example}
  To see the error message that is printed by Boomerang, change the
  @error@ above to @?@ and re-run Boomerang. You should see the
  following message printed to the terminal:
\begin{progeg}
File "./QuickStart.src", line 107, characters 3-35: Unit test failed 
Test result: error
copy built-in: type errors in
  [Hello World]
<<HERE>>
  [!!]
\end{progeg}
Notice that Boomerang identifies a location in the
string where matching failed (<<HERE>>). When you are
done, change the @?@ back to @error@.
\end{example}

\section{The Composers Lens}

Now let's build a larger example. We will write a lens whose GET
function transforms newline-separated records of comma-separated data
about classical music composers:

#* let c : string = 
## <<
#* Jean Sibelius, 1865-1957, Finnish
#* Aaron Copland, 1910-1990, American
#* Benjamin Britten, 1913-1976, English
## >>

\noindent into comma-separated lines where the year data is deleted:
  
#* let a : string = 
## <<
#* Jean Sibelius, Finnish
#* Aaron Copland, American
#* Benjamin Britten, English
## >>

\subsection{Basic Composers Lens}

\noindent The lens that maps---bidirectionally---betweeen these
strings is written as follows:

#* let ALPHA : regexp = [A-Za-z ]+
#* let YEARS : regexp = [0-9]{4} . "-" . [0-9]{4}
#* let comp : lens = 
#*            ALPHA . ", "
#*          . del YEARS . del ", "
#*          . ALPHA
#* 
#* let comps : lens = "" | comp . (newline . comp)* 

We can check that @comp@ works as we expect using unit tests:

#* test comps.get c = a
#* test comps.put a into c = c

There are several things to note about this program. First, we have
use let-bindings to factor out repeated parts of programs, such as the
regular expression named @ALPHA@. This makes programs easier to read
and maintain. Second, operators like concatenation (@.@) automatically
promote their arguments, according to the following subtyping
relationships: $@string@ <: @regexp@ <: @lens@$. Thus, the string @", "@ 
is automatically promoted to the (singleton) regular expression
containing it, and the regular expression @ALPHA@ is automatically
promoted to the lens @copy ALPHA@.

\begin{example}
  Edit the @comp@ lens to abstract away the separator between fields
  and verify that your version has the same behavior on @c@ and @a@ by
  re-running Boomerang. Your program should look roughly like the
  following one:
\begin{progeg}
let comp (sep:string) : lens = ...
let comps : lens = 
  let comp_comma = comp ", " in
  ...
\end{progeg}
or, equivalently, one that binds @comp@ to an explicit
function:
\begin{progeg}
let comp : string -> lens = (fun (sep:string) -> ... )
\end{progeg}
\end{example}

\subsection{Dictionary Composers Lenses}

The behavior of @comps@ lens is not very satisfactory when the updated
abstract view is obtained by changing the order of lines. For example
if we swap the order of Britten and Copland, the year data from
Britten gets associated to Copland, and vice versa (@<< ... >>@ is
Boomerang syntax for a string literal in heredoc notation.)

#* test comps.put 
#* <<
#*   Jean Sibelius, Finnish
#*   Benjamin Britten, English
#*   Aaron Copland, American
#* >>
#* into
#* <<
#*   Jean Sibelius, 1865-1957, Finnish
#*   Aaron Copland, 1910-1990, American
#*   Benjamin Britten, 1913-1976, English
#* >>
#* = 
#* <<
#*   Jean Sibelius, 1865-1957, Finnish
#*   Benjamin Britten, 1910-1990, English
#*   Aaron Copland, 1913-1976, American
#* >>

The root of this problem is that the PUT function of the Kleene star
operator works positionally---it divides the concrete and abstract
strings into lines, and invokes the PUT of comp on each pair.

Our solution is to add new combinators for specifying reorderable
``chunks'' (@<comp>@) and a key for each chunk (@key ALPHA@). The
$\PUT$ function of the following lens:

#* let ALPHA : regexp = [A-Za-z ]+
#* let YEARS : regexp = [0-9]{4} . "-" . [0-9]{4}
#* let comp : lens = 
#*            key ALPHA . ", "
#*          . del YEARS . del ", "
#*          . ALPHA
#* 
#* let comps : lens = "" | <comp> . (newline . <comp>)* 

restores lines using the name on each line as a key, rather than by
position. For the details of how this all works, see~\citet{Boomerang07}. 
To verify it on this example, try out this unit test:

#* test comps.put 
#* <<
#*   Jean Sibelius, Finnish
#*   Benjamin Britten, English
#*   Aaron Copland, American
#* >>
#* into
#* <<
#*   Jean Sibelius, 1865-1957, Finnish
#*   Aaron Copland, 1910-1990, American
#*   Benjamin Britten, 1913-1976, English
#* >>
#* = ?

Note that the year data is correctly restored to each composer. 

