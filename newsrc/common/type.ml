(*******************************************************)
(* The Harmony Project                                 *)
(* harmony@lists.seas.upenn.edu                        *)
(*                                                     *)
(* type.ml - representation and functions on types     *)
(*                                                     *)
(* $Id: type.ml,v 1.1 2005/04/11 18:24:48 jnfoster Exp $ *)
(*                                                     *)
(*******************************************************)

open Pretty
    
(* TYPES *)
type state = Syntax.qid
type cstate = state * (state list) * (state list)

type t =
    Empty 
  | Name of string * cstate 
  | Star of (string list) * cstate      
  | Bang of (string list) * cstate            
  | Cat of t list 
  | Union of t list 

(* types *)
let string_of_cstate (x,is,ds) = 
  concat ""
    (Syntax.string_of_qid x::
       if (is = [] && ds = []) then []
       else
	 [ "&"; curlybraces (concat " " (List.map Syntax.string_of_qid is))
	 ; "-"; curlybraces (concat " " (List.map Syntax.string_of_qid ds))
	 ])
let rec string_of_type = function
  | Empty -> "empty"
  | Name(n,cx) -> concat "" [n; curlybraces (string_of_cstate cx)]
  | Bang(f,cx)  ->
      concat ""
    	[ "!"
    	; braces (concat " " f)
    	; curlybraces (string_of_cstate cx)]
  | Star(f,cx)  ->
	concat ""
    	  [ "*"
    	  ; braces (concat " " f)
    	  ; curlybraces (string_of_cstate cx)]
  | Cat(cs)   -> concat "." (List.map string_of_type cs)
  | Union(ts)  -> braces (concat " | " (List.map string_of_type ts))


(* (\* helper: map f everywhere on a type - not currently used *\) *)
(* let rec map_typ f t =  *)
(*   match t with *)
(*       TCat(i,cs)   -> f (TCat(i,(List.map (map_typ f) cs))) *)
(*     | TUnion(i,us) -> f (TCat(i,(List.map (map_typ f) us))) *)
(*     | _         -> f t *)

(* (\* a (somewhat arbitrary) order on types: used in t2nf *\) *)
(* let rec cmp_typ t1 t2 =  *)
(*   let eq = 0 in    (\* symbolic comparisons *\) *)
(*   let lt = -1 in *)
(*   let gt = 1 in *)

(*   (\* helper for comparing lists of things in dictionary order *\) *)
(*   let rec cmp_lex l1 l2 cmp_f =  *)
(*     let rec cmp_aux l1 l2 tie =  *)
(*       match (l1,l2) with *)
(* 	  ([],[])           -> tie *)
(* 	| (_,[])            -> gt *)
(* 	| ([],_)            -> lt *)
(* 	| (h1::t1),(h2::t2) -> *)
(* 	    if (tie = eq) then cmp_aux t1 t2 (cmp_f h1 h2) *)
(* 	    else cmp_aux t1 t2 tie *)
(*     in *)
(*       cmp_aux l1 l2 eq *)
(*   in *)
(*     match t1,t2 with *)
(*       (\* TName *\) *)
(*       | TEmpty(_),_                 -> lt *)
(*       | _,TEmpty(_)                 -> gt *)
(*       | TName(n1,_,_),TName(n2,_,_) -> compare n1 n2 *)
(*       | TName(_,_,_),_              -> lt *)

(*       (\* TBang *\) *)
(*       | TBang(_,_,_),TName(_,_,_)   -> gt *)
(*       | TBang(_,f1,_),TBang(_,f2,_)   -> cmp_lex f2 f1 compare *)
(*       | TBang(_,_,_),_               -> lt *)

(*       (\* TStar *\) *)
(*       | TStar(_,_,_),TName(_,_,_)    -> gt *)
(*       | TStar(_,_,_),TBang(_,_,_)     -> gt *)
(*       | TStar(_,f1,_),TStar(_,f2,_)   -> cmp_lex f2 f1 compare *)
(*       | TStar(_,_,_),_               -> lt *)
	
(*       (\* TCat *\) *)
(*       | TCat(_,_),TName(_,_,_)      -> gt *)
(*       | TCat(_,_),TBang(_,_,_)       -> gt  *)
(*       | TCat(_,_),TStar(_,_,_)       -> gt *)
(*       | TCat(_,cs1),TCat(_,cs2)     -> cmp_lex cs1 cs2 cmp_typ  *)
(*       | TCat(_,_),_                 -> lt *)
	  
(*       (\* TUnion *\) *)
(*       | TUnion(_,_),TName(_,_,_)    -> gt *)
(*       | TUnion(_,_),TBang(_,_,_)     -> gt *)
(*       | TUnion(_,_),TStar(_,_,_)     -> gt *)
(*       | TUnion(_,_),TCat(_,_)       -> gt *)
(*       | TUnion(_,us1),TUnion(_,us2) -> cmp_lex us1 us2 cmp_typ  *)

(* (\* sort a type list *\) *)
(* let sort_tl tl = List.sort cmp_typ tl  *)
	  
(* (\* sort a type *\) *)
(* let rec sort_typ t = match t with *)
(*   | TCat(i,ts)   -> TCat (i,sort_tl (List.map sort_typ ts)) *)
(*   | TUnion(i,us) -> TUnion (i,sort_tl (List.map sort_typ us)) *)
(*   | _         -> t *)

(* (\*** UTILITIES ***\) *)

(* (\* t2nf: convert a type to normal form *\) *)
(* (\* returns the new type and a list of new bindings *\) *)
(* let rec t2nf t delta = match t with  *)
(*   | TEmpty(_)     -> (t,[]) *)
(*   | TBang(_,_,_)   -> (t,[]) *)
(*   | TStar(_,_,_)   -> (t,[]) (\* should maybe think about normalizing empty TStars as TEmptyViews *\) *)
(*   | TName(_,_,_)  -> (t,[]) *)

(*   (\* unions: *)
(*      - recursively normalize *)
(*      - lift nested unions *)
(*      - remove TEmpty from unions *)
(*   *\) *)
(*   | TUnion(i,us)  ->        *)
(*       let (usnf,newbinds) =  *)
(* 	List.fold_left  *)
(* 	  (fun (usnf,newbinds) ui ->  *)
(* 	     let (uinf,uibinds) = t2nf ui (delta @ newbinds )in *)
(* 	       (uinf::usnf, uibinds @ newbinds)) *)
(* 	  ([],[]) *)
(* 	  us *)
(*       in *)
(*       let lift_us =  *)
(* 	(List.fold_left  *)
(* 	   (fun acc h -> *)
(* 	      match h with  *)
(* 		| TEmpty(_)    -> acc    (\* skip TEmpty bits of unions *\) *)
(* 		| TUnion(i,us) -> us@acc (\* lift nested unions *\) *)
(* 		| _            -> h::acc) *)
(* 	   [] *)
(* 	   usnf)  *)
(*       in  *)
(*       let tres =  *)
(* 	(match lift_us with	   *)
(* 	   | []              -> TEmpty(i) *)
(* 	   | [(TCat (_,[]))] -> TEmpty(i) *)
(* 	   | _               -> sort_typ (TUnion(i,lift_us))) *)
(*       in  *)
(* 	(tres, newbinds) *)
	  
(*   (\* TCat: *)
(*      - recursively normalize cs *)
(*      - lift nested cats in cs  *)
(*      - distribute nested unions over cats *)
(*      - sort result *)
(*      - if a name is repeated, then TEmpty *)
(*   *\) *)
(*   | TCat(i,cs)    ->  *)
(*       let (csnf,newbinds) =  *)
(* 	List.fold_left  *)
(* 	  (fun (csnf,newbinds) ci ->  *)
(* 	     let (cinf,cibinds) = t2nf ci (delta @ newbinds) in *)
(* 	       (cinf::csnf, (cibinds @ newbinds))) *)
(* 	  ([],[]) *)
(* 	  cs *)
(*       in *)
	
(*       (\* temporarily represent the lifted union of cats as a list of lists *\) *)
(*       let lift_us_rep =  *)
(* 	List.fold_left *)
(* 	  (fun acc h -> *)
(* 	     (\* helper functions for readability *\) *)
(* 	     let prepend s a = List.map (fun x -> sort_tl (s::x)) a in *)
(* 	     let concat cs a = List.map (fun x -> sort_tl (x @ cs)) a in *)
(* 	       match h with *)
(* 		 | TCat(_,cs)   -> concat cs acc (\* lift nested cats *\) *)
(* 		 | TUnion(_,us) ->  *)
(* 		     (\* distribute unions, lift deep-nested cats *\) *)
(* 		     List.flatten  *)
(* 		       (List.map  *)
(* 			  (fun u -> match u with *)
(* 			     | TCat(_,cs) -> concat cs acc *)
(* 			     | _          -> prepend u acc) us) *)
(* 		 | _         -> prepend h acc) *)
(* 	  [[]] *)
(* 	  csnf *)
(*       in *)
(*       let check_repeats t =  *)
(* 	let rec cr_aux cs info acc =  *)
(* 	  match cs with *)
(* 	    | []                                            ->  *)
(* 		TCat (info,(List.rev acc)) *)
(* 	    | TName(n,_,_)::TName(m,_,_)::rest when (n = m) ->  *)
(* 		TEmpty(info) *)
(* 	    | TStar(i,f,x)::TStar(_,_,y)::rest when (x=y)     -> *)
(* 		cr_aux ((TStar(i,f,x))::rest) info acc *)
(* 	    | TStar(_,_,_)::TStar(i,_,_)::rest                -> *)
(* 		raise (Error.Type_error("repeated wildcard ~ in type", i)) *)
(* 	    | h::t                                          ->  *)
(* 		cr_aux t info (h::acc)  *)
(* 	in *)
(* 	  match t with *)
(* 	      TCat(i,cs) -> cr_aux cs i [] *)
(* 	    | t          -> t *)
(*       in *)
(*       let tres =  *)
(* 	match lift_us_rep with	     *)
(* 	  | [[]]              -> TEmpty(i) (\* recognize some empty types *\) *)
(* 	  | [[TEmpty(_)]]     -> TEmpty(i) *)
(* 	  | [[(TCat (_,[]))]] -> TEmpty(i) *)
(* 	  | [[t]]             -> check_repeats t *)
(* 	  | [cs]              -> check_repeats (TCat (i,cs)) *)
(* 	  | _                 ->  *)
(* 	      TUnion (i, List.map (fun x -> check_repeats (TCat (i,x))) lift_us_rep) *)
(*       in *)
(* 	(tres,newbinds) *)
	  
(* let normalize_ctx delta =    *)
(*   let delta1,newbinds =  *)
(*     (List.fold_left  *)
(*        (fun (deltaacc,newbinds) (x,i,t) -> *)
(* 	  let (t1,tbinds) = t2nf t (delta @ newbinds) in *)
(* 	    ((x,i,t1)::deltaacc, (tbinds @ newbinds))) *)
(*        ([],[]) *)
(*        delta) *)
(*   in *)
(*     (List.rev delta1) @ (List.rev newbinds) *)
    
(* (\* more functions *\) *)
(* let rec project t n =  *)
(*   debug ("--- PROJECT --- " ^ n ^ " from t=" ^ (t2str t)); *)
(*   let res =  *)
(*     match t with *)
(*       | TEmpty(_)     -> None *)
(*       | TName(_,m,x)  -> if (n=m) then Some x else None *)
(*       | TBang(_,f,x)   -> if (List.mem n f) then None else Some x *)
(*       | TStar(_,f,x)   ->  *)
(* 	  if (List.mem n f) then None  *)
(* 	  else Some x *)
(*       | TUnion(_,ts) ->  *)
(* 	  List.fold_left  *)
(* 	    (fun xo ti -> match xo with *)
(* 		 None -> project ti n *)
(* 	       | Some x ->  *)
(* 		   let to2str t =  *)
(* 		     match t with *)
(* 			 None -> "NONE" *)
(* 		       | Some t -> cs2str t *)
(* 		   in *)
(* 		   let tin = project ti n in *)
(* 		     (match tin with *)
(* 			  None -> xo *)
(* 			| Some _ ->  *)
(* 			    if tin = xo then xo *)
(* 			    else *)
(* 			      (Format.printf  *)
(* 				 "ERROR: type is not projectable because %s <> %s \n" *)
(* 				 (to2str tin) *)
(* 				 (to2str xo);			        *)
(* 			       assert false))) *)
(* 	    None  *)
(* 	    ts *)
(*       | TCat(_,cs) ->  *)
(* 	  List.fold_left  *)
(* 	    (fun xo ti -> match xo with *)
(* 		 None -> project ti n *)
(* 	       | Some _ -> xo) *)
(* 	    None  *)
(* 	    cs *)
(*   in *)
(*   let _ = debug ("res = " ^ (match res with *)
(* 				 None -> "NONE" *)
(* 			       | Some x -> cs2str x)) in *)
(*     res *)

(* (\* the unfold operator *\) *)
(* let rec unfold cx delta = match cx with *)
(*     (x,[],[]) -> Syntax.lookup x delta *)
(*   | _         -> debug "ERROR: unfold not implemented for complex type states"; assert false *)
(* (\* *)
(*   | (x,y::t,ds) ->  *)
(*       let dy = lookup y delta in *)
(*       let ux = unfold (x,t,ds) delta in *)
(* 	diff (TUnion ([ux; dy],bogusI)) (TUnion ([diff ux dy; diff dy ux],bogusI)) *)
(*   | (x,[],y::t) -> diff (unfold (x,[],t) delta) (lookup y delta) *)
(* *\)  *)
     
(* (\* check if v in t *\) *)
(* let rec member v t delta =  *)
(*   let _ = debug ("\n--MEMBER--\nt=" *)
(* 		 ^ (t2str t) *)
(* 	         ^ "\nv="); debug_view v in *)
(*   let _ = debug ("\nDELTA =\n" ^ (defs2str delta)) in *)
(*     match t with		 *)
(*       | TEmpty(_)    ->  *)
(* 	  debug "\nin TEmpty\nANSWER to TBang = false"; *)
(* 	  false *)
(*       | TName(_,n,x) -> *)
(* 	  debug ("\nin TName for " ^ n); *)
(* 	  let d = V.dom v in *)
(* 	  let c = Name.Set.cardinal d in *)
(* 	  let res = (c = 1) &&  *)
(* 		    (match V.get v n with *)
(* 		       | None -> false *)
(* 		       | Some vn -> member vn (unfold x delta) delta) *)
(* 	  in *)
(* 	  let _ = debug ("ANSWER to TName: " ^ (t2str t) ^ " = " ^ (string_of_bool res)) in *)
(* 	    res *)
(*       | TBang(_,f,x) -> *)
(* 	  let _ = debug "\nin TBang" in	   *)
(* 	  let d = V.dom v in *)
(* 	  let res =  *)
(* 	    match Name.Set.cardinal d with *)
(* 	      | 1 ->  *)
(* 		  let k = Name.Set.choose d in		    *)
(* 		    (not (List.mem k f))  *)
(* 		    && (member  *)
(* 			  (V.get_required v k)  *)
(* 			  (unfold x delta)  *)
(* 			  delta) *)
(* 	      | _ -> false *)
(* 	  in *)
(* 	  let _ = debug ("ANSWER to TBang: " ^ (t2str t) ^ " = " ^ (string_of_bool res)) in *)
(* 	    res *)
(*       | TStar(_,f,x) ->  *)
(* 	  debug "\nin TStar"; *)
(* 	  let ux = unfold x delta in *)
(* 	  let res = Name.Set.fold  *)
(* 	      (fun k okSoFar -> *)
(* 		 okSoFar && *)
(* 		 (not (List.mem k f)) && *)
(* 		 (member (V.get_required v k) ux delta))	   *)
(* 	      (V.dom v) *)
(* 	      true	   *)
(* 	  in  *)
(* 	  let _ = debug ("ANSWER to TStar : " ^ (t2str t) ^ " = " ^ (string_of_bool res)) in *)
(* 	    res *)
(*       | TUnion (_,us) ->  *)
(* 	  let _ = debug "\nin TUnion" in *)
(* 	  let res =  *)
(* 	    List.fold_left *)
(* 	      (fun acc ui -> *)
(* 		 if acc then true  *)
(* 		 else member v ui delta) *)
(* 	      false *)
(* 	      us *)
(* 	  in *)
(* 	  let _ = debug ("ANSWER to TUnion: "  ^ (t2str t) ^ " = " ^ (string_of_bool res)) in *)
(* 	    res *)
(*       | TCat (_,cs) ->  *)
(* 	  let _ = debug "\nin TCat" in *)
(* 	  (\* this split does not work in general...  *)
(* 	     just for testing some easy cases *\) *)
(* 	  let split v t  =  *)
(* 	    match t with *)
(* 	      | TEmpty(_)     -> (None, v) *)
(* 	      | TName(_,n,x) ->  *)
(* 		  (match V.get v n with *)
(* 		     | None       -> (None, v) *)
(* 		     | Some vn    -> (Some (vn,x), V.set v n None)) *)
(* 	      | TBang(_,f,x)  ->  *)
(* 		  let n = Name.Set.choose (V.dom v) in *)
(* 		  let vn = V.get_required v n in *)
(* 		    if (List.mem n f) then (None, v) *)
(* 		    else (Some (vn,x), V.set v n None) *)
(* 	      | TStar(_,f,x)  -> (Some (v,x), V.empty) *)
(* 	      | _            ->  *)
(* 		  debug ("ERROR: the impossible happened. Non-atomic type in TCat; t=" ^ (t2str t)); *)
(* 		  assert false (\* can't happen *\) *)
(* 	  in *)
(* 	  let rec loop cs v =  *)
(* 	    (\** let _ = debug ("\n--LOOP--\n t=" *)
(* 	      ^ (tl2str cs) *)
(* 	      ^ " v=") in *)
(* 	      let _ = V.format v in	       *)
(* 	    **\) *)
(* 	    if (V.is_empty v) then  *)
(* 	      (\* all the cs must be TStars *\) *)
(* 	      List.fold_left (fun ok h -> match h with TStar _ -> ok | _ -> false) true cs *)
(* 	    else *)
(* 	      match cs with *)
(* 		| []   -> false *)
(* 		| [ci] -> member v ci delta *)
(* 		| ci::rest ->  *)
(* 		    match split v ci with *)
(* 		      | (None,_)             -> false *)
(* 		      | (Some (vk,x), vrest) -> *)
(* 			  let tx = unfold x delta in *)
(* 			    (member vk tx delta ) && (loop rest vrest) *)
(* 	  in *)
(* 	  let res = loop cs v *)
(* 	  in *)
(* 	  let _ = debug ("ANSWER to TCat: "  ^ (t2str t) ^ " = " ^ (string_of_bool res)) in *)
(* 	    res *)

(* (\* (\\* Nice interface to the parser/compiler for types *\\) *\) *)
(* (\* let string2abstract_type deltastr =  *\) *)
(* (\*   try  *\) *)
(* (\*     let lexbuf = Lexing.from_string deltastr in *\) *)
(* (\*     let pdefs = Parser.pdefs Lexer.type_token lexbuf in *\) *)
(* (\*     let delta1 = pctx2ctx pdefs in *\) *)
(* (\*     let delta = normalize_ctx delta1 in *\) *)
(* (\*     let ty =  *\) *)
(* (\*       match pdefs with  *\) *)
(* (\* 	  [] -> Syntax.TEmpty Error.bogusInfo *\) *)
(* (\* 	| ((x,_,_)::_) -> unfold (x,[],[]) delta  *\) *)
(* (\*     in *\) *)
(* (\*       (delta,ty)	 *\) *)
(* (\*   with *\) *)
(* (\*       e ->  *\) *)
(* (\* 	Format.printf "ERROR in string2abstract_type for:\n%s\n" deltastr;  *\) *)
(* (\* 	raise e *\) *)

(* (\************* DEPRECATED / UNFINISHED STUFF **************************\) *)
(* (\* let setUnion x f =  if (List.mem x f) then f else x::f *\) *)
(* (\* *\) *)
(* (\* (\\* symbolic diff on two cstates *\\) *\) *)
(* (\* let rec csdiff cx cy = *\) *)
(* (\*   let (x,ix,dx) = cx in *\) *)
(* (\*     match cy with *\) *)
(* (\*       | (z,[],[])    ->  *\) *)
(* (\* 	  if (z = x || List.mem z ix) then [] *\) *)
(* (\* 	  else [(x,ix,setUnion z dx)] *\) *)
(* (\*       | (z,i::is,ds) ->  *\) *)
(* (\* 	  let rest = csdiff cx (z,is,ds) in *\) *)
(* (\* 	    if (z = x || List.mem z ix) then rest *\) *)
(* (\* 	    else (x,ix,setUnion z dx)::rest *\) *)
(* (\*       | (z,[],d::ds) ->  *\) *)
(* (\* 	  let rest = csdiff cx (z,[],ds) in *\) *)
(* (\* 	    if (List.mem d dx) then rest  *\) *)
(* (\* 	    else if (x = d) then cx::rest  *\) *)
(* (\* 	    else (x,setUnion d ix,dx)::rest *\) *)
(* (\* *\) *)
(* (\* (\\* the diff operator *\\) *\) *)
(* (\* let rec diff t1 t2 =  *\) *)
(* (\*   (\\** let _ = debug ("diffing: " ^ t2str t1 ^ ", " ^ t2str t2) in **\\) *\) *)
  
(* (\*   (\\* compute normal forms *\\) *\) *)
(* (\*   let nt1,nt2 = t2nf t1, t2nf t2 in     *\) *)
    
(* (\*   (\\* lift a list of cstates to a list of things generated by f *\\) *\) *)
(* (\*   let liftCSUnions cus f =  *\) *)
(* (\*     match cus with *\) *)
(* (\* 	[]  -> [TEmpty(bogusI)] *\) *)
(* (\*       | [z] -> [f z] *\) *)
(* (\*       | _   -> (List.map f cus) *\) *)
(* (\*   in *\) *)
(* (\*   let mkNs f1 f2 x info = *\) *)
(* (\*     List.map  *\) *)
(* (\*       (fun n -> TName(n,x,info)) *\) *)
(* (\*       (List.filter (fun n -> not (List.mem n f1)) f2) *\) *)
(* (\*   in *\) *)

(* (\*   (\\* helper: used whenever we have to split a TCat *\\) *\) *)
(* (\*   (\\* NB: cs1 and cs2 are assumed to be in nf--i.e., consist of TNames, *\) *)
(* (\*      TBang, and at most one TStar in that order! *\\) *\) *)
(* (\*   let split_case cs1 cs2 info =  *\) *)
(* (\*     let divide cs =  *\) *)
(* (\*       List.fold_left *\) *)
(* (\* 	(fun (names,anys,alls) h -> *\) *)
(* (\* 	   match h with *\) *)
(* (\* 	       TName(_,_,_) -> (h::names,anys,alls) *\) *)
(* (\* 	     | TBang(_,_,_)  -> (names,h::anys,alls) *\) *)
(* (\* 	     | TStar(_,_,_)  -> (names,anys,h::alls) *\) *)
(* (\* 	     | _          ->  *\) *)
(* (\* 		 (\\* can't happen *\\) *\) *)
(* (\* 		 raise (Error.Type_error("Type not in normal form: " ^ (t2str h), *\) *)
(* (\* 					t2info h)) *\) *)
(* (\* 	) ([],[],[]) cs *\) *)
(* (\*     in *\) *)
(* (\*     let (ns1,ys1,ls1),(ns2,ys2,ls2) = divide cs1, divide cs2 in *\) *)
      
(* (\*     (\\* the split operator - iterates all the perfect matchings *\\) *\) *)
(* (\*     let rec split cs1 cs2 cover acc =  *\) *)
(* (\*       (\\**  *\) *)
(* (\* 	let _ = debug ("--SPLIT--\n cs1=" *\) *)
(* (\* 	^ (tl2str cs1) *\) *)
(* (\* 	^ " cs2=" *\) *)
(* (\* 	^ (tl2str cs2) *\) *)
(* (\* 	^ " cover=" *\) *)
(* (\* 	^ (if cover = [] then "[]"  *\) *)
(* (\* 	else (List.fold_right  *\) *)
(* (\* 	(fun (n,x) ta -> "(" ^ n ^ ", " ^ (cs2str x) ^ ") " ^ ta) *\) *)
(* (\* 	cover "")) *\) *)
(* (\* 	^ " acc=" *\) *)
(* (\* 	^ tpl2str acc) in  *\) *)
(* (\*       **\\) *\) *)
(* (\*       match cs1,cs2 with *\) *)
(* (\*       | (TName(n,x,i1)::tl1, TName(m,y,i2)::tl2) ->  *\) *)
(* (\* 	  if m = n then split tl1 tl2 cover ((TName(n,x,i1),TName(m,y,i2))::acc) *\) *)
(* (\* 	  else split tl1 tl2 ((n,x)::cover) acc *\) *)
(* (\*       | (TName(n,x,_)::tl1, TBang(f,y,_)::tl2) -> split tl1 cs2 ((n,x)::cover) acc *\) *)
(* (\*       | (TName(n,x,_)::tl1, TStar(f,y,_)::tl2) -> split tl1 cs2 ((n,x)::cover) acc *\) *)
(* (\*       | (TName(n,x,i)::tl1, [])             -> split tl1 [] ((n,x)::cover) acc *\) *)
(* (\*       | [],[]                             -> *\) *)
(* (\* 	  if (cover = []) then acc  *\) *)
(* (\* 	  else  *\) *)
(* (\* 	    (List.map (fun (n,x) -> (TName(n,x,bogusI),TEmpty(bogusI))) cover)  *\) *)
(* (\* 	    @ (List.map (fun (t,_) -> (t,TEmpty(bogusI))) acc) *\) *)
(* (\*       | _ ->  *\) *)
(* (\* 	  raise (Error.Type_error("unimplemented case in split", bogusI)) *\) *)
(* (\*    in  *\) *)
      
(* (\*     let splits = split cs1 cs2 [] [] in       *\) *)
(* (\*     let diff_pairs = List.map (fun (t1,t2) -> (t1,diff t1 t2)) splits in *\) *)

(* (\*     (\\** *\) *)
(* (\*       let _ = debug ("splits=" ^ (tpl2str splits)) in       *\) *)
(* (\*       let _ = debug ("diff_pairs=" ^ (tpl2str diff_pairs)) in *\) *)
(* (\*     **\\) *\) *)
(* (\*     (\\* ugly hack alert! - we should fold this fold in somewhere else :) *\\)  *\) *)
(* (\*     let all_diffs_empty =  *\) *)
(* (\*       List.fold_left (fun a (_,d) ->  *\) *)
(* (\* 		     match d with  *\) *)
(* (\* 		       | TEmpty _ -> a *\) *)
(* (\* 		       | _        -> false) *\) *)
(* (\* 	true splits *\) *)
(* (\*     in *\) *)

(* (\*     (\\* helper: append t to all the lists in acc IF acc non-empty *\\) *\) *)
(* (\*     let rec app t acc =  *\) *)
(* (\*       match acc with *\) *)
(* (\* 	| []      -> [] *\) *)
(* (\* 	| h::rest -> (h@[t])::(app t rest) *\) *)
(* (\*     in       *\) *)
      
(* (\*     (\\* hideous code. JNF takes blame :) *\\) *\) *)
(* (\*     let diag_diff_matrix =  *\) *)
(* (\*       snd  *\) *)
(* (\* 	(List.fold_left  *\) *)
(* (\* 	   (fun (ts,acc) (t,d) -> *\) *)
(* (\* 	      let newacc = app t acc in *\) *)
(* (\* 		(ts@[t]), *\) *)
(* (\* 		match d with  *\) *)
(* (\* 		    TEmpty _ -> newacc  *\) *)
(* (\* 		  | _ -> (ts@[d])::newacc) *\) *)
(* (\* 	   ([],[]) *\) *)
(* (\* 	   diff_pairs) *\) *)
(* (\*     in *\) *)
      
(* (\*       (\\* need to factor out code from t2nf and here *\\) *\) *)
(* (\*       if (all_diffs_empty) then nt1 *\) *)
(* (\*       else 	 *\) *)
(* (\* 	let cs =  *\) *)
(* (\* 	  List.map (fun x -> TCat(x,info)) diag_diff_matrix in *\) *)
(* (\* 	  t2nf (TUnion(cs,info)) *\) *)
(* (\*   in *\) *)
(* (\*     match nt1,nt2 with *\) *)

(* (\*       (\\* the "easy" cases *\\) *\) *)
(* (\*       | TEmpty(_),_               -> nt1 *\) *)
(* (\*       | _,TEmpty(_)               -> nt1 *\) *)
(* (\*       | TUnion(us,i),_         -> t2nf (TUnion ((List.map (fun ui -> diff ui t2) us),i)) *\) *)
(* (\*       | _,TUnion(us,_)         -> t2nf (List.fold_left (fun t ui -> diff t ui) t1 us) *\) *)
(* (\*       | TCat(_,_),TName(_,_,_) -> nt1 *\) *)
(* (\*       | TCat(_,_),TBang(_,_,_)  -> nt1 *\) *)

(* (\*       | TCat(cs1,i),TStar(f,y,_) -> split_case cs1 [nt2] i *\) *)
(* (\*       | TCat(cs1,i),TCat(cs2,_) -> split_case cs1 cs2 i *\) *)
	    
(* (\*       (\\* base cases *\\) *\) *)
(* (\*       | TName(n,x,i),TName(m,y,_) ->  *\) *)
(* (\* 	  if (n <> m) then nt1 *\) *)
(* (\* 	  else t2nf (TUnion ((liftCSUnions (csdiff x y) (fun z -> TName(n,z,i))),i)) *\) *)

(* (\*       | TName(n,x,i),TBang(f,y,_)  -> *\) *)
(* (\* 	  if (List.mem n f) then nt1 *\) *)
(* (\* 	  else t2nf(TUnion ((liftCSUnions (csdiff x y) (fun z -> TName(n,z,i))),i)) *\) *)

(* (\*       | TName(n,x,i),TStar(f,y,_)  -> *\) *)
(* (\* 	  if (List.mem n f) then nt1 *\) *)
(* (\* 	  else t2nf (TUnion ((liftCSUnions (csdiff x y) (fun z -> TName(n,z,i))),i)) *\) *)

(* (\*       | TName(n,x,_),TCat(ts,_) -> nt1 *\) *)
	  
(* (\*       | TBang(f,x,i),TName(m,y,_)  ->  *\) *)
(* (\* 	  if (List.mem m f) then nt1 *\) *)
(* (\* 	  else  *\) *)
(* (\* 	    t2nf(TUnion ((TBang(setUnion m f,x,i):: *\) *)
(* (\* 			    (liftCSUnions  *\) *)
(* (\* 			       (csdiff x y)  *\) *)
(* (\* 			       (fun z -> TName(m,z,i)))),i)) *\) *)

(* (\*       | TBang(f,x,i),TBang(g,y,_)   -> *\) *)
(* (\* 	  t2nf (TUnion (( *\) *)
(* (\* 		  (mkNs f g x i) @ *\) *)
(* (\* 			  (liftCSUnions  *\) *)
(* (\* 			     (csdiff x y)  *\) *)
(* (\* 			     (fun z -> TBang(f@g,z,i))) *\) *)
(* (\* 			),i)) *\) *)
	    
(* (\*       | TBang(f,x,i),TStar(g,y,_)   -> *\) *)
(* (\* 	  t2nf(TUnion (( *\) *)
(* (\* 		 (mkNs f g x i) @ *\) *)
(* (\* 		 (liftCSUnions  *\) *)
(* (\* 		    (csdiff x y)  *\) *)
(* (\* 		    (fun z -> TBang(f@g,z,i))) *\) *)
(* (\* 	    ),i)) *\) *)

(* (\*       | TBang(f,x,_),TCat(ts,_)     -> nt1 *\) *)

(* (\*       | TStar(f,x,i),TName(m,y,_)  -> *\) *)
(* (\* 	  if (List.mem m f) then nt1 *\) *)
(* (\* 	  else *\) *)
(* (\* 	    t2nf ( *\) *)
(* (\* 	      TUnion (( *\) *)
(* (\* 		(liftCSUnions (csdiff x y) (fun z -> (TName(m,z,i)))) *\) *)
(* (\* 		@[(\\* emptyViewType; *\\)TBang(setUnion m f,x,i); TCat ([TBang(f,x,i); TBang(f,x,i); TStar(f,x,i)],i)] *\) *)
(* (\* 	      ),i)) *\) *)

(* (\*       | TStar(f,x,i),TBang(g,y,_)   -> *\) *)
(* (\* 	  t2nf ( *\) *)
(* (\* 	    TUnion(( *\) *)
(* (\* 	      (liftCSUnions (csdiff x y) (fun z -> (TBang(f,z,i)))) *\) *)
(* (\* 	      @ (mkNs f g x i) *\) *)
(* (\* 	      @ [(\\* emptyViewType; *\\) TCat([TBang(f,x,i); TStar(f,x,i)],i)]	  	   *\) *)
(* (\* 	    ),i)) *\) *)

(* (\*       | TStar(f,x,i),TStar(g,y,_)   -> *\) *)
(* (\* 	  t2nf ( *\) *)
(* (\* 	    TCat((TBang(f,x,i)::[TUnion(( *\) *)
(* (\* 			       (liftCSUnions (csdiff x y) (fun z -> (TBang(f,z,i)))) *\) *)
(* (\* 			       @ (mkNs f g x i)),i)]),i) *\) *)
(* (\* 	  ) *\) *)
(* (\*       | TStar(f,x,i),TCat(cs2,_) -> split_case [nt1] cs2 i *\) *)



(* (\* insert CK's algorithm here *\) *)
(* (\* let is_empty g x = false *\) *)


(* (\* --- CK added from here --- *\) *)

(* (\* *)
(* type tdom_atom = *)
(*     DAny of Name.Set.t *)
(*   | DAll of Name.Set.t *)
(*   | DName of name *)
      
(* let cmp_tdom_atom a1 a2 = *)
(*   let lt = -1 in *)
(*   let gt = 1 in *)
(*     match a1,a2 with *)
(* 	(\* DAny *\) *)
(* 	DAny(s1), DAny(s2)   -> Name.Set.compare s1 s2 *)
(*       | DAny(_), DAll(_)     -> lt *)
(*       | DAny(_), DName(_)    -> lt *)
(*         (\* DAll *\) *)
(*       | DAll(_), DAny(_)     -> gt *)
(*       | DAll(s1), DAll(s2)   -> Name.Set.compare s1 s2  *)
(*       | DAll(_), DName(_)    -> lt *)
(*         (\* DName *\) *)
(*       | DName(_), DAny(_)    -> gt *)
(*       | DName(_), DAll(_)    -> gt *)
(*       | DName(n1), DName(n2) -> compare n1 n2 *)
	  
(* module TDomAtomSet = Set.Make(struct *)
(* 				type t = tdom_atom *)
(* 				let compare = cmp_tdom_atom *)
(* 			      end) *)
  
(* module TDom = Set.Make(struct *)
(* 			 type t = TDomAtomSet.t *)
(* 			 let compare = compare *)
(* 		       end)   *)

(* let nfcheck tbase f t =  *)
(*   match tbase with *)
(*       TCat(_,i) -> *)
(* 	(match t with *)
(* 	     TCat(_,_) | TUnion(_,_) -> raise (Error.Type_error("Type not normal formed",i))  *)
(* 	   | _ -> f t) *)
(*     | TUnion(_,i) ->  *)
(* 	(match t with  *)
(* 	     TUnion(_,_) -> raise (Error.Type_error("Type not normal formed",i))  *)
(* 	   | _ -> f t) *)
(*     | _ -> f t *)
    
  		    
(* let rec tdom t = *)
(*   let nameset lst =  *)
(*     List.fold_left (fun ns n -> Name.Set.add n ns) Name.Set.empty lst *)
(*   in  *)
(*   let shallow_union f lst =  *)
(*     List.fold_left (fun acc td -> TDom.union acc (f td)) TDom.empty lst      *)
(*   in *)
(*   let deep_union f lst =  *)
(*     TDom.singleton (TDom.fold (fun acc d -> TDomAtomSet.union acc d) (shallow_union f lst) TDomAtomSet.empty) *)
(*   in *)
(*     match t with *)
(* 	TUnion(tl,_)  -> shallow_union (nfcheck t tdom) tl *)
(*       | TCat(tl,_)    -> deep_union (nfcheck t tdom) tl *)
(*       | TName(m,x,_)  -> TDom.singleton (TDomAtomSet.singleton (DName(m)))  *)
(*       | TBang(f,x,_)   -> TDom.singleton (TDomAtomSet.singleton (DAny(nameset f)))  *)
(*       | TStar(f,x,_)   -> TDom.singleton (TDomAtomSet.singleton (DAll(nameset f)))  *)
(*       | TEmpty(_)     -> TDom.empty *)
	  
(* (\* It is assumed that precisely one tdom_atom in a tdas matches a *)
(*    given name - is this always true for normalized types? Especially, *)
(*    how do we restrict ![f2] and *[f1] from overlapping? If the *)
(*    assumption is false then these functions must be generalized to *)
(*    somehow find the best global match - this should be possible using *)
(*    the "max matching in bipartite graph" algorithm *\) *)

(* let tdas_match tdas n =  *)
(*   TDomAtomSet.fold  *)
(*     (fun tda ao -> *)
(*        match tda with *)
(* 	   DAny s -> if Name.Set.mem n s then ao else Some tda  *)
(* 	 | DAll s -> if Name.Set.mem n s then ao else Some tda  *)
(* 	 | DName m -> if n=m then Some tda else ao)  *)
(*     tdas  *)
(*     None *)
    
(* let tdas_diff tdas ns =  *)
(*   (Name.Set.fold  *)
(*      (fun n (tdas',ns') ->  *)
(* 	match (tdas_match tdas' n) with *)
(* 	    None -> (tdas',ns') *)
(* 	  | Some a -> (TDomAtomSet.remove a tdas',Name.Set.remove n ns'))  *)
(*      ns  *)
(*      (tdas,ns)) *)
    
(* let tdas_inter tdas ns = *)
(*   (Name.Set.fold  *)
(*      (fun n (tdas',ns') ->  *)
(* 	match (tdas_match tdas' n) with *)
(* 	    None -> (tdas',ns') *)
(* 	  | Some tda -> (TDomAtomSet.add tda tdas',Name.Set.add n ns'))  *)
(*      ns  *)
(*      (TDomAtomSet.empty,Name.Set.empty)) *)
    
(* let tdas_matches_empty tdas =  *)
(*   TDomAtomSet.fold (fun tda b ->  *)
(* 		      match tda with *)
(* 			  DAny _   -> b  *)
(* 			| DAll _   -> false *)
(* 			| DName _  -> false *)
(* 		   ) tdas true *)
    
(* let tdas_matches tdas ns =  *)
(*   let (tdas',rest) = tdas_diff tdas ns in *)
(*     tdas_matches_empty tdas' && Name.Set.is_empty rest  *)
      
(* let maxdom t o a b =  *)
(*   let dom_o = V.dom o in *)
(*   let dom_a = V.dom a in *)
(*   let dom_b = V.dom b in *)
(*   let (unchanged,changed) = Name.Set.partition (fun n -> V.equal_opt (V.get o n) (V.get a n)) dom_a in  *)
(*   let remove = Name.Set.diff (Name.Set.inter dom_a unchanged) dom_b in *)
(*   let add = Name.Set.diff dom_b (Name.Set.union dom_o dom_a) in *)
(*   let diffs = Name.Set.union remove add in  *)
(*   let cmp tdas md =   *)
(*     let tdas' = fst (tdas_diff tdas changed) in *)
(*     let d = Name.Set.union changed (snd (tdas_inter tdas' diffs)) in *)
(*       if  *)
(* 	(tdas_matches tdas d) &&  *)
(* 	(Name.Set.cardinal d > Name.Set.cardinal md) *)
(*       then  *)
(* 	d *)
(*       else *)
(* 	md	   *)
(*   in  *)
(*     TDom.fold cmp (tdom t) Name.Set.empty *)
(* *\) *)
      
(* (\* --- CK added to here --- *\) *)
