module Pervasives = 

(* common schemas *)
type List T = { "*h" = T, "*t" =(List T) } 
type Any = *{Any}

(* derived lenses *)
let fork (p:view) = xfork p p

let mapp (p:view) (l:lens) = fork p (map l) id 

let filter (p:view) (d:view) = fork p id (const {} d)

let prune (n:name) (d:view) = fork {n} (const {} {n=d}) id

let add (n:name) (v:view) = xfork {} {n} (const v {} ; plunge n) id

let focus (n:name) (d:view) = filter {n} d ; hoist n

let hoist_nonunique (n:name) (p:view) = xfork {n} p (hoist n) id 

let rename (m:name) (n:name) = xfork {m} {n} (hoist m;plunge n) id

let hd (d:view) = focus "*h" { "*t" = d }

let tl (d:view) = focus "*t" { "*h" = d }

let list_map (l:lens) : lens = wmap { "*h" -> l, "*t" -> (list_map l) }

let acond (c:type) (a:type) (lt:lens) (lf:lens) = cond_ww c a <~a> lt lf

let ccond (c:type) (lt:lens) (lf:lens) = cond c Any Any id id lt lf

let rename_if_present (m:name) (n:name) = 
    acond <m{Any},*{Any}> <n{Any},*{Any}>
      (rename m n)
      id


