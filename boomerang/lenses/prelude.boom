(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007-2008                                                     *)
(* J. Nathan Foster, Alexandre Pilkiewicz, and Benjamin C. Pierce              *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/prelude.boom                                              *)
(* Boomerang definitions of lens primitives                                    *)
(* $Id$ *)
(*******************************************************************************)

module Prelude =

(* polymorphic operators *)
let copy : {'a:string,regexp,lens} => 'a -> lens = 
  Native.Prelude.copy
let const : {'a:string,regexp} => 'a -> string -> string -> lens = 
  Native.Prelude.const 
let shortest : {'a:string,regexp} => 'a -> string = 
  Native.Prelude.shortest
let poly_concat : {'a:string,regexp,lens,canonizer} => 'a -> 'a -> 'a = 
  Native.Prelude.poly_concat
let poly_union : {'a:string,regexp,lens,canonizer} => 'a -> 'a -> 'a =
  Native.Prelude.poly_union
let poly_iter : {'a:regexp,lens,canonizer} => 'a -> 'a = 
  Native.Prelude.poly_iter
let poly_swap  : {'a:lens,canonizer} => 'a -> 'a -> 'a = 
  Native.Prelude.poly_swap

(* lens operations *)
let pget : lens -> string -> string = 
  Native.Prelude.get
let pput : lens -> string -> string -> string = 
  Native.Prelude.put
let pcreate : lens -> string -> string =
  Native.Prelude.create
let invert : lens -> lens =
  Native.Prelude.invert
let concat : lens -> lens -> lens =
  Native.Prelude.concat
let union : lens -> lens -> lens =
  Native.Prelude.union
let star : lens -> lens =
  Native.Prelude.star
let dmatch : string -> lens -> lens = 
  Native.Prelude.dmatch
let swap : lens -> lens -> lens =
  Native.Prelude.swap
let compose : lens -> lens -> lens =
  Native.Prelude.compose
let default : lens -> string -> lens =
  Native.Prelude.default
let key : regexp -> lens =
  Native.Prelude.key
let duplicate : lens -> lens -> lens -> lens = 
  Native.Prelude.duplicate
let duplicate_snd : lens -> lens -> lens -> lens = 
  Native.Prelude.duplicate_snd
let count : regexp -> lens =
  Native.Prelude.count
let forgetkey : lens -> lens = 
  Native.Prelude.forgetkey
let filter : regexp -> regexp -> lens = 
  Native.Prelude.filter
  
(* canonizer operations *)
let cls : canonizer -> string -> string =
  Native.Prelude.cls
let rep : canonizer -> string -> string = 
  Native.Prelude.rep
let left_quot : canonizer -> lens -> lens = 
  Native.Prelude.left_quot
let right_quot : lens -> canonizer -> lens =
  Native.Prelude.right_quot
let columnize : string -> regexp -> string -> string -> canonizer = 
  Native.Prelude.columnize

(* string operations *)
let append : string -> string -> string = 
  Native.Prelude.append
let read : string -> string = 
  Native.Prelude.read

(* regexp operations *)
let str : string -> regexp =
  Native.Prelude.str
let empty : regexp = 
  Native.Prelude.empty
let seq : regexp -> regexp -> regexp = 
  Native.Prelude.seq
let alt : regexp -> regexp -> regexp = 
  Native.Prelude.alt
let iter : regexp -> regexp = 
  Native.Prelude.iter
let inter : regexp -> regexp -> regexp = 
  Native.Prelude.inter
let diff : regexp -> regexp -> regexp = 
  Native.Prelude.diff
let equiv : regexp -> regexp -> string = 
  Native.Prelude.equiv

(* run-time checking *)
let assert : regexp -> regexp -> lens -> lens = 
  Native.Prelude.assert
let assert_ctype : regexp -> lens -> lens = 
  Native.Prelude.assert_ctype
let assert_atype  : regexp -> lens -> lens = 
  Native.Prelude.assert_atype
let ctype : lens -> regexp = 
  Native.Prelude.ctype
let atype : lens -> regexp =
  Native.Prelude.atype

(* coercions *)
let canonizer_of_lens : lens -> canonizer = 
  Native.Prelude.canonizer_of_lens
let string_of_regexp : regexp -> string = 
  Native.Prelude.string_of_regexp


(* derived forms *)
let epsilon : regexp = str ""

let ins (s:string) : lens = const (str "") s "" 

let del r = const r "" (shortest r) 

let set r s = const r s (shortest r)

(* constants *)
(* [ANY] any string *)
let ANY : regexp = [^]*

(* [containing R] any string containing [R] *)
let containing (R:regexp) : regexp = ANY . R . ANY

(* [nl] newline *)
let newline : string = "\n"

(* [s] space *)
let space : string = " "

(* [WS] whitespace *)
let WS : regexp = [ \n]*

(* [NWS] not white space *)
let NWS : regexp = [^ \n]

(* [WSP] positive whitespace *)
let WSP : regexp = [ \n]+

(* [SP] positive space *)
let SP : regexp = [ ]+

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [NUMBER] number *)
let NUMBER : regexp = DIGIT+

(* [FNUMBER] floating-point number *)
let FNUMBER : regexp = DIGIT* . ([.] . DIGIT+)?

(* [ULETTER] uppercase letter *)
let ULETTER : regexp = [A-Z]

(* [UALPHANUM] uppercase alphanumeric character *)
let UALPHANUM : regexp = [A-Z0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let NL0 = newline
let NL1 = NL0 . "  "
let NL2 = NL1 . "  "
let NL3 = NL2 . "  "
let NL4 = NL3 . "  "
let NL5 = NL4 . "  "
let NL6 = NL5 . "  "
let NL7 = NL6 . "  " 
let NL8 = NL7 . "  "
let NL9 = NL8 . "  "
let NL10 = NL9 . "  "

(* quotient lenses *)
(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : { C <-> A } = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : { epsilon <-> E } = 
  qconst // E e "" 

(* unit tests for qins *)
test qins [A-Z]+ "A" get "" = "A"
test qins [A-Z]+ "A" create "ABC" = ""

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : { E <-> epsilon } = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    (copy "")

(* unit tests for qdel *)
test (qdel [A-Z]+ "ZZZ" get "ABC") = ""
test (qdel [A-Z]+ "ZZZ" put "" into "ABC") = "ZZZ"
