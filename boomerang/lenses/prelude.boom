(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007-2008                                                     *)
(* J. Nathan Foster, Alexandre Pilkiewicz, and Benjamin C. Pierce              *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/prelude.boom                                              *)
(* Boomerang definitions of lens primitives                                    *)
(* $Id$ *)
(*******************************************************************************)

module Prelude =

let epsilon : regexp = // 

let ins (s:string) : lens = const // s "" 

let del (r:regexp) = const r "" (shortest r) 

let set (r:regexp) (s:string) = const r s (shortest r)

(* [ANYCHAR] any character *)
let ANYCHAR = [^]

(* [ANY] any string *)
let ANY : regexp = ANYCHAR*

(* [ANYP] any non-empty string *)
let ANYP : regexp = ANYCHAR+

(* [containing R] any string containing [R] *)
let containing (R:regexp) : regexp = ANY . R . ANY

(* [nl] newline *)
let newline : string = "\n"

(* [s] space *)
let space : string = " "

(* [WS] whitespace *)
let WS : regexp = [ \n]*

(* [NWS] not white space *)
let NWS : regexp = [^ \n]

(* [WSP] positive whitespace *)
let WSP : regexp = [ \n]+

(* [SP] positive space *)
let SP : regexp = [ ]+

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [NUMBER] number *)
let NUMBER : regexp = DIGIT+

(* [FNUMBER] floating-point number *)
let FNUMBER : regexp = DIGIT* . ([.] . DIGIT+)?

(* [ULETTER] uppercase letter *)
let ULETTER : regexp = [A-Z]

(* [UALPHANUM] uppercase alphanumeric character *)
let UALPHANUM : regexp = [A-Z0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let NL0 = newline
let NL1 = NL0 . "  "
let NL2 = NL1 . "  "
let NL3 = NL2 . "  "
let NL4 = NL3 . "  "
let NL5 = NL4 . "  "
let NL6 = NL5 . "  "
let NL7 = NL6 . "  " 
let NL8 = NL7 . "  "
let NL9 = NL8 . "  "
let NL10 = NL9 . "  "

(* quotient lenses *)
(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : lens = 
  right_quot
    (ins e)
    (canonizer_of_lens (const E e e))

(* unit tests for qins *)
test (qins [A-Z]+ "A" get "") = "A"
test (qins [A-Z]+ "A" create "ABC") = ""

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : lens = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    (copy //)

(* unit tests for qdel *)
test (qdel [A-Z]+ "ZZZ" get "ABC") = ""
test (qdel [A-Z]+ "ZZZ" put "" into "ABC") = "ZZZ"
test (Native.Prelude.unsafe_rput (qdel [A-Z]+ "ZZZ") "1" "ABC") = "ZZZ"
test (rput (qdel [A-Z]+ "ZZZ") "1" "ABC") = error

type 'a option = 
    None | Some of 'a

type ('a,'b) maybe = 
    Left of 'a | Right of 'b 
