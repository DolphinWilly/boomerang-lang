(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007-2008                                                     *)
(* J. Nathan Foster, Alexandre Pilkiewicz, and Benjamin C. Pierce              *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/prelude.boom                                              *)
(* Boomerang definitions of lens primitives                                    *)
(* $Id$ *)
(*******************************************************************************)

module Prelude =

(* standard datatypes *)

(* options *)
type 'a option = 
    None | Some of 'a

type ('a,'b) maybe = 
    Left of 'a | Right of 'b 

(* components of lenses *)
let ctype : lens -> regexp = 
  Native.Prelude.ctype
let atype : lens -> regexp =
  Native.Prelude.atype
let pget : lens -> string -> string = 
  Native.Prelude.get
let pput : lens -> string -> string -> string = 
  Native.Prelude.put
let pcreate : lens -> string -> string =
  Native.Prelude.create

(* predicates *)
(* 
let splittable : {'a:string,regexp,lens,canonizer} => 'a -> 'a -> bool =
  Native.Prelude.splittable

let disjoint : regexp -> regexp -> bool =
  Native.Prelude.disjoint
*)
(* Maybe we also want one for lenses? *)

(* polymorphic operators *)
let copy : regexp -> lens = 
  Native.Prelude.copy
let const : regexp -> string -> string -> lens = 
  Native.Prelude.const 

let string_concat : string -> string -> string = 
  Native.Prelude.string_concat 

let regexp_concat : regexp -> regexp -> regexp = 
  Native.Prelude.regexp_concat 


(* 
let lens_concat : (x:lens)
               -> (y:lens | splittable x y) 
               -> lens =
  Native.Prelude.lens_concat
*)
let lens_concat : lens -> lens -> lens = 
  Native.Prelude.lens_concat 

let canonizer_concat : canonizer -> canonizer -> canonizer = 
  Native.Prelude.canonizer_concat 

let regexp_union : regexp -> regexp -> regexp = 
  Native.Prelude.regexp_union
(* 
  let lens_union : (x:lens) 
                -> (y:lens where disjoint (ctype x) (ctype y))
                -> lens =
    Native.Prelude.lens_union
*)
let lens_union : lens -> lens -> lens = 
  Native.Prelude.lens_union

let canonizer_union : canonizer -> canonizer -> canonizer = 
  Native.Prelude.canonizer_union

let regexp_iter : regexp -> int -> int -> regexp = 
  Native.Prelude.regexp_iter

let lens_iter : lens -> int -> int -> lens = 
  Native.Prelude.lens_iter

let canonizer_iter : canonizer -> int -> int -> canonizer = 
  Native.Prelude.canonizer_iter

let lens_swap: lens -> lens -> lens = 
  Native.Prelude.lens_swap

let canonizer_swap: canonizer -> canonizer -> canonizer = 
  Native.Prelude.canonizer_swap

(* operations on lenses *)
let invert : lens -> lens =
  Native.Prelude.invert
let dmatch : string -> lens -> lens = 
  Native.Prelude.dmatch
let smatch : string -> string -> lens -> lens = 
  Native.Prelude.smatch
let compose : lens -> lens -> lens =
  Native.Prelude.compose
let default : lens -> string -> lens =
  Native.Prelude.default
let key : regexp -> lens =
  Native.Prelude.key
let duplicate : lens -> lens -> lens -> lens = 
  Native.Prelude.duplicate
let duplicate_snd : lens -> lens -> lens -> lens = 
  Native.Prelude.duplicate_snd
let count : regexp -> lens =
  Native.Prelude.count
let forgetkey : lens -> lens = 
  Native.Prelude.forgetkey
let filter : regexp -> regexp -> lens = 
  Native.Prelude.filter
  
(* canonizer operations *)
let cls : canonizer -> string -> string =
  Native.Prelude.cls
let rep : canonizer -> string -> string = 
  Native.Prelude.rep
let left_quot : canonizer -> lens -> lens = 
  Native.Prelude.left_quot
let right_quot : lens -> canonizer -> lens =
  Native.Prelude.right_quot
let columnize : string -> regexp -> string -> string -> canonizer = 
  Native.Prelude.columnize

(* string operations *)
let read : string -> string = 
  Native.Prelude.read

(* regexp operations *)
let str : string -> regexp =
  Native.Prelude.str
let shortest : regexp -> string = 
  Native.Prelude.shortest
let empty : regexp = 
  Native.Prelude.empty
let inter : regexp -> regexp -> regexp = 
  Native.Prelude.inter
let diff : regexp -> regexp -> regexp = 
  Native.Prelude.diff
let equiv : regexp -> regexp -> string = 
  Native.Prelude.equiv

(* run-time checking *)
let assert : regexp -> regexp -> lens -> lens = 
  Native.Prelude.assert
let assert_ctype : regexp -> lens -> lens = 
  Native.Prelude.assert_ctype
let assert_atype  : regexp -> lens -> lens = 
  Native.Prelude.assert_atype

(* coercions *)
let canonizer_of_lens : lens -> canonizer = 
  Native.Prelude.canonizer_of_lens
let string_of_regexp : regexp -> string = 
  Native.Prelude.string_of_regexp


(* derived forms *)
let epsilon : regexp = str ""

let ins (s:string) : lens = const // s "" 

let del (r:regexp) = const r "" (shortest r) 

let set (r:regexp) (s:string) = const r s (shortest r)

(* constants *)
(* [ANY] any string *)
let ANY : regexp = [^]*

(* [ANYP] any non-empty string *)
let ANYP : regexp = [^]+

(* [containing R] any string containing [R] *)
let containing (R:regexp) : regexp = ANY . R . ANY

(* [nl] newline *)
let newline : string = "\n"

(* [s] space *)
let space : string = " "

(* [WS] whitespace *)
let WS : regexp = [ \n]*

(* [NWS] not white space *)
let NWS : regexp = [^ \n]

(* [WSP] positive whitespace *)
let WSP : regexp = [ \n]+

(* [SP] positive space *)
let SP : regexp = [ ]+

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [NUMBER] number *)
let NUMBER : regexp = DIGIT+

(* [FNUMBER] floating-point number *)
let FNUMBER : regexp = DIGIT* . ([.] . DIGIT+)?

(* [ULETTER] uppercase letter *)
let ULETTER : regexp = [A-Z]

(* [UALPHANUM] uppercase alphanumeric character *)
let UALPHANUM : regexp = [A-Z0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let NL0 = newline
let NL1 = NL0 . "  "
let NL2 = NL1 . "  "
let NL3 = NL2 . "  "
let NL4 = NL3 . "  "
let NL5 = NL4 . "  "
let NL6 = NL5 . "  "
let NL7 = NL6 . "  " 
let NL8 = NL7 . "  "
let NL9 = NL8 . "  "
let NL10 = NL9 . "  "

(* quotient lenses *)
(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : lens = 
  right_quot
    (ins e)
    (canonizer_of_lens (const E e e))

(* unit tests for qins *)
test qins [A-Z]+ "A" get "" = "A"
test qins [A-Z]+ "A" create "ABC" = ""

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : lens = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    (copy //)

(* unit tests for qdel *)
test (qdel [A-Z]+ "ZZZ" get "ABC") = ""
test (qdel [A-Z]+ "ZZZ" put "" into "ABC") = "ZZZ"

