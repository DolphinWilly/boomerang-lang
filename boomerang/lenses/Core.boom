(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007-2008                                                     *)
(* J. Nathan Foster, Alexandre Pilkiewicz, and Benjamin C. Pierce              *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/lenses/core.boom                                                 *)
(* Imports natively-defined primitives                                         *)
(* $Id$ *)
(*******************************************************************************)

module Core = 

(* polymorphic *)
let equals : forall 'a => 'a -> 'a -> bool = 
  Native.Prelude.poly_equal

(* booleans *)
let land : bool -> bool -> bool = 
  Native.Prelude.land
let lor : bool -> bool -> bool = 
  Native.Prelude.lor
let not : bool -> bool = 
  Native.Prelude.not

(* strings *)
let string_concat : string -> string -> string = 
  Native.Prelude.string_concat 

(* regular expressions *) 
let regexp_union : regexp -> regexp -> regexp = 
  Native.Prelude.regexp_union
let regexp_concat : regexp -> regexp -> regexp = 
  Native.Prelude.regexp_concat 
let regexp_iter : regexp -> int -> int -> regexp = 
  Native.Prelude.regexp_iter

let str : string -> regexp =
  Native.Prelude.str
let shortest : regexp -> string = 
  Native.Prelude.shortest
let empty : regexp = 
  Native.Prelude.empty
let inter : regexp -> regexp -> regexp = 
  Native.Prelude.inter
let is_empty : regexp -> bool = 
  Native.Prelude.is_empty
let diff : regexp -> regexp -> regexp = 
  Native.Prelude.diff
let equiv : regexp -> regexp -> bool = 
  Native.Prelude.equiv
let matches : regexp -> string -> bool = 
  Native.Prelude.matches
let disjoint (r1:regexp) (r2:regexp) : bool = 
  is_empty (inter r1 r2)
let splittable : regexp -> regexp -> bool = 
  Native.Prelude.splittable
let iterable : regexp -> bool = 
  Native.Prelude.iterable

(* lenses *)
let bij : lens -> bool = 
  Native.Prelude.bij
let ctype : lens -> regexp = 
  Native.Prelude.ctype
let atype : lens -> regexp =
  Native.Prelude.atype
let in_lens_type (l:lens) (c:regexp) (a:regexp) : bool = 
  land (equiv (ctype l) c) (equiv (atype l) a)
let in_bij_lens_type (l:lens) (c:regexp) (a:regexp) : bool = 
  land (land (equiv (ctype l) c) (equiv (atype l) a)) (bij l)

let get (l:lens) (c:string where matches (ctype l) c) : string =
  Native.Prelude.unsafe_get l c
let put (l:lens) (a:string where matches (atype l) a) (c:string where matches (ctype l) c) : string = 
  Native.Prelude.unsafe_put l a c
let create (l:lens) (a:string where matches (atype l) a) : string = 
  Native.Prelude.unsafe_create l a

let copy (R:regexp) : lens
  = Native.Prelude.copy R

let const (R:regexp) (u:string) (v:string where matches R v) : lens
  = Native.Prelude.unsafe_const R u v

let lens_union (l1:lens) (l2:lens where disjoint (ctype l1) (ctype l2)) : lens
  = Native.Prelude.unsafe_union l1 l2 

let lens_disjoint_union 
    (l1:lens) 
    (l2:lens where land (disjoint (ctype l1) (ctype l2))
                        (disjoint (atype l1) (atype l2))) : lens 
  = Native.Prelude.unsafe_disjoint_union l1 l2 

let lens_concat (l1:lens)
                (l2:lens where land (splittable (ctype l1) (ctype l2))
                                    (splittable (ctype l1) (ctype l2))) : lens
  = Native.Prelude.unsafe_concat l1 l2

let lens_iter (l1:lens where land (iterable (ctype l1)) (iterable (atype l1))) (x:int) (y:int) 
  : lens 
  = Native.Prelude.unsafe_iter l1 x y 

let lens_star (l1:lens where land (iterable (ctype l1)) (iterable (atype l1))) 
  : lens 
  = Native.Prelude.unsafe_star l1

let invert : (l:lens where bij l) -> lens =
  Native.Prelude.invert
let dmatch : string -> lens -> lens = 
  Native.Prelude.dmatch
let smatch : string -> string -> lens -> lens = 
  Native.Prelude.smatch
let compose : lens -> lens -> lens =
  Native.Prelude.compose
let default : lens -> string -> lens =
  Native.Prelude.default
let key : regexp -> lens =
  Native.Prelude.key
let count : regexp -> (string -> int) =
  Native.Prelude.count
let forgetkey : lens -> lens = 
  Native.Prelude.forgetkey
let filter (r1:regexp where iterable r1) (r2:regexp where land (disjoint r1 r2) (iterable r2)) : lens = 
  Native.Prelude.unsafe_filter r1 r2
let lens_swap (l1:lens)
              (l2:lens where land (splittable (ctype l1) (ctype l2))
                                  (splittable (ctype l1) (ctype l2))) : lens = 
  Native.Prelude.unsafe_swap l1 l2

(* canonizers *)
let canonize : canonizer -> string -> string =
  Native.Prelude.canonize
let choose : canonizer -> string -> string = 
  Native.Prelude.choose
let left_quot : canonizer -> lens -> lens = 
  Native.Prelude.left_quot
let right_quot : lens -> canonizer -> lens =
  Native.Prelude.right_quot

let canonizer_concat : canonizer -> canonizer -> canonizer = 
  Native.Prelude.canonizer_concat 
let canonizer_iter : canonizer -> int -> int -> canonizer = 
  Native.Prelude.canonizer_iter

let columnize : string -> regexp -> string -> string -> canonizer = 
  Native.Prelude.columnize

(* integers *)
let bgt : int -> int -> bool = 
  Native.Prelude.gt
let blt : int -> int -> bool = 
  Native.Prelude.lt
let bgeq : int -> int -> bool = 
  Native.Prelude.geq
let bleq : int -> int -> bool = 
  Native.Prelude.leq
let plus : int -> int -> int = 
  Native.Prelude.plus
let minus : int -> int -> int = 
  Native.Prelude.minus
let times : int -> int -> int = 
  Native.Prelude.times
let bdiv : int -> int -> int = 
  Native.Prelude.div
let bmod : int -> int -> int = 
  Native.Prelude.mod

(* misc utilities *)
let read : string -> string = 
  Native.Prelude.read

(* run-time checking *)
let canonizer_of_lens : lens -> canonizer = 
  Native.Prelude.canonizer_of_lens
let string_of_regexp : regexp -> string = 
  Native.Prelude.string_of_regexp

let blame 'a 'b (i:string * ((int * int) * (int * int))) (v:'a) (es:string) : 'b = 
  Native.Prelude.blame{'a}{'b} i v es

let set (r:regexp) (s:string) = 
  const r s (shortest r)

let rewrite (s1:string) (s2:string) = 
  const s1 s2 s1 
