(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007-2008                                                     *)
(* J. Nathan Foster, Alexandre Pilkiewicz, and Benjamin C. Pierce              *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/examples/address.boom                                            *)
(* VCard, XCard, CSV address books lens                                        *)
(* $Id$ *)
(*******************************************************************************)

module Address = 

(* This module contains lenses for mapping between vCard, CSV, and a
   simple XML format (based on XCard). Most of the complexity is
   related to escaping / unescaping of the special characters in
   each format. We use sequential composition to build lenses that
   make multiple passes over each string--escaping / unescaping the
   raw strings, and then processing the tidied data. 

   In going from vCard to CSV, entire fields (e.g., addresses) and
   the formatting details of specific lines (e.g, item1, item2,
   item3, and abemail vs. email) are discarded. 

   In going from XML to CSV whitespace is discarded. 

   In each case, each entry is a chunk and the name serves as a key.
*)

(* -------------------------------------------------------------------- *)
(* GENERIC DEFINITIONS *)

(* Any: any string *)
let Any : regexp = [^]*

(* AnyP: any non-empty string *)
let AnyP : regexp = [^]+

(* StringNotContaining: any string not containing a regular
   expression *)
let StringNotContaining (r:regexp) : regexp = 
  Any - (Any . r . Any)

(* NonEmptyStringNotContaining: any non-empty string not containing a
   regular expression *)
let NonEmptyStringNotContaining (r:regexp) : regexp = 
  AnyP - (Any . r. Any)

(* WS: strings of whitespace *)
let WS : regexp = [ \n\t]*

(* ws: lens that deletes whitespace *)
let ws : lens = del WS

(* NL: portable newline *)
let NL : regexp = /\r/? . /\n/

(* NonNL: any string not containing a newline *)
let NonNL : regexp = StringNotContaining [\n\r]

(* filterwith: derived lens that removes characters in [both], then
   runs [l]*)
let filterwith (both: regexp) (l: lens) : lens = 
  filter (both - (ctype l)) (ctype l) ; l*

(* -------------------------------------------------------------------- *)
(* ESCAPING *)

(* Special: characters that are always escaped *)
let Special : regexp = [\n\r\\]

(* NonSpecial negation of Special *)
let NonSpecial : regexp = [^\n\r\\]

(* EscapedSpecial: escape characters for Special *)
let EscapedSpecial : regexp = [\\nr]

(* escspecial: lens escaping non-slash chars in Special *)
let escspecial : lens = (/\n/ <-> "\\n" | /\r/ <-> "\\r")

(* EscapedStr: strings where every character in [R] and [Special] are
   escaped using backslash. [R] should be a chracter class. *)
let EscapedStr (R:regexp) : regexp =
  let Normal = StringNotContaining (Special | R) in
  let Escaped = /\\/ . (EscapedSpecial | R) in
  Normal . (Escaped . Normal)* 

(* NonEmptyEscapedStr: non-empty strings where every character in [R]
   and [Special] are escaped using backslash. [R] should be a
   chracter class. *)
let NonEmptyEscapedStr (R:regexp) : regexp = 
  let Normal = StringNotContaining (Special | R) in 
  let NonEmptyNormal = Normal - epsilon in 
  let Escaped = /\\/ . (EscapedSpecial | R) in 
  let EscapedNormal = Escaped . Normal in 
    NonEmptyNormal . EscapedNormal* | EscapedNormal+

(* escchar: escape characters in [c], which should be a character
   class. *)
let escchar (c:regexp) : lens = 
  ( (ins "\\" . copy (c | /\\/))
  | escspecial
  | copy (NonSpecial - c))

(* unescchar: inverse of (the bijective lens) escchar *)
let unescchar (c:regexp) : lens = invert (escchar c)

(* escstr: escape a string using [escchar] *)
let escstr (c:regexp) : { ? <-> EscapedStr c } = (escchar c)*

(* escNonEmptyStr: escape a non-empty string using [escchar] *)
let escNonEmptyStr (c:regexp) : { ? <-> NonEmptyEscapedStr c } = (escchar c)+

(* unescstr: unescape a string using [unescchar] *)
let unescstr (c:regexp) : { EscapedStr c <-> ? } = (unescchar c)*

(* unescNonEmptyStr: unescape a non-empty string using [unescchar] *)
let unescNonEmptyStr (c:regexp) : { NonEmptyEscapedStr c <-> ? } = (unescchar c)+

(* unit tests for escaping lenses *)
test (unescchar empty)* get "\n" = error
test (unescchar empty)* get "abc" = "abc"
test (unescchar empty)* get "\\\\" = "\\"
test (unescchar empty)* get "\\n" = "\n"
test (unescchar [,])* get "\\," = ","
test (escchar empty)* get "a\nb\\c" = "a\\nb\\\\c"
test (escchar [,])* get "a,b" = "a\\,b"

(* -------------------------------------------------------------------- *)
(* TELEPHONE AND NAME FIELDS *)

(* TelTags: strings used in markers for tel fields in CSV *)
let TelTags : regexp = [hwce] | /note/

(* TelMarker: strings used to mark tel fields in CSV *)
let TelMarker : regexp = / (/ . TelTags . /)/

(* Tel: a single, escaped tel field *)
let Tel : regexp = /, / . (EscapedStr [,]) . TelMarker

(* Name: a single, escaped name field. Cannot end with a TelMarker *)
let Name : regexp = (NonEmptyEscapedStr [,]) - ( Any . TelMarker )

(* NonEmptyName: a single, non-empty name *)
let NonEmptyName : regexp = Name - epsilon

(* Family and Given: just non-empty names *)
let Family,Given : regexp * regexp = NonEmptyName,NonEmptyName

(* GlobalName: a single name in CSV *)
let GlobalName : regexp = Family . (/, / . Given)?
  
(* AbsAddr: type for CSV address book entry *) 
let AbsAddr = GlobalName . Tel* 

(* escaper: a lens that handles escaping of non-empty fields.
   Describing this type is rather tricky, because we want the abstract
   view to exclude strings that include TelMarkers, but allow strings
   that are *almost* TelMarkers.  The arguments are as follows:
     o legal: the set of legal characters
     o esc: function that takes  a set of characters to escape 
       and yields a lens that does the escaping
     o l: lens for special characters 
     o c: set of special characters 
  *)
let escaper (legal:regexp) (esc:regexp -> lens) (l:lens) (c:regexp) = 
  let mk_suffix (r:regexp) : lens = copy (legal - (r | c)) | l  in
  let suffix : lens = 
    ( (mk_suffix [)])
    | (mk_suffix [hwce]) . cp ")"
    | (mk_suffix [t(])   . cp "e)"
    | (mk_suffix [(])    . copy ( [hwc] . [)] | /note)/ )
    | (mk_suffix [ ])    . copy ([(] . TelTags . [)])
    | (mk_suffix [o])    . cp "te)"
    | (mk_suffix [n])    . cp "ote)" ) in 
  ( esc c . suffix
  | cp ")" 
  | copy ([hwce] . /)/)
  | cp "te)" 
  | cp "ote)"
  | cp "note)"
  | cp "(note)" 
  | copy ( /(/ . [hwce] . /)/ ) )
            
(* formatter: specialization of escaper with the standard special characters *)
let formatter : (regexp -> lens) -> lens -> regexp -> lens = 
  escaper [^\n\r\\] 

(* formatspecial: lens for formatting the special characters *)
let formatspecial : lens = 
  ( [\\] <-> "\\\\" 
  | [,] <-> "\\," 
  | [\n] <-> "\\n" 
  | [\r] <-> "\\r")

(* unformatspecial: lens for unformatting special characters, also 
   handles colons and semicolons *)
let unformatspecial : lens = 
  ( invert formatspecial
  | /\\:/ <-> ":" 
  | /\\;/ <-> ";" ) 

(* formatnotemptyname: escape string to Name *)
let formatnotemptyname : { ? <-> Name } = 
  formatter escstr formatspecial  [,]


(* unformatnotemptyname: unescape string from Name *)
let unformatnotemptyname : lens = 
  formatter unescstr unformatspecial [,;:]
  
(* name: handles escaping and formatting of a Name. We do this in two 
   passes. First, we unformat to put everything in a canonical "raw" form, 
   Then we format to escape characters and render the name *)
let name : { ? <-> GlobalName } = 
  let escNonEmptyName = 
    unformatnotemptyname ; formatnotemptyname in
  let familyname = 
    del /N:/ . escNonEmptyName in
  familyname . (del /;/ | /;/ <-> ", " . escNonEmptyName ) . del /;;;/

(* unit test for name *)
test name get "N:Pierce;Benjamin C.;;;" = "Pierce, Benjamin C."

(* formattel: lens for escaping tel data *)
let formattel : lens = escstr [,]

(* field': helper for handling a field. The arguments are as follows:
     o w0: first tag in vCard source
     o w1: second tag in vCard source
     o w2: tag in CSV view
*)
let field' (w0:string) (w1:string) (w2:string) =
  str (w0 . ";") <-> ", " . 
  del /type=/ . del (str w1) .
  del (/;/ . /type=/ . [A-Z]+)* . 
  (cp "" | del /;type=pref/) .
  del [:] . 
  (unescstr [;,:]; formattel) .
  ins " (" . ins w2 . ins ")" .
  del NL

(* tel': helper lens for handling telephone fields *)
let tel' : string -> string -> lens = field' "TEL"

(* tel: lens for handling all kinds of telephone fields *)
let tel : lens =
    tel' "WORK" "w"
  | tel' "HOME" "h"
  | tel' "CELL" "c"

(* formatnote: lens for escaping note data *)
let formatnote : lens = escstr [,]

(* note: lens for handling note fields. Again, we use the two-pass 
   approach--unformatting / unescaping, and then reformatting / reescaping *)
let note : lens =
  /NOTE:/ <-> ", " .
  (unescstr [,:;]; formatnote) .
  ins " (note)" .
  del NL

(* abemail: lens for Apple's special email field. Uses two-pass approach. *)
let abemail : lens =
  /item.EMAIL;type=INTERNET;type=pref:/ <-> ", " .
  (unescstr [,:;]; escstr [,]) .
  del NL .
  del /item.X-ABLabel:E-mail/ . del NL .
  ins " (e)" 

(* email: lens for ordinary vCard (as in RFC) field *)
let email : lens = field' "EMAIL" "INTERNET" "e"

(* entry : lens for an individual vCard field. *)
let entry : lens =  abemail | email | tel | note

(* ItemLine: regexp for lines that use Apple's itemN convention *)
let ItemLine :regexp = /item/ . NonNL . NL

(* Line: regexp for any line *)
let Line : regexp = [^ ] . NonNL . NL . (/ / . NonNL . NL)*

(* Field: regexp for ItemLine fields: either an ordinary line or two
   item lines *)
let Field : regexp = 
  ((Line - ItemLine) | (ItemLine . ItemLine))
  - (/END:VCARD/ . NL)

(* numberedItem: regexp for lines with numbered items *)
let NumberedItem (n:string) : regexp =
  /item/ . str n . /./ . NonNL . NL . /item/ . str n . /./ . NonNL . NL

(* Field_unnumbered: regexp for fields without numbered item lines *)
let Field_unnumbered : regexp =
  Field - (NumberedItem "1" | NumberedItem "2" | NumberedItem "3")

(* remove_item_numbers: lens for deleting item numberings *)
let remove_item_numbers : { ? <-> Field_unnumbered* } = 
  let delItemNumber (n:string) : lens = 
    cp "item" . 
    del (str n) . 
    copy ([.] . NonNL . NL . /item/) . 
    del (str n) . 
    copy ([.] . NonNL . NL) in
  let Stuff = copy (Field - (/item/ . NonNL . NL . /item/ . NonNL . NL) ) in 
  ( ( Stuff* . delItemNumber "1" .
      Stuff* . delItemNumber "2" .
      Stuff* . delItemNumber "3" .
      copy Field_unnumbered* )
  | ( Stuff* . delItemNumber "1" .
      Stuff* . delItemNumber "2" .
      copy Field_unnumbered* )
  | ( Stuff* . delItemNumber "1" .
      copy Field_unnumbered* )
  | ( copy Field_unnumbered* ) )

(* chunk: lens for a vCard entry *)
let chunk : { ? <-> AbsAddr } = 
  (* delete preamble *)
  del /BEGIN:VCARD/ . del NL . 
  del /VERSION:3.0/ . del NL .  
  (* format name, tag it as key *)
  (name; key (atype name)) . del NL .
  (* handle fields by: 
       removing item numbers, 
       removing unnumbered fields, 
       evaluating entry *)
    (remove_item_numbers ;
     filterwith
       Field_unnumbered
       entry) .
  (* del postamble *)
  del /END:VCARD/ . del NL

(* vcard lens: match a chunk *)
let vcard = <chunk>

(* unit tests for vcard *)
let samplevcard = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    TEL;type=WORK;type=pref:6106236713
    FN:Andy Patroni
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    END:VCARD
    
>>>

test vcard create 
<<<
  Foo, Jean-Paul, jean-paul.courbebaisse@education.gouv.fr (e), 1234567 (h), bar (e)
>>>
= 
<<<
  BEGIN:VCARD
  VERSION:3.0
  N:Foo;Jean-Paul;;;
  item1.EMAIL;type=INTERNET;type=pref:jean-paul.courbebaisse@education.gouv.fr
  item1.X-ABLabel:E-mail
  TEL;type=HOME:1234567
  item2.EMAIL;type=INTERNET;type=pref:bar
  item2.X-ABLabel:E-mail
  END:VCARD

>>>
  
test vcard put "Foo, Jean-Paul, bar (e)" 
  into
<<<
  BEGIN:VCARD
  VERSION:3.0
  N:AAAAA TEST;Jean-Paul;;;
  item1.EMAIL;type=INTERNET;type=pref:jean-paul.courbebaisse@education.gouv.fr
  item1.X-ABLabel:E-mail
  TEL;type=WORK:1234567
  item2.EMAIL;type=INTERNET;type=pref:foo
  item2.X-ABLabel:E-mail
  END:VCARD

>>> 
= 
<<<
  BEGIN:VCARD
  VERSION:3.0
  N:Foo;Jean-Paul;;;
  item1.EMAIL;type=INTERNET;type=pref:bar
  item1.X-ABLabel:E-mail
  END:VCARD

>>>

test vcard get samplevcard = "Andy Patroni, 6106236713 (w)"

test vcard put 
  "Andy Patroni, 12345 (c), 67890 (h)"
  into samplevcard = 
  "BEGIN:VCARD
  |VERSION:3.0
  |N:Andy Patroni;;;;
  |TEL;type=CELL:12345
  |FN:Andy Patroni
  |X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\\:ABPerson
  |TEL;type=HOME:67890
  |END:VCARD
  |"

test vcard put 
  "Andy Patroni, fubar (note)" 
  into samplevcard =
<<<
  BEGIN:VCARD
  VERSION:3.0
  N:Andy Patroni;;;;
  NOTE:fubar
  FN:Andy Patroni
  X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
  END:VCARD

>>>

(* vcards: lens for a whole file of vcards *)
let vcards : lens = (<chunk> . ins "\n") * . ws

(* unit test for vcards *)
let samplevcards = 
<<<
  BEGIN:VCARD
  VERSION:3.0
  N:Androuet;;;;
  FN:Androuet
  NOTE:(01) 42 89 95 00  41 rue d'Amsterdam  M. Liege  (cheese restaurant near St. Lazare\, Paris)  rather expensive and fancy and pungent (300FF/person)
  X-ABUID:A5695B7A-5931-4A63-8308-ANOTHERIDENT0\:ABPerson
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:New York Restaurants;;;;
  FN:New York Restaurants
  NOTE:two best mexican in nyc (according to Scot\, IIRC)\n          rosa mexicana\n          zarela's
  X-ABUID:D40A8D20-F5E8-47E1-983E-D331E92C6F8B\:ABPerson
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:Pierce;Benjamin C.;;;
  FN:Benjamin C. Pierce
  TEL;type=HOME;type=pref:215 732-4684
  TEL;type=CELL:215 266-9001
  TEL;type=WORK:215 898-6222
  X-ABUID:87B85E7E-AB0F-4819-8647-0BD532019144\:ABPerson
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:Andy Patroni;;;;
  FN:Andy Patroni
  TEL;type=WORK;type=pref:6106236713
  X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:Bistro de Vent;;;;
  FN:Bistro de Vent
  X-ABUID:F00ABF1D-8DC0-4C3C-98ED-2BC33FA8D90C\:ABPerson
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:Biswas;Goutam;;;
  FN:Goutam Biswas
  X-ABUID:5BEAD7E0-AFF8-42AB-BD38-9A741CD64E20\:ABPerson
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:Black;Andrew;;;
  FN:Andrew Black
  X-ABUID:A9BA5924-5A64-4D46-A40F-A0BC86073232\:ABPerson
  END:VCARD

>>>
      
test vcards get samplevcards = 
<<<
  Androuet, (01) 42 89 95 00  41 rue d'Amsterdam  M. Liege  (cheese restaurant near St. Lazare\, Paris)  rather expensive and fancy and pungent (300FF/person) (note)
  New York Restaurants, two best mexican in nyc (according to Scot\, IIRC)\n          rosa mexicana\n          zarela's (note)
  Pierce, Benjamin C., 215 732-4684 (h), 215 266-9001 (c), 215 898-6222 (w)
  Andy Patroni, 6106236713 (w)
  Bistro de Vent
  Biswas, Goutam
  Black, Andrew

>>>

test vcards put 
<<<
  Andy Patroni, 6106236713 (w), fubar (note)
  Pierce, Benjamin C., 215 898-6222 (w), 215 732-4684 (h), 215 266-9001 (c)

>>>
into samplevcards = 
<<<
  BEGIN:VCARD
  VERSION:3.0
  N:Andy Patroni;;;;
  FN:Andy Patroni
  TEL;type=WORK;type=pref:6106236713
  X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
  NOTE:fubar
  END:VCARD
  BEGIN:VCARD
  VERSION:3.0
  N:Pierce;Benjamin C.;;;
  FN:Benjamin C. Pierce
  TEL;type=WORK:215 898-6222
  TEL;type=HOME:215 732-4684
  TEL;type=CELL:215 266-9001
  X-ABUID:87B85E7E-AB0F-4819-8647-0BD532019144\:ABPerson
  END:VCARD

>>>

(* BCP's own unit test *)
(* test vcards get (read "/home/bcpierce/Desktop/vCards.vcf") = ? *)

(* -------------------------------------------------------------------- *)
(* GENERIC XML STUFF *)

(* nlX: X^th amount of whitespace; used as defaults when creating XML *)
let nl0 = "\n"
let nl1 = nl0 . "  "
let nl2 = nl1 . "  "
let nl3 = nl2 . "  "
let nl4 = nl3 . "  "

(* del_xml_nl_var: lens for deleting whitespace with a default *)
let del_xml_nl_var (def:string) : lens = default ((del WS . del [\n]) | cp "") def

(* del_xml_nl: lens for deleting whitespace with a default--adds a newline to passed default *)
let del_xml_nl (def:string) : lens = del_xml_nl_var (def . "\n")

(* single_line_elt: helper for processing a single-line XML element
     o spaces: default whitespace before the element
     o tag: the element's tag
     o body: lens for handling the children
*)
let single_line_elt (spaces:string) (tag:string) (body:lens) : lens = 
  default (del WS) spaces .
  del (/</ . str tag . />/) . body . 
  del (/<\// . str tag . />/) 

(* multi_line_elt_nl_nl: helper for processing a multi-line XML element 
   o spaces: default whitespace after the element
   o tag: the element's tag
   o body: lens for handling the children 
*)
let multi_line_elt_no_nl (spaces:string) (tag:string) (body:lens) : lens = 
  del (/</ . str tag . />/) .
  body . 
  default (del WS) spaces . 
  del (/<\// . str tag ./>/) 

(* multi_line_elt: helper for processing a multi-line XML element
   o spaces: default whitespace before the element
   o tag: the element's tag
   o body: lens for handling the children 
*)
let multi_line_elt (spaces:string) (tag:string) (body:lens) : lens = 
  default (del WS) spaces .
  (multi_line_elt_no_nl spaces tag body) 

(* special: lens for escaping special characters in PCDATA *)
let special : lens = 
  ( /&lt;/ <-> "<" 
  | /&gt;/ <-> ">" 
  | /&amp;/ <-> "&")    

(* R: character set for special characters *)
let R = [&<>]

(* Normal: regexp for non-special strings *)
let Normal : regexp = StringNotContaining R

(* unescpcdata: regexp for unescaping raw PCDATA *)
let unescpcdata : lens = copy Normal . (special . copy Normal)*  
  
(* formatpcdata: lens for escaping PCDATA; excludes TelTags using escaper helper from above. *)
let format_pcdata : lens = escaper [^] (fun (c:regexp) -> unescpcdata) (copy []) []

(* -------------------------------------------------------------------- *)
(* BCP's personal variant of XCard *)

(* name: lens for handling name field. In XCard, a name is either a
   single element n, or has two subelements, family and given. Also
   handles escaping. *)
let name : lens = 
  let n = format_pcdata; formatnotemptyname in 
    ( single_line_elt nl2 "n" n
    | (multi_line_elt nl2 "n" 
         (single_line_elt nl3 "family" n . 
            (cp "" | ins ", " . single_line_elt nl3 "given" n))))

(* tel': helper for escaping and formatting telephone data. 
     o full: XCard tag
     o short: CSV tag 
*)
let tel' (full:string) (short:string) : lens = 
  ins ", " . 
  single_line_elt nl2 full (unescpcdata ; formattel . ins (" (" . short . ")"))

(* tel: lens for handling all tags *)
let tel : lens = 
    tel' "tel-home" "h"
  | tel' "tel-work" "w"
  | tel' "tel-cell" "c"
  | tel' "email"    "e"
  | tel' "note"     "note"
      
(* chunk: lens for handling a single XCard entry *)
let chunk :lens = 
  multi_line_elt nl1 "vcard" ((name; key (atype name)) . tel* )

(* vcard: lens for handling a single XCard vcard element *)
let vcard : lens = <chunk>

let samplevcard = 
  "<vcard>
      <n><family>foo</family><given>bar</given></n>
      <tel-home>12345</tel-home>
      <tel-cell>12345</tel-cell>
      <note>hello world</note>
   </vcard>"

(* unit test for vcard *)
test vcard get samplevcard = 
  "foo, bar, 12345 (h), 12345 (c), hello world (note)"

(* xcard: lens for handling a single XCard xcard elemnet *)
let xcard = multi_line_elt_no_nl nl0 "xcard" ((vcard . ins "\n") * )

(* unit tests for xcard *)
let samplexcards = 
  "<xcard>
     | <vcard>
     |   <n>Charles Addams</n>
     |   <note>goodbye world</note></vcard>
     | <vcard>
     |   <n><family>Doe</family><given>John</given></n>
     |   <note>hello world</note>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home></vcard>
     | <vcard>
     |   <n><family>Doe</family><given>Sally</given></n>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     |   <note>hello, world ! Question : nice weather ? (no ?)</note>
     | </vcard>
     |</xcard>"

test xcard get samplexcards =
<<<
  Charles Addams, goodbye world (note)
  Doe, John, hello world (note), 792-8134 (h), 732-4684 (h)
  Doe, Sally, 792-8134 (h), 732-4684 (h), hello\, world ! Question : nice weather ? (no ?) (note)

>>>             

test xcard create "Foster, Nate, 267.342.1099 (h)\n" = 
<<<
  <xcard>
    <vcard>
      <n>
        <family>Foster</family>
        <given>Nate</given>
      </n>
      <tel-home>267.342.1099</tel-home>
    </vcard>
  </xcard>
>>>

(* Some notes about the Apple Address Book application:
   - \ characters do NOT round-trip: It will read a vCard containing
   \\Manchester and write it out as \Manchester
   - it trims blanks from the ends of fields
   - Unknown vCard fields get dumped into NOTEs.
   - It wants X-ABLabel fields to know how to display things, but it
   doesn't require them
   - It sometimes uses item1, item2, etc., instead of the EMAIL tag
*)

(* TO DO:

   When processing a vCard, we might want to take *all* the fields we don't recognize
   (except, perhaps, some that we explicitly choose to delete) and put them in the note
   field in the abstract.  (This would mean that the lens is essentially a bijection.)

   To achieve this, it seems we'd need to...
      - use the order primitive to move the NOTE field to the end
      - then use order again to move all the recognized fields to the beginning
        and unrecognized fields to the end (before the NOTE)
      - then invent some convention for smashing them together with a separator, say $
      - escape $ everywhere it appears in the concrete vCard
      - In other formats (e.g. xCard), disallow $ in the concrete format of notes, except
        in situations where the whole note can be parsed as a real note plus some extra
        fields.  (I.e., basically the abstract and concrete note formats are the same.)

*)   

