(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007 J. Nathan Foster and Benjamin C. Pierce                  *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/examples/address.boom                                            *)
(* VCard, XCard, CSV address books lens                                        *)
(* $Id$ *)
(*******************************************************************************)

module Address = 

(* Some notes about the Apple Address Book application:
     - \ characters do NOT round-trip: It will read a vCard containing
       \\Manchester and write it out as \Manchester
     - it trims blanks from the ends of fields
     - Unknown vCard fields get dumped into NOTEs.
     - It wants X-ABLabel fields to know how to display things, but it
       doesn't require them
     - It sometimes uses item1, item2, etc., instead of the EMAIL tag
*)

(* -------------------------------------------------------------------- *)
(* GENERIC HELPERS *)
let Any : regexp = [^]*
let AnyP : regexp = [^]+

let StringNotContaining (r:regexp) : regexp = Any - (Any . r . Any)
let NonEmptyStringNotContaining (r:regexp) : regexp = AnyP - (Any . r. Any)

let WS : regexp = [ \n\t]*
let ws : lens = del WS

let NL = "\r"? . "\n"
let NonNL = StringNotContaining [\n\r]

let filterwith (both: regexp) (l: lens) : lens = 
  filter (both - (ctype l)) (ctype l) ; l*

(* -------------------------------------------------------------------- *)
(* ESCAPING *)

let Special : regexp = [\n\r\\]
let NonSpecial : regexp = [^\n\r\\]
let EscapedSpecial : regexp = [\\nr]

let EscapedStr (R:regexp) : regexp =
  let Normal = StringNotContaining (Special | R) in
  let Escaped = "\\" . (EscapedSpecial | R) in
  Normal . (Escaped . Normal)* 

let NonEmptyEscapedStr (R:regexp) : regexp = 
  let Normal = StringNotContaining (Special | R) in 
  let NonEmptyNormal = Normal - "" in 
  let Escaped = "\\" . (EscapedSpecial | R) in 
  let EscapedNormal = Escaped . Normal in 
  NonEmptyNormal . EscapedNormal* | EscapedNormal+

let escspecial : lens = ("\n" <-> "\\n" | "\r" <-> "\\r")

let escchar (c:regexp) : lens = 
  ( (ins "\\" . (c | "\\"))
  | escspecial
  | (NonSpecial - c))

let unescchar (c:regexp) : lens = invert (escchar c)

let escstr (c:regexp) : { ? <-> ? } = (escchar c)*

let unescstr (c:regexp) : { EscapedStr c <-> ? } = (unescchar c)*

let escNonEmptyStr (c:regexp) : { ? <-> NonEmptyEscapedStr c } = (escchar c)+
let unescNonEmptyStr (c:regexp) : { NonEmptyEscapedStr c <-> ? } = (unescchar c)+

(* unit tests for escaping *)
test (unescchar empty)* get "\n" = error
test (unescchar empty)* get "abc" = "abc"
test (unescchar empty)* get "\\\\" = "\\"
test (unescchar empty)* get "\\n" = "\n"
test (unescchar [,])* get "\\," = ","
test (escchar empty)* get "a\nb\\c" = "a\\nb\\\\c"
test (escchar [,])* get "a,b" = "a\\,b"

(* -------------------------------------------------------------------- *)
(* TELEPHONE AND NAMES *)

let TelTags : regexp = [hwce] | "note"
let TelMarker : regexp = " (" . TelTags . ")"
let Tel : regexp = ", " . (EscapedStr [,]) . TelMarker

let Name : regexp = (NonEmptyEscapedStr [,]) - ( Any . TelMarker )
let NonEmptyName : regexp = Name - ""
let Family : regexp = NonEmptyName
let Given : regexp = NonEmptyName
let GlobalName : regexp = Family . (", " . Given)?
  
let AbsAddr = GlobalName . Tel* 

let escaper (legal:regexp) (esc:regexp -> lens) (l:lens) (c:regexp) = 
  let mk_suffix (r:regexp) : lens = (legal - (r | c)) | l  in
  let suffix : lens = 
    ( (mk_suffix ")")
    | (mk_suffix [hwce]) . ")"
    | (mk_suffix [t(])   . "e)"
    | (mk_suffix [(])    . ( [hwc] . ")" | "note)" )
    | (mk_suffix [ ])    . ("(" . TelTags . ")")
    | (mk_suffix [o])    . "te)"
    | (mk_suffix [n])    . "ote)" ) in 
  ( esc c . suffix
  | ")" 
  | [hwce] . ")" 
  | "te)" 
  | "ote)"
  | "note)"
  | "(note)" 
  | "(" . [hwce] . ")")
            
let formatter : (regexp -> lens) -> lens -> regexp -> lens = 
  escaper [^\n\r\\] 

let formatspecial : lens = 
  ( "\\" <-> "\\\\" 
  | "," <-> "\\," 
  | "\n" <-> "\\n" 
  | "\r" <-> "\\r")
    
let unformatspecial : lens = 
  ( invert formatspecial
  | "\\:" <-> ":" 
  | "\\;" <-> ";" ) 

let formatnotemptyname : { ? <-> Name } = 
  formatter escstr formatspecial  [,]

let unformatnotemptyname : lens = 
  formatter unescstr unformatspecial [,;:]
  
let name : { ? <-> GlobalName } = 
  let escNonEmptyName (* : ? <-> Name *) = 
    unformatnotemptyname ; formatnotemptyname in
  let familyname (* : ? <-> Name *) = 
    del "N:" . escNonEmptyName in
  familyname . (del ";" | ";" <-> ", " . escNonEmptyName ) . del ";;;" 

test name get "N:Pierce;Benjamin C.;;;" = "Pierce, Benjamin C."

let formattel = escstr [,]

let field' (w0:string) (w1:string) (w2:string) =
  (w0 . ";") <-> ", " . 
  del "type=" . del w1 .
  del (";" . "type=" . [A-Z]+)* . 
  ("" | del ";type=pref") .
  del ":" . 
  (unescstr [;,:]; formattel) .
  ins " (" . ins w2 . ins ")" .
  del NL

let tel' = field' "TEL"

let tel =
    tel' "WORK" "w"
  | tel' "HOME" "h"
  | tel' "CELL" "c"

let formatnote = escstr [,]

let note =
  "NOTE:" <-> ", " .
  (unescstr [,:;]; formatnote) .
  ins " (note)" .
  del NL

let abemail =
  "item.EMAIL;type=INTERNET;type=pref:" <-> ", " .
  (unescstr [,:;]; escstr [,]) .
  del NL .
  del "item.X-ABLabel:E-mail" . del NL .
  ins " (e)" 

let email = field' "EMAIL" "INTERNET" "e"

let entry =  abemail | email | tel | note

let ItemLine = "item" . NonNL . NL
let Line = [^ ] . NonNL . NL . (" " . NonNL . NL)*

let Field =
      ((Line - ItemLine) | (ItemLine . ItemLine))
    - ("END:VCARD" . NL)

let NumberedItem (n:string) =
  "item" . n . "." . NonNL . NL . "item" . n . "." . NonNL . NL

let Field_unnumbered =
  Field - (NumberedItem "1" | NumberedItem "2" | NumberedItem "3")

let remove_item_numbers : { ? <-> Field_unnumbered* } = 
  let delItemNumber (n:string) = "item" . del n . "." . NonNL . NL .
                                 "item" . del n . "." . NonNL . NL in
  let Stuff = Field - ("item" . NonNL . NL . "item" . NonNL . NL) in
    Stuff* . delItemNumber "1" .
    Stuff* . delItemNumber "2" .
    Stuff* . delItemNumber "3" .
    Field_unnumbered* 
  | Stuff* . delItemNumber "1" .
    Stuff* . delItemNumber "2" .
    Field_unnumbered* 
  | Stuff* . delItemNumber "1" .
    Field_unnumbered* 
  | Field_unnumbered* 

let chunk : { ? <-> AbsAddr } = 
  del "BEGIN:VCARD" . del NL . del "VERSION:3.0" . del NL .  
  (name; key (atype name)) . del NL .
  (remove_item_numbers ;
   filterwith
     Field_unnumbered
     entry) .
  del "END:VCARD" . del NL

let vcard = <chunk>

let samplevcard = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    TEL;type=WORK;type=pref:6106236713
    FN:Andy Patroni
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    END:VCARD
    
  >>>

test vcard create "Foo, Jean-Paul, jean-paul.courbebaisse@education.gouv.fr (e), 1234567 (h), bar (e)" = 
<<<
             BEGIN:VCARD
             VERSION:3.0
             N:Foo;Jean-Paul;;;
             item1.EMAIL;type=INTERNET;type=pref:jean-paul.courbebaisse@education.gouv.fr
             item1.X-ABLabel:E-mail
             TEL;type=HOME:1234567
             item2.EMAIL;type=INTERNET;type=pref:bar
             item2.X-ABLabel:E-mail
             END:VCARD
             
>>>
test vcard put "Foo, Jean-Paul, bar (e)" 
into
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:AAAAA TEST;Jean-Paul;;;
    item1.EMAIL;type=INTERNET;type=pref:jean-paul.courbebaisse@education.gouv.fr
    item1.X-ABLabel:E-mail
    TEL;type=WORK:1234567
    item2.EMAIL;type=INTERNET;type=pref:foo
    item2.X-ABLabel:E-mail
    END:VCARD
    
  >>> = 
<<<
             BEGIN:VCARD
             VERSION:3.0
             N:Foo;Jean-Paul;;;
             item1.EMAIL;type=INTERNET;type=pref:bar
             item1.X-ABLabel:E-mail
             END:VCARD
             
>>>

test vcard get samplevcard = "Andy Patroni, 6106236713 (w)"

test vcard put "Andy Patroni, 12345 (c), 67890 (h)" into samplevcard = 
  "BEGIN:VCARD
  |VERSION:3.0
  |N:Andy Patroni;;;;
  |TEL;type=CELL:12345
  |FN:Andy Patroni
  |X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\\:ABPerson
  |TEL;type=HOME:67890
  |END:VCARD
  |"

test vcard put "Andy Patroni, fubar (note)" into samplevcard =
<<<BEGIN:VCARD
VERSION:3.0
N:Andy Patroni;;;;
NOTE:fubar
FN:Andy Patroni
X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
END:VCARD
>>>

let vcards = (<chunk> . ins "\n") * . ws

let samplevcards = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Androuet;;;;
    FN:Androuet
    NOTE:(01) 42 89 95 00  41 rue d'Amsterdam  M. Liege  (cheese restaurant near St. Lazare\, Paris)  rather expensive and fancy and pungent (300FF/person)
    X-ABUID:A5695B7A-5931-4A63-8308-ANOTHERIDENT0\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:New York Restaurants;;;;
    FN:New York Restaurants
    NOTE:two best mexican in nyc (according to Scot\, IIRC)\n          rosa mexicana\n          zarela's
    X-ABUID:D40A8D20-F5E8-47E1-983E-D331E92C6F8B\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Pierce;Benjamin C.;;;
    FN:Benjamin C. Pierce
    TEL;type=HOME;type=pref:215 732-4684
    TEL;type=CELL:215 266-9001
    TEL;type=WORK:215 898-6222
    X-ABUID:87B85E7E-AB0F-4819-8647-0BD532019144\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    FN:Andy Patroni
    TEL;type=WORK;type=pref:6106236713
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Bistro de Vent;;;;
    FN:Bistro de Vent
    X-ABUID:F00ABF1D-8DC0-4C3C-98ED-2BC33FA8D90C\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Biswas;Goutam;;;
    FN:Goutam Biswas
    X-ABUID:5BEAD7E0-AFF8-42AB-BD38-9A741CD64E20\:ABPerson
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Black;Andrew;;;
    FN:Andrew Black
    X-ABUID:A9BA5924-5A64-4D46-A40F-A0BC86073232\:ABPerson
    END:VCARD
    
  >>>
  
test vcards get samplevcards = 
  <<<
    Androuet, (01) 42 89 95 00  41 rue d'Amsterdam  M. Liege  (cheese restaurant near St. Lazare\, Paris)  rather expensive and fancy and pungent (300FF/person) (note)
    New York Restaurants, two best mexican in nyc (according to Scot\, IIRC)\n          rosa mexicana\n          zarela's (note)
    Pierce, Benjamin C., 215 732-4684 (h), 215 266-9001 (c), 215 898-6222 (w)
    Andy Patroni, 6106236713 (w)
    Bistro de Vent
    Biswas, Goutam
    Black, Andrew
    
  >>>

test vcards put 
  <<<
    Andy Patroni, 6106236713 (w), fubar (note)
    Pierce, Benjamin C., 215 898-6222 (w), 215 732-4684 (h), 215 266-9001 (c)
    
  >>>
into samplevcards = 
  <<<
    BEGIN:VCARD
    VERSION:3.0
    N:Andy Patroni;;;;
    FN:Andy Patroni
    TEL;type=WORK;type=pref:6106236713
    X-ABUID:827704A0-38A3-4034-84BF-BADFB87EB1E2\:ABPerson
    NOTE:fubar
    END:VCARD
    BEGIN:VCARD
    VERSION:3.0
    N:Pierce;Benjamin C.;;;
    FN:Benjamin C. Pierce
    TEL;type=WORK:215 898-6222
    TEL;type=HOME:215 732-4684
    TEL;type=CELL:215 266-9001
    X-ABUID:87B85E7E-AB0F-4819-8647-0BD532019144\:ABPerson
    END:VCARD
    
  >>>

(* test vcards get (read "/home/bcpierce/Desktop/vCards.vcf") = ? *)

(* -------------------------------------------------- *)
(* Generic XML stuff *)

let nl0 = "\n"
let nl1 = nl0 . "  "
let nl2 = nl1 . "  "
let nl3 = nl2 . "  "
let nl4 = nl3 . "  "

let del_xml_nl_var (def:string) = default ((del WS . del "\n") | "") def

let del_xml_nl (def:string) = del_xml_nl_var (def . "\n")

let single_line_elt (spaces:string) (tag:string) (body:lens) = 
  default (del WS) spaces .
  del ("<" . tag . ">") . body . 
  del ("</" . tag .">") 

(* the body deal with its newlines at its end *)

let multi_line_elt_no_nl (spaces:string) (tag:string) (body:lens) = 
  del ("<" . tag . ">") .
  body . 
  default (del WS) spaces . 
  del ("</" . tag .">") 

let multi_line_elt  (spaces:string) (tag:string) (body:lens) = 
  default (del WS) spaces .
  (multi_line_elt_no_nl spaces tag body) 

let special = 
  ( "&lt;" <-> "<" 
  | "&gt;" <-> ">" 
  | "&amp;" <-> "&")    
let R = [&<>]
let Normal = StringNotContaining R
let unescpcdata = Normal . (special . Normal)*  
  
let format_pcdata = escaper [^] (fun (c:regexp) -> unescpcdata) [] []

let pcdata = unescpcdata

(* -------------------------------------------------- *)
(* BCP's strange personal variant of XCard *)

let name : lens = 
  let n = format_pcdata; formatnotemptyname in 
  ( single_line_elt nl2 "n" n
  | (multi_line_elt nl2 "n" 
       (single_line_elt nl3 "family" n . 
       ("" | ins ", " . single_line_elt nl3 "given" n))))

let tel' (full:string) (short:string) = 
  ins ", " . single_line_elt nl2 full (pcdata ; formattel . ins (" (" . short . ")"))

let tel = 
    tel' "tel-home" "h"
  | tel' "tel-work" "w"
  | tel' "tel-cell" "c"
  | tel' "email"    "e"
  | tel' "note"     "note"

let chunk = multi_line_elt nl1 "vcard" ((name; key (atype name)) . tel* )

let foo = 
  "<vcard>
      <n><family>foo</family><given>bar</given></n>
      <tel-home>12345</tel-home>
      <tel-cell>12345</tel-cell>
      <note>hello world</note>
   </vcard>"

let vcard = <chunk>

test vcard get foo = "foo, bar, 12345 (h), 12345 (c), hello world (note)"

let xcard = multi_line_elt_no_nl nl0 "xcard" ((vcard . ins "\n") * )

let samplexcards = 
     "<xcard>
     | <vcard>
     |   <n>Charles Addams</n>
     |   <note>goodbye world</note></vcard>
     | <vcard>
     |   <n><family>Doe</family><given>John</given></n>
     |   <note>hello world</note>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home></vcard>
     | <vcard>
     |   <n><family>Doe</family><given>Sally</given></n>
     |   <tel-home>792-8134</tel-home>
     |   <tel-home>732-4684</tel-home>
     |   <note>hello, world ! Question : nice weather ? (no ?)</note>
     | </vcard>
     |</xcard>"

test xcard get samplexcards =
<<<Charles Addams, goodbye world (note)
Doe, John, hello world (note), 792-8134 (h), 732-4684 (h)
Doe, Sally, 792-8134 (h), 732-4684 (h), hello\, world ! Question : nice weather ? (no ?) (note)
>>>             

test xcard create "Foster, Nate, 267.342.1099 (h)\n" = 
<<<
<xcard>
  <vcard>
    <n>
      <family>Foster</family>
      <given>Nate</given>
    </n>
    <tel-home>267.342.1099</tel-home>
  </vcard>
</xcard>
>>>

(* TO DO:

   When processing a vCard, we might want to take *all* the fields we don't recognize
   (except, perhaps, some that we explicitly choose to delete) and put them in the note
   field in the abstract.  (This would mean that the lens is essentially a bijection.)

   To achieve this, it seems we'd need to...
      - use the order primitive to move the NOTE field to the end
      - then use order again to move all the recognized fields to the beginning
        and unrecognized fields to the end (before the NOTE)
      - then invent some convention for smashing them together with a separator, say $
      - escape $ everywhere it appears in the concrete vCard
      - In other formats (e.g. xCard), disallow $ in the concrete format of notes, except
        in situations where the whole note can be parsed as a real note plus some extra
        fields.  (I.e., basically the abstract and concrete note formats are the same.)

*)   

