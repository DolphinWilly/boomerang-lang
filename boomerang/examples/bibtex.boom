#{*}
(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007 J. Nathan Foster and Benjamin C. Pierce                  *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/examples/bibtex.boom                                             *)
(* BiBTeX <-> RIS lens                                                         *)
(* $Id$ *)
(*******************************************************************************)

module Bibtex = 

(* ABBREVIATIONS *)
let mk_cn : lens -> canonizer = canonizer_of_lens 

(* GLOBALS *)
let ANY : regexp = [^]*

let NONE : regexp = []

let CHAR : regexp = [a-zA-Z. ]
let ALPHA : regexp = [a-zA-Z.]
let WS : regexp = [ \n]
let tag (s:string) : string = s . "  - "

let ANY_TAG : regexp = [A-Z] . [A-Z0-9] . /  - /

let NO_TAGS (r:regexp) : regexp = 
  r - (ANY . ANY_TAG . ANY)

let ty_tag : string = tag "TY"
let au_tag : string = tag "AU"

(* AUTHORS *)
let author : lens = 
  let ANY_AND : regexp = ANY . /and/ . ANY in
  let string_no_ws : lens = copy (ALPHA+ - ANY_AND) in
  let string_ws : lens = copy ((ALPHA . CHAR* . ALPHA) - ANY_AND) in
  ins au_tag . 
  ( (string_no_ws . copy /, / . string_ws)
  | (string_ws . del / /) ~ (string_no_ws . ins ", "))

(* process a list of authors *)
let wsp_and : regexp = 
  WS+ . /and/ . WS+
let authors : lens = 
  author | author . ( default (wsp_and <-> "\n") " and " . author)+

(* unit tests *)
test author.get "Pierce, Benjamin C." = "AU  - Pierce, Benjamin C."
test author.get "Foster, J. Nathan" = "AU  - Foster, J. Nathan"
test author.get "J. Nathan Foster" = "AU  - Foster, J. Nathan"
test author.put "AU  - Foster, J. Nathan" into "Foster, John" = "Foster, J. Nathan"
test author.put "AU  - Foster, J. Nathan" into "J. Nathan Foster" = "J. Nathan Foster"
test authors.get
  "Aaron Bohannon and J. Nathan Foster and Benjamin C. Pierce" =
  "AU  - Bohannon, Aaron
  |AU  - Foster, J. Nathan
  |AU  - Pierce, Benjamin C."

test authors.get
  "Bohannon, Aaron and Foster, J. Nathan and Pierce, Benjamin C." = 
  "AU  - Bohannon, Aaron
  |AU  - Foster, J. Nathan
  |AU  - Pierce, Benjamin C."

test authors.get 
  "Bohannon, Aaron and Foster, J. Nathan and Benjamin C. Pierce" = 
  "AU  - Bohannon, Aaron
  |AU  - Foster, J. Nathan
  |AU  - Pierce, Benjamin C."

test authors.create 
  "AU  - Bohannon, Aaron
  |AU  - Foster, J. Nathan
  |AU  - Pierce, Benjamin C." = 
  "Bohannon, Aaron and Foster, J. Nathan and Pierce, Benjamin C."

test authors.get
    <<
        J. Nathan Foster 
               and Benjamin C. Pierce 
               and Alan Schmitt
    >> = 
    <<
        AU  - Foster, J. Nathan
        AU  - Pierce, Benjamin C.
        AU  - Schmitt, Alan
    >>

(* HELPER FUNCTIONS *)
let ws = [ \t]*

let to_lower : (lens in [^@{}"] <-> ([a-z] | [^A-Z@{}"])) = 
  ( ([aA] <-> "a") 
  | ([bB] <-> "b")  
  | ([cC] <-> "c")  
  | ([dD] <-> "d")  
  | ([eE] <-> "e")  
  | ([fF] <-> "f")  
  | ([gG] <-> "g")  
  | ([hH] <-> "h")  
  | ([iI] <-> "i")  
  | ([jJ] <-> "j")     
  | ([kK] <-> "k")  
  | ([lL] <-> "l")  
  | ([mM] <-> "m")  
  | ([nN] <-> "n")  
  | ([oO] <-> "o")  
  | ([pP] <-> "p")  
  | ([qQ] <-> "q")  
  | ([rR] <-> "r")  
  | ([sS] <-> "s")  
  | ([tT] <-> "t")  
  | ([uU] <-> "u")  
  | ([vV] <-> "v")  
  | ([wW] <-> "w")  
  | ([xX] <-> "x")  
  | ([yY] <-> "y")  
  | ([zZ] <-> "z")  
  | copy [^a-zA-Z@{}"] ) (* " *)

let lower : regexp = [^A-Z@{}"]     (* " *)
let upper : regexp = [A-Z] 
let lower_no_ws = [^A-Z@{}" \n\t]   (* " *)
let ws = [ \n\t]

let braces : (lens in (/{/ . [^@{}"]+ . /}/) <-> (([{] . [A-Z] . [}]) | lower)+ ) = 
  del /{/ . 
    (ins "{" . copy upper . ins "}" | 
     copy lower)+ . 
  del /}/

test braces get "{HeLlO}" = "{H}e{L}l{O}"
test braces create "{F}oo" = "{Foo}"
test braces create "ho{W}{D}{Y}" = "{hoWDY}"

(* how do we write precise types for canonizers? *)
let empty_cn : canonizer = mk_cn (copy //)

let first_cn : canonizer = mk_cn (ins "{" . copy upper . ins "}" | copy lower | braces)

test cls first_cn "H" = "{H}"
test cls first_cn "f" = "f"
test cls first_cn "{HeLlO}" = "{H}e{L}l{O}"

(* NOTE: must be lazy star *)
(* what is lazy star? JNF *)
let rest_cn  : canonizer = (mk_cn (to_lower | braces))*

(* NOTE: must be lazy dot *)
(* what is lazy dot? *)
let title_can : canonizer = empty_cn | (first_cn . rest_cn)

test rep title_can "{L}{O}{O}{J}: {W}eaving {L}{O}{O}{M} into {J}ava" = 
                   "L{O}{O}{J}: {W}eaving {L}{O}{O}{M} into {J}ava"

let canonize_title 
  : (lens in ([^@{}"] | "{" . [^@{}"]+ . "}")* <->
             ((" "? . [^@{}" \n\t])* . " "? ))
  =
  (* ??? should we bother? it will only be messier 
     than the outer type *)
  let l : lens = 
    ((copy lower_no_ws 
     | del /{/ . copy upper . del /}/
     | (ws+ <-> " ") . copy lower_no_ws
     | (ws+ <-> " ") . del /{/ . copy upper . del /}/)* )
      . (copy // | (ws+ <-> " ")) in 
    left_quot title_can l

test canonize_title.get "LOOJ: {W}eaving {LOOM} into {Java}" = 
"Looj: Weaving LOOM into Java"

test canonize_title.get "Looj: {W}eaving {LOOM} into {Java}" = 
"Looj: Weaving LOOM into Java"

test canonize_title.put "LOOJ: Weaving LOOM into Java" into "{LOOJ}: {Weaving LOOM into Java}" = 
"L{O}{O}{J}: {W}eaving {L}{O}{O}{M} into {J}ava"

test canonize_title.get 
  "A {L}ogic {Y}our {T}ypechecker {C}an {C}ount {O}n: {U}nordered {T}ree {T}ypes in {P}ractice" =
  "A Logic Your Typechecker Can Count On: Unordered Tree Types in Practice"

(* VALUES *)
let ws_nl = [ \t\n]*

let esc (s:string) = str ("\\" . s)
let bare_value = [A-Za-z0-9]+
let braced_value = no_tags ([^@{}\\] | esc "{" | esc "}")*
let quoted_value = no_tags ([^@"\\] | esc "\"")*            (* " *)

(* FIELDS *)
let start_field (lb:string) : regexp = ws* . /=/ . ws* . str lb
let end_field (rb:string) : regexp = str rb . [ ]* . /,/ . [ ]* . /\n/

let mk_template 
  (lb:string) 
  (l:lens where splittable (del (start_field lb)) l) 
  (rb:string where splittable (del (start_field lb) . l) (del (end_field rb)))
  : (lens in ((start_field lb) . (ctype l) . (end_field rb)) <-> (atype l))
  = 
  del (start_field lb) . l . del (end_field rb)

(* I lifted this out to avoid re-calculating the NFAs for the
   preamble. I don't know if this saves us much because we still have
   to copy the (huge) Array.ts each time this function is invoked, but
   it can't hurt *)
let quoted_preamble = mk_template "\"" (copy quoted_value) "\""
let braced_preamble = mk_template "{" (copy braced_value) "}"
let bare_preamble = mk_template "" (copy bare_value) ""
let any_preamble = quoted_preamble | braced_preamble | bare_preamble 

let std_field_bibtex (o:regexp) = ws_nl . o . (ctype any_preamble)
let std_field_ris (r:string) (c:string) = (str r) . (atype any_preamble) . (str c)

(* str concatenations in atype of return are fine; we only need the check on o *)
let do_std_field
  (r:string) 
  (o:regexp where splittable (del o) any_preamble)
  (c:string) 
  : (lens in std_field_bibtex o <-> std_field_ris r c)
  = 
  (ws_nl <-> r) . del o . any_preamble . ins c
      
let mk_do_field 
  (r:string) 
  (lo:regexp -> lens) 
  (o:regexp) 
  (lb:string) 
  (l:lens) 
  (rb:string where splittable (lo o) (mk_template lb l rb))
  (c:string) 
  : (lens in 
      (ws_nl . (ctype (lo o . mk_template lb l rb))) <-> 
      ((str r) . (atype (lo o . mk_template lb l rb)) . (str c)))
  = 
  (ws_nl <-> r) . lo o . mk_template lb l rb . ins c

let field_bibtex (loo:lens) (l1:lens) (l2:lens) (l3:lens) =
  let tmpl1 = mk_template "{" l1 "}" in
  let tmpl2 = mk_template "\"" l2 "\"" in
  let tmpl3 = mk_template "" l3 "" in
  let templates = tmpl1 | tmpl2 | tmpl3 in
  ws_nl . (ctype loo) . (ctype templates)

let field_ris (r:string) (loo:lens) (l1:lens) (l2:lens) (l3:lens) (c:string) =
  let tmpl1 = mk_template "{" l1 "}" in
  let tmpl2 = mk_template "\"" l2 "\"" in
  let tmpl3 = mk_template "" l3 "" in
  let templates = tmpl1 | tmpl2 | tmpl3 in
  (str r) . (atype loo) . (atype templates) . (str c)

let uniform_field_bibtex (loo:lens) (l:lens) = field_bibtex loo l l l
let uniform_field_ris (r:string) (loo:lens) (l:lens) (c:string) =
  field_ris r loo l l l c

let do_field 
  (r:string) 
  (lo:regexp -> lens) 
  (o:regexp) 
  (l1:lens where splittable (lo o) (mk_template "{" l1 "}"))
  (l2:lens where splittable (lo o) (mk_template "\"" l2 "\""))
  (l3:lens where splittable (lo o) (mk_template "" l3 ""))
  (c:string) 
  : (lens in 
    field_bibtex (lo o) l1 l2 l3 <-> field_ris r (lo o) l1 l2 l3)
  =
    mk_do_field r lo o "{" l1 "}" c
  | mk_do_field r lo o "\"" l2 "\"" c
  | mk_do_field r lo o "" l3 "" c

(* special processors for fields *)
let digits = [0-9]+

let page_value 
  : (lens in (digits . [\-]+ . digits) <->
             (/SP  - / . digits . /\n/ . /EP  - / . digits))
  = 
  ins (tag "SP") . copy [0-9]+ . ins "\n" . 
  del [\-]+ . 
  ins (tag "EP") . copy [0-9]+ 

let month_data = 
    (/January/ | /jan/) <-> "01"
  | (/February/ | /feb/) <-> "02"
  | (/March/ | /mar/) <-> "03"
  | (/April/ | /apr/) <-> "04"
  | (/May/ | /may/) <-> "05"
  | (/June/ | /jun/) <-> "06"
  | (/July/ | /jul/) <-> "07"
  | (/August/ | /aug/) <-> "08"
  | (/September/ | /sep/) <-> "09"
  | (/October/ | /oct/) <-> "10"
  | (/November/ | /nov/) <-> "11"
  | (/December/ | /dec/) <-> "12"

let month_str = ctype month_data
let month_num = atype month_data

let dates_bibtex = 
  (std_field_bibtex /year/) . (uniform_field_bibtex (del /month/) month_data)?

let dates_ris = "PY  - " . (no_tags bare_value) . "/" . month_num? . (str "//\n")

let do_dates : (lens in dates_bibtex <-> dates_ris) = 
  let do_year = do_std_field (tag "PY") /year/ "/" in
  let do_month = do_field "" del /month/ month_data month_data month_data "" in 
    (do_year . do_month?)
    . ins "//" 
    . ins "\n"

let title_bibtex = 
  field_bibtex (del /title/) canonize_title canonize_title (copy bare_value)

let title_ris =
  field_ris (tag "T1") (del /title/) 
            canonize_title canonize_title (copy bare_value)
            "\n"

let do_title : (lens in title_bibtex <-> title_ris) = 
  do_field (tag "T1") del /title/ 
           canonize_title canonize_title (copy bare_value) "\n"

let pages_bibtex =
  field_bibtex (del /pages/) page_value page_value (copy none)

let pages_ris =
  field_ris "" (del /pages/) page_value page_value (copy none) "\n"

let do_pages : (lens in pages_bibtex <-> pages_ris) = 
  do_field "" del /pages/ page_value page_value (copy none) "\n"


let non_field = ([a-zA-Z]+ - 
                  (/author/ | /title/ | /booktitle/ | /journal/ | /volume/ | 
                   /number/ | /note/ | /pages/ | /year/ | /month/ | /address/ |
                   /url/ | /pdf/ | /issn/ | /publisher/ | /abstract/ |
                   /series/))
let noteize (r:regexp) = (copy r) . ins ": "

let field_to_note_bibtex = 
  field_bibtex (noteize non_field)
               (copy braced_value) (copy quoted_value) (copy bare_value)

let field_to_note_ris =
  field_ris (tag "M1") (noteize non_field)
            (copy braced_value) (copy quoted_value) (copy bare_value)
            "\n"

let do_field_to_note : (lens in field_to_note_bibtex <-> field_to_note_ris) = 
    do_field (tag "M1") noteize non_field 
             (copy braced_value) (copy quoted_value) (copy bare_value)
             "\n"
  
let field_ris_tnl (r:string) = std_field_ris (tag r) "\n"

let non_author_fields 
  : (lens in 
      (title_bibtex | dates_bibtex | pages_bibtex |
       std_field_bibtex /booktitle/ | std_field_bibtex /journal/ |
       std_field_bibtex /volume/    | std_field_bibtex /number/ |
       std_field_bibtex /note/      | std_field_bibtex /address/ |
       std_field_bibtex /url/       | std_field_bibtex /pdf/ |
       std_field_bibtex /issn/      | std_field_bibtex /publisher/ |
       std_field_bibtex /abstract/  | std_field_bibtex /series/ |
       field_to_note_bibtex)* 
    <->
      (title_ris | dates_ris | pages_ris |
       field_ris_tnl "T2" | field_ris_tnl "JO" |
       field_ris_tnl "VL" | field_ris_tnl "IS" |
       field_ris_tnl "N1" | field_ris_tnl "AD" |
       field_ris_tnl "UR" | field_ris_tnl "L1" |
       field_ris_tnl "SN" | field_ris_tnl "PB" |
       field_ris_tnl "N2" | field_ris_tnl "T3" |
       field_to_note_ris)* ) 
  = 
  ( do_title
  | do_dates
  | do_pages
  | do_std_field (tag "T2") /booktitle/ "\n" 
  | do_std_field (tag "JO") /journal/ "\n"
  | do_std_field (tag "VL") /volume/ "\n"
  | do_std_field (tag "IS") /number/ "\n"
  | do_std_field (tag "N1") /note/ "\n"
  | do_std_field (tag "AD") /address/ "\n" 
  | do_std_field (tag "UR") /url/ "\n"
  | do_std_field (tag "L1") /pdf/ "\n"
  | do_std_field (tag "SN") /issn/ "\n"
  | do_std_field (tag "PB") /publisher/ "\n"
  | do_std_field (tag "N2") /abstract/ "\n"
  | do_std_field (tag "T3") /series/ "\n"
  | do_field_to_note)* (* star is on the whole union *) 

let author_field 
  : (lens in (field_bibtex (del /author/) authors authors (copy none)) 
         <-> (field_ris "" (del /author/) authors authors (copy none) "\n"))
  = 
    do_field "" del /author/ authors authors (copy none) "\n"

let fields_bibtex = (ctype author_field) . (ctype non_author_fields)
let fields_ris = (atype author_field) . (atype non_author_fields)

let fields : (lens in fields_bibtex <-> fields_ris) 
  = 
  author_field . non_author_fields

let key_re = [^@{}",\n ]+

let key_bibtex = key_re . /,/ . [ ]* . /\n/
let key_ris = (str (tag "ID")) . key_re

let do_key 
  : (lens in key_bibtex <-> key_ris)
  = ins (tag "ID") . key [^@{}",\n ]+ . ((/,/ . [ ]* . /\n/) <-> "")

test do_key get "dtts,\n" = ?

let type_bibtex (b:string) = /@/ . (str b) . ws_nl . /{/
let type_ris (r:string) = /TY  - / . (str r)

(* trivially splittable -- everything is constant strings*)
let do_type (b:string) (r:string) 
  : (lens in type_bibtex b <-> type_ris r)
  = (/@/ . (str b) . ws_nl . /{/) <-> ("TY  - " . r)


let chunk_bibtex =
  (type_bibtex "article"       | type_bibtex "inproceedings" |
   type_bibtex "misc"          | type_bibtex "incollection" |
   type_bibtex "mastersthesis" | type_bibtex "manual" |
   type_bibtex "phdthesis") .  (* includes the open { *)
  key_bibtex . fields_bibtex . ws_nl . /}/

let chunk_ris =
  (type_ris "JOUR" | type_ris "CONF" | type_ris "UNPB" |
   type_ris "CHAP" | type_ris "THES" | type_ris "COMP") . "\n" .
  key_ris . "\n" . fields_ris . "ER  -\n\n"

let chunk : (lens in chunk_bibtex <-> chunk_ris) = 
  ( do_type "article" "JOUR" 
  | do_type "inproceedings" "CONF"
  | do_type "misc" "UNPB"
  | do_type "incollection" "CHAP"
  | do_type "mastersthesis" "THES"
  | do_type "manual" "COMP"
  | do_type "phdthesis" "THES")
  . ins "\n" . 
  do_key . ins "\n" . 
  fields . 
  ((ws_nl . /}/) <-> "ER  -\n\n")

let non_entry = 
  any - (any . 
         (/@/ . (/article/       | /inproceedings/ | /misc/ | /incollection/ |
                 /mastersthesis/ | /manual/        | /phdthesis/)) .
         any)

let del_non_entry : (lens in non_entry <-> //) 
  = del non_entry
    
let ris : (lens in ((non_entry . chunk_bibtex)* . non_entry) <-> chunk_ris* )
  = del_non_entry 
  | del_non_entry . <chunk> . (del_non_entry . <chunk>)* . del_non_entry

test ris.get 
<<

  @inproceedings{dtts,
     author = {J. Nathan Foster 
               and Benjamin C. Pierce 
               and Alan Schmitt},
     title =  {A {L}ogic {Y}our {T}ypechecker {C}an {C}ount {O}n: {U}nordered {T}ree {T}ypes in {P}ractice},
     booktitle = planx07,
     year =   2007,
     month = jan,
     pages = {80--90},
     conf=    {http://www.cis.upenn.edu/~jnfoster/papers/dtts.pdf},
     slides = {http://www.cis.upenn.edu/~jnfoster/papers/dtts-slides.pdf},
     jnf =    "yes",
   }
>> = 
<<
TY  - CONF
ID  - dtts
AU  - Foster, J. Nathan
AU  - Pierce, Benjamin C.
AU  - Schmitt, Alan
T1  - A Logic Your Typechecker Can Count On: Unordered Tree Types in Practice
T2  - planx07
PY  - 2007/01//
SP  - 80
EP  - 90
M1  - conf: http://www.cis.upenn.edu/~jnfoster/papers/dtts.pdf
M1  - slides: http://www.cis.upenn.edu/~jnfoster/papers/dtts-slides.pdf
M1  - jnf: yes
ER  -


>>

test ris.get 
"@article{Lenses-TOPLAS05,
| author = {J. Nathan Foster and Michael B. Greenwald and Jonathan T. Moore and Benjamin C. Pierce and Alan Schmitt},
| title = {Combinators for Bidirectional Tree Transformations: 
|          {A} Linguistic Approach to the View Update Problem},
| journal = {Transactions on Programming Languages and Systems (TOPLAS)},
| year = {2007},
| month = may,
| pages = {233--246},
| address = {New York, NY, USA},
|} 
|
|@inproceedings{SchemaSync-DBPL05,
|  author    = {Foster, J. Nathan and Greenwald, Michael B. and Kirkegaard, Christian and Pierce, Benjamin C. and Schmitt, Alan},
|  title     = {Exploiting Schemas in Data Synchronization},
|  booktitle = {Database Programming Languages (DBPL), Trondheim, Norway},
|  year      = {2005},
|  month     = {August}, 
|  pages     = {42--57},
|}
|" = 
<<
TY  - JOUR
ID  - Lenses-TOPLAS05
AU  - Foster, J. Nathan
AU  - Greenwald, Michael B.
AU  - Moore, Jonathan T.
AU  - Pierce, Benjamin C.
AU  - Schmitt, Alan
T1  - Combinators for bidirectional tree transformations: A linguistic approach to the view update problem
JO  - Transactions on Programming Languages and Systems (TOPLAS)
PY  - 2007/05//
SP  - 233
EP  - 246
AD  - New York, NY, USA
ER  -

TY  - CONF
ID  - SchemaSync-DBPL05
AU  - Foster, J. Nathan
AU  - Greenwald, Michael B.
AU  - Kirkegaard, Christian
AU  - Pierce, Benjamin C.
AU  - Schmitt, Alan
T1  - Exploiting schemas in data synchronization
T2  - Database Programming Languages (DBPL), Trondheim, Norway
PY  - 2005/08//
SP  - 42
EP  - 57
ER  -


>>
 
