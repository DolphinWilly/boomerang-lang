(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007 J. Nathan Foster and Benjamin C. Pierce                  *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/examples/units.boom                                              *)
(* Boomerang unit tests                                                        *)
(* $Id$ *)
(*******************************************************************************)

module Units = 

let x : { ? <-> ? } = [^]*

type mytype = A | B of regexp

let x = B "nate"

let y = match x with | A -> ("","") | B z -> (z . " " . "foster", "levine 561")

let z = match y with (x,y) -> x

test y = ?
test y : ?
test z : ?
test "<< " . z . " >>" = ?

(*let cl1 = lowercase [A-Za-z ] | del "{" . [A-Za-z ]+ . del "}" *)
(*let cl2 = smash_clens cl1
test cl2 get "{LOOJ} {W}eaving {LOOM} into {J}ava" = ? 
test cl2 put 
"LOOJ Weaving loom into Java" into 
"{L}{O}{O}{J} {W}eaving {LOOM} into {J}ava" = ? 
*)
test "---- DONE ----" get "---- DONE ----" = "---- DONE ----"

(*test lowercase [a-zA-Z ]+ get "LOOJ Weaving LOOM into Java" = ?
test lowercase [@-[ a-z]+ put 
  "looj weaving loom into java" 
into 
  "LOOJ Weaving LOOM into JAVA" = ?
*)
let foo = "foo"
let bar = del "bar"
let foobar = foo . bar
let foobarbis = foo | bar

let otherbar = "bar"
let otherfoobar = foo . otherbar

let chunk = "Last Name" <-> "LAST NAME" 

test ("First Name " . ("Last Name" ; <chunk>)) get "First Name Last Name" 
= "First Name LAST NAME"

let opt (l:lens) (C:regexp) (A:regexp) = (l | "")
test opt ("A" <-> "BB") "A" "BB" get "A" = "BB"

let l = "A" ~ ("B" ~ "C") 
test l get "ABC" = "CBA"

let R = [\\]

let R = "a"|"b"
let l = R{0,2}
test l get "" = ""
test l get "aa" = "aa"
test l put "" into "a" = ""
test l put "a" into "" = "a"

(* check ambiguous on aababa *)
test
  (cp "a" . [ab]* . "ab").(cp "a" . [ab]*)
get "aaba" = error

test  ("abc" . (del "123" . "4") * . "def") get "abc1234def" = "abc4def"

test [b-c] get "a" = error
test [b-c] get "b" = "b"
test [b-c] get "c" = "c"
test [b-c] get "d" = error

(* ambiguity checker *)
let any = [^,]
let alpha = [a-zA-Z]
let ws = [ ]
let author = (alpha . any* . alpha) - (any* . ws . "and" . ws . any*)

test (del [^]* )* get "" = error

test (const [^]* "hihi" "haha")* get "" = error

test (const ("b"|"abb"|"abbba"|"bba"|"baabb") "paf" "baabb")* get "" = error

test (const ("a"."b"*) "!" "abbbb")* put "!!!!" into "aaa" = "aaaabbbb"

(* test of finite repetitions*)
test const "ah"{2,4} "haha" "ahah" .
     del [ ]*.
     const "" " " "" . 
     const "test" "ok" "test" 
get "ahahah     test" 
= "haha ok"

(* bad repetitions *)
(* test const "ah"{4,2} "haha" "ahah" get "ahahah" = error *)
test const "ah"{1,2} "haha" "ahah" get "ahahah" = error

test del empty get "" = error

let everything = [^]*
let r1 = everything - (everything.("ab"|"ca").everything)
let l1 = del r1
let k1 = ("ab" <-> "ABC") | ("ca" <-> "CBA")

(* ambiguity on "cabab" *)
test (l1.k1)*.l1 get "test" = error

(* need to check if the removed string finishs by 'c' *)
let r2 = r1 - (everything."c")
let l2 = del r2
let r3 = r1."c"
let l3 = del (r1."c")
let k2 = "ca" <-> "CBA"
let l = (l2.k1|l3.k2)*.l1 
test l get "ab ab saaaalut ca ca" = "ABCABCCBACBA"
test l put "CBACBAABCABC" into "ab ab hihi ca ca" = "ca ca hihi ab ab"

(* fails because the strings could contain "ABC". Counter example : ABCABC*)
test (r2.k1|r3.k2)*.r1 get "123ab 1ab23" = error

let name = del "NAME:" . [^\n:]*

let unesc = "\\," <-> "," | [^\\,]
let note = "NOTE:" <-> ": " . unesc*

let vc = name . (del [\n]+ . note)?

(*with an existing note, it's ok*)
test vc put "Nobody: Interresting note, no" into
"NAME:Nobody
|NOTE:something" =
"NAME:Nobody
|NOTE:Interresting note\\, no"

(* when the note does not contain a ',' it's ok *)
test vc put "Nobody: Interresting note" into
"NAME:Nobody" =
"NAME:Nobody
|NOTE:Interresting note"


(* and with a coma and no existing note, we don't have a problem either :) *)
test vc put "Nobody: Interresting note, no" into
"NAME:Nobody" =
"NAME:Nobody
|NOTE:Interresting note\\, no"


(* testing of regexp representation *)

let bs = "One string"
let balt = "one" | "the other"
let bseq = bs . balt
let bmin = [abc] - [a]
test (string_of_regexp (empty . bseq) ) = 
  "empty"

test (string_of_regexp (bs | bseq . balt)) = 
  <<<"One string" | bseq . balt>>>

test (string_of_regexp (bmin . bseq | balt)) = 
  <<<bmin . bseq | balt>>>

test (string_of_regexp (bmin & bseq . balt)) = 
  <<<bmin & bseq . balt>>>


test (string_of_regexp (bmin . bseq | balt*)) =
  <<<bmin . bseq | balt*>>>

test (string_of_regexp ((bmin . balt)*))=
  <<<(bmin . balt)*>>>

test (string_of_regexp (bseq . (bmin . balt)))=
  <<<bseq . (bmin . balt)>>>

test (string_of_regexp (bseq | ([abc] - [ab])))=
  <<<bseq | ([abc] - [ab])>>>

test (string_of_regexp ((bseq | [abc]) - [ab]))=
  <<<(bseq | [abc]) - [ab]>>>

test (string_of_regexp ((bmin . balt){1,3}))=
  <<<bmin . balt | bmin . balt . (bmin . balt) | bmin . balt . (bmin . balt . (bmin . balt))>>>
      
test (string_of_regexp ((bmin . balt){2,}))=
  <<<bmin . balt . (bmin . balt . (bmin . balt)*)>>>
    
test (string_of_regexp ((bmin . balt)?))=
  <<<"" | bmin . balt>>>

(*let me = move_end [ab] [CD]

test me get "abbababbabbbCababbaa" = 
              "abbababbabbbababbaaC"

test me put  "abbababbabbbababbaaD"
	  into "aaaaaaaaaCaa" = 
               "abbababbaDbbbababbaa"

test me put  "abbabaaD"
	  into "aaaaaaaaaCaa" = 
               "abbabaaD"
*)




(* probleme with convertion between type :-\ *)
let a1 = "a"

(* a new lense is created from the *string* a1 each time, so a unique id is generated *)
test (<a1> . <a1>) get "aa" = error 
test (<a1:a1> . <a2:a1>) get "aa" = "aa"

let a3 = cp "a"
test (<a3>.<a3>) get "aa" = "aa"


(* dictionaries are (not) shared *)

let l = key [a-z]* . del [0-9]{4}

(* dictionaries are shared *)
test (<l> ."\n". <l>) put 
<<<
foo
bar
>>>
into 
<<<
bar1234
foo5678
>>>
=
<<<
foo5678
bar1234
>>>


(* dictionaries are *not* shared *)
test (<tag1:l> ."\n". <tag2:l>) put 
<<<
foo
bar
>>>
into 
<<<
bar1234
foo5678
>>>
=
<<<
foo0000
bar0000
>>>






(***** strange things... ****)

let alpha = [a-z]
let strange_chunk = key alpha . del alpha

let strange = (<strange_chunk> . <strange_chunk>);<strange_chunk>

test strange get "abcd" = "a"

test strange put "z" into "abcd" = "zaac"

let strange = (<bis:strange_chunk> . <bis:strange_chunk>);<strange_chunk>

test strange get "abcd" = "a"

test strange put "z" into "abcd" = "zaab"

(*** not strange anymore ***)

let chunk = key alpha{3} . del [0-9]{2}

let normal_def = 
default <chunk> "zzz42"

let strange_def = 
default <chunk> "foo42"


let normal_l = normal_def*. "," . normal_def
let strange_l = strange_def* ."," .strange_def

(* swaping of values *) 
test normal_l put "bar,foo" into "foo11,bar22"= "bar22,foo11"
test strange_l put "bar,foo" into "foo11,bar22"= "bar22,foo11"

test normal_l put "barbar,foo" into "foo11,bar22" = "bar22bar00,foo11"
test strange_l put "barbar,foo" into "foo11,bar22" = "bar22bar00,foo11" (* use to be "bar22bar00,foo42"*)



(**** Algebraic laws ****)

(* we don't have l1.(l2|l3) = l1.l2 | l1.l3 *)

let l1 = ("a" | "aa")
let l2 = "c" <-> "a"
let l3 = "d" <-> "aa"

test (l1.l2 | l1.l3) get "ac" = "aa"
test (l1.(l2|l3)) get "ac" = error
