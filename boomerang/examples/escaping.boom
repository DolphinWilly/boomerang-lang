module Escaping = 

let ANYCHAR = [^]

let ANY = ANYCHAR*

(* FIRST TRY:

let unrender_quotedstr =
    "\"" <-> "" 
  . copy ANY
  . "\"" <-> "" 

let unescape_quotedstr_char =
    "\\\"" <-> "\""
  | "\\\\" <-> "\\"
  | copy (ANYCHAR - [\\"])

let unescape_quotedstr = unescape_quotedstr_char*

test unescape_quotedstr get 
    <<<
        <hello\"world>
    >>> 
  = 
    <<<
        <hello"world>
    >>> 

let tester = unrender_quotedstr ; unescape_quotedstr
(* DOESN'T WORK!! *)
*)

let unrender_quotedstr R =
    "\"" <-> "" 
  . copy R
  . "\"" <-> "" 

let unescape_quotedstr_char =
    "\\\"" <-> "\""
  | "\\\\" <-> "\\"
  | copy (ANYCHAR - [\\])

let unescape_quotedstr = unescape_quotedstr_char*

test unescape_quotedstr get 
    <<<
        <hello\"world>
    >>> 
  = 
    <<<
        <hello"world>
    >>> 

let test1 = unrender_quotedstr (ctype unescape_quotedstr) ; unescape_quotedstr

(* Does this transformation work in general? *)

(* Making the example harder: Make the ASCII into a CSV... *)

let escape_xml_char = 
    "<" <-> "&lt;"
  | ">" <-> "&gt;"
  | "&" <-> "&amp;"
  | copy (ANYCHAR - [<>&])

let escape_xml = escape_xml_char*

let render_tag R = 
    "" <-> "<tag>"
  . copy R
  . "" <-> "</tag>"

let test2 = escape_xml; render_tag (atype escape_xml) 

test test2 get 
    <<<
        <hello"world>
    >>> 
  = 
    <<<
        <tag>&lt;hello"world&gt;</tag>
    >>> 
    
let l = test1 ; test2

test l get 
    <<<
        " <hello\"world> "
    >>> 
  = <<<
        <tag> &lt;hello"world&gt; </tag>
    >>>

(* That works.  So let's make it more generic... *)

let render R before after = 
    "" <-> before
  . copy R
  . "" <-> after

let render_xml R = render R "<tag>" "</tag>"

let render_tag R tag = render R ("<" . tag . ">") ("</" . tag . ">")

let render_str R = render R "\"" "\""

let unrender_str R = invert (render_str R)

(* Takes initial escape character (e.g., '\', '&') and set of
character/code papers *)
let escape (pairs : (string * string) List.t) =
  let escaped =
    List.fold_left
      (fun r p ->
         match p with
           (from,to) -> ((str from) | r))
      []
      pairs
  in
  let escape_char =
    List.fold_left
      (fun l p -> 
         match p with 
           (from,to) -> ((from <-> to) | l))
      (copy (ANYCHAR - escaped))
      pairs
  in
    escape_char*

let xml_escs : (string * string) List.t =
  List.Cons((">","&gt;"),
  List.Cons(("<","&lt;"),
  List.Cons(("&","&amp;"), 
  List.Nil)))

let escape_xml = escape xml_escs

let str_escs =
  List.Cons(("\"","\\\""),
  List.Cons(("\\","\\\\"),
  List.Nil))

let escape_str = escape str_escs

let unescape_str = invert escape_str

let l2 = 
  unrender_str (ctype unescape_str) ; unescape_str ; 
  escape_xml ; render_xml (atype escape_xml)

test l2 get 
    <<<
        " <hello\"world> "
    >>> 
  = <<<
        <tag> &lt;hello"world&gt; </tag>
    >>>

(* TODO move this to lenses/list.boom at some point *)
let list_reverse l =
  List.fold_left (fun l p -> (List.Cons(p,l))) List.Nil l

let list_map (f : 'a -> 'b) (la : 'a List.t) : 'b List.t =
  list_reverse (List.fold_left (fun lb p -> (List.Cons(f p,lb))) List.Nil la)

let concat_lenses (lenses : lens List.t) (sep : lens) : lens =
  let concatted = List.fold_left 
    (fun l_acc l -> 
       match l_acc with
         | Prelude.None -> Some l
         | Prelude.Some acc -> Some (acc . sep . l)) None lenses in
  match concatted with
    | Prelude.Some l -> l
    | Prelude.None -> copy epsilon

let field_to_xml (field : string) : lens = 
  unrender_str (ctype unescape_str) ; unescape_str ;
  escape_xml ; render_tag (atype escape_xml) field

let csv_to_xml (fields : string List.t) = 
  concat_lenses (list_map field_to_xml fields) (del ",")

let l3 = csv_to_xml (List.Cons("first",List.Cons("last",List.Nil)))

test l3 get
    <<<
        "Michael \"The Autominator\"","Greenberg, Jr. &c"
    >>>
  = ? (*<<<
        <first>Michael "The Autominator"</first><last>Greenberg, Jr. &amp;c</last>
    >>> *)

