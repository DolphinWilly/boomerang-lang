(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007 J. Nathan Foster and Benjamin C. Pierce                  *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/examples/uniProtV2.boom                                          *)
(* UniProtKB <-> SwissProt lens                                                *)
(* $Id$ *)
(*******************************************************************************)

module UniProtV2 = 

let cn : canonizer = columnize [a-z0-9 ]+ " " "\n"
let l : lens = 
  let ANY : regexp = [^]* in
  ([a-z0-9 ]+ - (ANY . [a-z0-9]{81} . ANY))

test right_quot l cn get 
"alpha bravo charlie delta echo foxtrot golf hotel india juliet kilo lima mike november oscar papa quebec romeo sierra tango unicorn victor whiskey xray yankee zulu zero one two tree four five six seven eight niner 12345678901234567890123456789012345678901234567890123456789012345678901234567890" = ? 

(* --------------------------------------------------------------------------- *)
(* GENERIC HELPER FUNCTIONS *)

(* booleans / conditionals *)
type bool = True | False

let cond (b:bool) (l1:lens) (l2:lens) = match b with True -> l1 | False -> l2

(* sorting *)
let sort2 (R1:regexp) (R2:regexp) : lens = 
  ( R1 . R2
  | R2 ~ R1)

test sort2 "a" "b" get "ab" = "ab"
test sort2 "a" "b" get "ba" = "ab"

let sort3 (R1:regexp) (R2:regexp) (R3:regexp) : lens = 
  let s23 : lens = sort2 R2 R3 in 
  ( R1 . s23
  | (R2 ~ R1) . R3
  | R3 ~ (R1 . R2)
  | s23 ~ R1 )

test sort3 "a" "b" "c" get "abc" = "abc"
test sort3 "a" "b" "c" get "acb" = "abc"
test sort3 "a" "b" "c" get "bac" = "abc"
test sort3 "a" "b" "c" get "bca" = "abc"
test sort3 "a" "b" "c" get "cab" = "abc"
test sort3 "a" "b" "c" get "cba" = "abc"

let sort4 (R1:regexp) (R2:regexp) (R3:regexp) (R4:regexp) : lens = 
  let s12 : lens = sort2 R1 R2 in 
  let s23 : lens = sort2 R2 R3 in 
  let s34 : lens = sort2 R3 R4 in 
  let s123 : lens = sort3 R1 R2 R3 in 
  let s234 : lens = sort3 R2 R3 R4 in 
  let f1324 : lens = R1 . (R3 ~ R2) . R4 in 
  ( R1 . s234 
  | s234 ~ R1
  | ((R2 . R3) ~ R1) . R4
  | (R2 ~ R1) . s34 
  | (R3 ~ s12) . R4
  | R4 ~ (R1 . s23)
  | R4 ~ ((R2 ~ R1) . R3)
  | R4 ~ (R3 ~ (R1 . R2))
  | (R3 . R4) ~ (R1 . R2) 
  | ( (R2 . R4) ~ (R1 . R3); f1324 )
  | ( (R3 ~ R1) . (R4 ~ R2); f1324 ) )

test sort4 "a" "b" "c" "d" get "abcd" = "abcd"
test sort4 "a" "b" "c" "d" get "abdc" = "abcd"
test sort4 "a" "b" "c" "d" get "acbd" = "abcd"
test sort4 "a" "b" "c" "d" get "acdb" = "abcd"
test sort4 "a" "b" "c" "d" get "adbc" = "abcd"
test sort4 "a" "b" "c" "d" get "adcb" = "abcd"
test sort4 "a" "b" "c" "d" get "bacd" = "abcd"
test sort4 "a" "b" "c" "d" get "badc" = "abcd"
test sort4 "a" "b" "c" "d" get "bcad" = "abcd"
test sort4 "a" "b" "c" "d" get "bcda" = "abcd"
test sort4 "a" "b" "c" "d" get "bdac" = "abcd"
test sort4 "a" "b" "c" "d" get "bdca" = "abcd"
test sort4 "a" "b" "c" "d" get "cabd" = "abcd"
test sort4 "a" "b" "c" "d" get "cadb" = "abcd"
test sort4 "a" "b" "c" "d" get "cbad" = "abcd"
test sort4 "a" "b" "c" "d" get "cbda" = "abcd"
test sort4 "a" "b" "c" "d" get "cdab" = "abcd"
test sort4 "a" "b" "c" "d" get "cdba" = "abcd"
test sort4 "a" "b" "c" "d" get "dabc" = "abcd"
test sort4 "a" "b" "c" "d" get "dacb" = "abcd"
test sort4 "a" "b" "c" "d" get "dbac" = "abcd"
test sort4 "a" "b" "c" "d" get "dbca" = "abcd"
test sort4 "a" "b" "c" "d" get "dcab" = "abcd"
test sort4 "a" "b" "c" "d" get "dcba" = "abcd"

(* [bracket s] encloses [s] in bracket. *) 
let bracket (s:string) : string = "[" . s . "]" 

(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : { "" <-> E } = 
  qconst "" E e "" 

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : { E <-> "" } = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    ""

(* unit tests *)
test bracket (qdel [A-Z]+ "ZZZ" get "ABC") = "[]"
test bracket (qdel [A-Z]+ "ZZZ" put "" into "ABC") = "[ZZZ]"
  
(* --------------------------------------------------------------------------- *)
(* CONSTANTS *)

(* [NL] newline *)
let NL :string = "\n"

(* [WS] whitespace *)
let WS : regexp = [ \n]*

(* [WSP] positive whitespace *)
let WSP : regexp = [ \n]+

(* [S] space *)
let S : regexp = [ ]*

(* [SP] positive space *)
let SP : regexp = [ ]+

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let nl0 = "\n"
let nl1 = nl0 . "  "
let nl2 = nl1 . "  "
let nl3 = nl2 . "  "
let nl4 = nl3 . "  "

(* --------------------------------------------------------------------------- *)
(* XML helper functions *)

(* single_line_elt: helper for processing a single-line XML element
   o spaces: default whitespace before the element
   o tag: the element's tag
   o body: lens for handling the children
*)
let single_line_elt (spaces:string) (tag:string) (body:lens) : lens = 
  qdel WS spaces . 
  del ("<" . tag . ">") . 
  body . 
  del ("</" . tag .">") 

(* multi_line_elt_nl_nl: helper for processing a multi-line XML element 
   o spaces: default whitespace after the element
   o tag: the element's tag
   o body: lens for handling the children 
*)
let multi_line_elt (spaces:string) (tag:string) (body:lens) : lens = 
  qdel WS spaces . 
  del ("<" . tag . ">") .
  body . 
  qdel WS spaces . 
  del ("</" . tag .">") 

let tag (t:string) : lens = 
  qins (t . SP) (t . "    ")
    
(* --------------------------------------------------------------------------- *)
(* ID line *)
let id_tag : string = "ID"
let id_data : regexp = [A-Z0-9_]{1,12}
let id_xml : lens = 
  let STATUS : regexp = SP . ("Reviewed" | "Unreviewed") . ";" in 
  let LENGTH : regexp = SP . DIGIT+ . " AA" in 
  let def_sl : string = " Unreviewed; 000 AA" in 
  tag "ID" . 
  single_line_elt nl1 "name" 
    (key id_data .
     qins (STATUS . LENGTH) def_sl . 
     ins NL)
let id_line : lens = id_xml 

(* unit tests *)
test id_line get 
  "<name>Q56J06_HUMAN</name>" = 
  "ID    Q56J06_HUMAN Unreviewed; 000 AA\n"

test id_line create 
  "ID Q5JU06_HUMAN Reviewed; 280 AA\n" 
= "\n  <name>Q5JU06_HUMAN</name>"


(* --------------------------------------------------------------------------- *)
(* AC line *)
let ac_tag : string = "AC"
let ac_data : regexp = [A-Z0-9]{6} 
let ac_entry : regexp = ac_data . ";" 
let ac_xml : lens = (single_line_elt nl1 "accession" (ac_data . ins "; "))+
let ac_cn : canonizer =
  let aux : lens = 
    del (ac_tag . SP) . 
    (ac_entry . SP <-> " "){0,7} . 
    (ac_entry . S <-> " ") . 
    del NL in 
  (canonizer_of_lens aux)+
let ac_line : lens =
  right_quot ac_xml ac_cn

(* unit tests *)
test ac_line get "<accession>Q21234</accession>" = "AC Q21234;\n" 

let ac_9 = 
  "
  |  <accession>Q92892</accession>
  |  <accession>Q92893</accession>
  |  <accession>Q92894</accession>
  |  <accession>Q92895</accession>
  |  <accession>Q93053</accession>
  |  <accession>Q96KU9</accession>
  |  <accession>Q96KV0</accession>
  |  <accession>Q93053</accession>
  |  <accession>Q96KU9</accession>" 

test ac_line get ac_9
= 
  "AC Q92892; Q92893; Q92894; Q92895; Q93053; Q96KU9; Q96KV0; Q93053;
  |AC Q96KU9;
  |"

test ac_line create
  "AC Q92892; Q92893; Q92894;
  |AC    Q92895;   Q93053; Q96KU9; Q96KV0;  Q93053;
  |AC Q96KU9;  
  |"
= ac_9

test ac_line put
  "AC    Q21234; QJNF12;
  |"
into
  "<accession>Q92892</accession>
  |  <accession>Q92893</accession>
  |      <accession>Q92894</accession>
  | <accession>Q92895</accession>"
= 
  "
  |  <accession>Q21234</accession>
  |  <accession>QJNF12</accession>" 
 
(* --------------------------------------------------------------------------- *)
(* DT line *)

(* [date] maps between aphanumeric and numeric dates *)
let date : lens = 
  let day : regexp = DIGIT{2} in 
  let month : lens = 
    ( "01" <-> "JAN" 
    | "02" <-> "FEB" 
    | "03" <-> "MAR" 
    | "04" <-> "APR" 
    | "05" <-> "MAY" 
    | "06" <-> "JUN" 
    | "07" <-> "JUL" 
    | "08" <-> "AUG" 
    | "09" <-> "SEP" 
    | "10" <-> "OCT" 
    | "11" <-> "NOV" 
    | "12" <-> "DEC" ) in       
  let year : regexp = DIGIT{4} in 
    default
      (year ~ (("-" . month . "-") ~ day))        
      "1900-01-01"  

test date get "2009-01-20" = "20-JAN-2009"

let xml_attr_open (spaces:string) (tag:string) : lens = 
  del ("<" . tag) 

let xml_attr_close : lens = 
  del ("/>" | ">") 

let (entry_cn,entry_xml) : canonizer * lens = 
  let entry_tag : string = "entry" in 
  let DATE : regexp = ctype date in 
  let STRING : regexp = [A-Za-z\-]+ in 
  let NUMBER : regexp = [0-9]+ in 
  (* helpers *)
  let cp_ws (R:regexp) : lens = WS . R in 
  let del_ws (R:regexp) : lens = WS <-> " " . R in 
  let attr  (s:string) (R:regexp) : regexp = s . "=\"" . R . "\"" in 
  (* definitions *)
  let R1 = attr "created" DATE in 
  let R2 = attr "dataset" STRING in
  let R3 = attr "modified" DATE in
  let R4 = attr "version" NUMBER in 
  let cn = canonizer_of_lens (
    xml_attr_open nl1 entry_tag . 
    (sort4 (cp_ws R1) (cp_ws R2) (cp_ws R3) (cp_ws R4);
     del_ws R1 . del_ws R2 . del_ws R3 . del_ws R4 ) . 
    xml_attr_close) in 
  let dt1a = tag "DT" . date . ins ", " in
  let dt1b = ins "integrated into UniprotKB/" . [A-Za-z\-]+ . ins "." . ins NL in
  let dt3a = tag "DT" . date . ins ", " in
  let dt3b = ins "entry version" . qins S " " . [0-9]+ . ins ". " . ins NL in
  let xml_attr (name:string) (l:lens) = del (" " . name . "=\"") . l . del "\"" in 
  let xml = 
    xml_attr "created" dt1a . 
    xml_attr "dataset" dt1b .  
    xml_attr "modified" dt3a . 
    xml_attr "version" dt3b in 
  cn,xml

let entry_line = left_quot entry_cn entry_xml

test entry_line get "<entry created=\"2006-04-18\" version=\"15\"   dataset=\"Swiss-Prot\"   modified=\"2007-02-20\"/>" = ?

 
(* --------------------------------------------------------------------------- *)
(* DE line *)

let A: regexp = [A-Za-z0-9\-.] 
let ALPHA : regexp = A.(A | " ")*
let de_xml : lens = 
  let name : lens = single_line_elt nl2 "name" ALPHA in 
  let domain: lens = multi_line_elt nl2 "domain" (name . (ins " (". name . ins ")")* ) in 
  let component: lens = multi_line_elt nl2 "component" (name . (ins " (". name . ins ")")* ) in 
  tag "DE" . 
  multi_line_elt nl1 "protein" 
    (name . 
     (ins " [Includes: " . domain. (ins "; " . domain)+ . ins "]")? . 
     (ins " [Contains: " . component. (ins "; " . component)+ . ins "]")? )

(* 
let sp : canonizer = canonizer_of_lens (SP <-> " ")
let nl : canonizer = canonizer_of_lens (SP <-> "\n")

let A1 = (canonizer_of_lens A)
let A2 = A1.A1
let A3 = A2.A1
let A4 = A3.A1
let A5 = A4.A1
let A6 = A5.A1
let A7 = A6.A1
let A8 = A7.A1
let A9 = A8.A1
let A10 = A9.A1
let A11 = A10.A1
let A12 = A11.A1
let A13 = A12.A1
let A14 = A13.A1
let A15 = A14.A1
let A16 = A15.A1
let A17 = A16.A1
let A18 = A17.A1
let A19 = A18.A1
let A20 = A19.A1

let cp1 : canonizer = 
    A1 
let cp2 : canonizer = 
    A2  
let cp3 : canonizer = 
    A3 
  | A1 . sp . cp1 
let cp4 : canonizer = 
    A4 
  | A2 . sp . cp1 
  | A1 . sp . cp2 
let cp5 : canonizer = 
    A5 
  | A3 . sp . cp1 
  | A2 . sp . cp2 
  | A1 . sp . cp3 
let cp6 : canonizer = 
    A6 
  | A4 . sp . cp1 
  | A3 . sp . cp2 
  | A2 . sp . cp3 
  | A1 . sp . cp4 
let cp7 : canonizer = 
    A7 
  | A5 . sp . cp1 
  | A4 . sp . cp2 
  | A3 . sp . cp3 
  | A2 . sp . cp4 
  | A1 . sp . cp5
let cp8 : canonizer = 
    A8 
  | A6 . sp . cp1 
  | A5 . sp . cp2 
  | A4 . sp . cp3 
  | A3 . sp . cp4 
  | A2 . sp . cp5 
  | A1 . sp . cp6
let cp9 : canonizer = 
    A9 
  | A7 . sp . cp1
  | A6 . sp . cp2 
  | A5 . sp . cp3 
  | A4 . sp . cp4 
  | A3 . sp . cp5 
  | A2 . sp . cp6 
  | A1 . sp . cp7                  
let cp10 : canonizer = 
    A10 
  | A8 . sp . cp1
  | A7 . sp . cp2 
  | A6 . sp . cp3 
  | A5 . sp . cp4 
  | A4 . sp . cp5 
  | A3 . sp . cp6 
  | A2 . sp . cp7 
  | A1 . sp . cp8
let cp11 : canonizer = 
    A11 
  | A9 . sp . cp1
  | A8 . sp . cp2
  | A7 . sp . cp3 
  | A6 . sp . cp4 
  | A5 . sp . cp5 
  | A4 . sp . cp6 
  | A3 . sp . cp7 
  | A2 . sp . cp8 
  | A1 . sp . cp9
let cp12 : canonizer = 
    A12 
  | A10 . sp . cp1
  | A9 . sp . cp2
  | A8 . sp . cp3 
  | A7 . sp . cp4 
  | A6 . sp . cp5 
  | A5 . sp . cp6 
  | A4 . sp . cp7 
  | A3 . sp . cp8 
  | A2 . sp . cp9
  | A1 . sp . cp10
let cp13 : canonizer = 
    A13 
  | A11 . sp . cp1
  | A10 . sp . cp2
  | A9  . sp . cp3 
  | A8  . sp . cp4 
  | A7  . sp . cp5 
  | A6  . sp . cp6 
  | A5  . sp . cp7 
  | A4  . sp . cp8 
  | A3  . sp . cp9
  | A2  . sp . cp10
  | A1  . sp . cp11
let cp14 : canonizer = 
    A14 
  | A12 . sp . cp1
  | A11 . sp . cp2
  | A10 . sp . cp3 
  | A9  . sp . cp4 
  | A8  . sp . cp5 
  | A7  . sp . cp6 
  | A6  . sp . cp7 
  | A5  . sp . cp8 
  | A4  . sp . cp9
  | A3  . sp . cp10
  | A2  . sp . cp11
  | A1  . sp . cp12
let cp15 : canonizer = 
    A15
  | A13 . sp . cp1
  | A12 . sp . cp2
  | A11 . sp . cp3 
  | A10 . sp . cp4  
  | A9  . sp . cp5 
  | A8  . sp . cp6 
  | A7  . sp . cp7 
  | A6  . sp . cp8 
  | A5  . sp . cp9 
  | A4  . sp . cp10
  | A3  . sp . cp11
  | A2  . sp . cp12
  | A1  . sp . cp13
let cp16: canonizer = 
    A16
  | A14 . sp . cp1
  | A13 . sp . cp2
  | A12 . sp . cp3 
  | A11 . sp . cp4  
  | A10 . sp . cp5 
  | A9  . sp . cp6 
  | A8  . sp . cp7 
  | A7  . sp . cp8 
  | A6  . sp . cp9 
  | A5  . sp . cp10
  | A4  . sp . cp11
  | A3  . sp . cp12
  | A2  . sp . cp13
  | A1  . sp . cp14
let cp17: canonizer = 
    A17
  | A15 . sp . cp1
  | A14 . sp . cp2
  | A13 . sp . cp3 
  | A12 . sp . cp4  
  | A11 . sp . cp5 
  | A10 . sp . cp6 
  | A9  . sp . cp7  
  | A8  . sp . cp8 
  | A7  . sp . cp9 
  | A6  . sp . cp10
  | A5  . sp . cp11
  | A4  . sp . cp12
  | A3  . sp . cp13
  | A2  . sp . cp14
  | A1  . sp . cp15
let cp18: canonizer = 
    A18
  | A16 . sp . cp1
  | A15 . sp . cp2
  | A14 . sp . cp3 
  | A13 . sp . cp4  
  | A12 . sp . cp5 
  | A11 . sp . cp6 
  | A10 . sp . cp7
  | A9  . sp . cp8   
  | A8  . sp . cp9 
  | A7  . sp . cp10
  | A6  . sp . cp11
  | A5  . sp . cp12
  | A4  . sp . cp13
  | A3  . sp . cp14
  | A2  . sp . cp15
  | A1  . sp . cp16
let cp19: canonizer = 
    A19
  | A17 . sp . cp1
  | A16 . sp . cp2
  | A15 . sp . cp3 
  | A14 . sp . cp4  
  | A13 . sp . cp5 
  | A12 . sp . cp6 
  | A11 . sp . cp7
  | A10 . sp . cp8
  | A9  . sp . cp9 
  | A8  . sp . cp10 
  | A7  . sp . cp11
  | A6  . sp . cp12
  | A5  . sp . cp13
  | A4  . sp . cp14
  | A3  . sp . cp15
  | A2  . sp . cp16
  | A1  . sp . cp17
let cp20: canonizer = 
    A20
  | A18 . sp . cp1
  | A17 . sp . cp2
  | A16 . sp . cp3 
  | A15 . sp . cp4  
  | A14 . sp . cp5 
  | A13 . sp . cp6 
  | A12 . sp . cp7
  | A11 . sp . cp8
  | A10 . sp . cp9
  | A9  . sp . cp10 
  | A8  . sp . cp11 
  | A7  . sp . cp12
  | A6  . sp . cp13
  | A5  . sp . cp14
  | A4  . sp . cp15
  | A3  . sp . cp16
  | A2  . sp . cp17
  | A1  . sp . cp18
let cn : canonizer = 
  let aux : canonizer = 
    canonizer_of_lens (del "DE") . 
    sp . 
    ( cp20 | cp19 | cp18 | cp17 | cp16 | cp15 | cp14 | cp13 | cp12 | cp11 
    | cp10 | cp9 | cp8 | cp7 | cp6 | cp5 | cp4 | cp3 | cp2 | cp1) . 
    canonizer_of_lens (del NL) in 
  aux+

test rep cn " alpha bravo charlie delta echo foxtrot golf hotel india juliet kilo lima mike november oscar papa quebec romeo sierra tango unicorn victor whiskey xray yankee zulu zero one two tree four five six seven eight niner" = ?

test cls cn  
 "DE a b c d e
 |DE f
 |DE g
 |DE h
 |DE i
 |DE j
 |DE k
 |DE l m n o p
 |DE q r s t u
 |DE u v w x y
 |DE z
 |" = ?
*)

test de_xml get 
  "<protein>
  |     <name>Arginine biosynthesis bifunctional protein argJ</name>
  |     <domain>
  |       <name>Glutamate N-acetyltransferase</name>
  |       <name>EC 2.3.1.35</name>
  |       <name>Ornithine acetyltransferase</name>
  |       <name>Ornithine transacetylase</name>
  |       <name>OATase</name>
  |     </domain>
  |     <domain>
  |       <name>Amino-acid acetyltransferase</name>
  |       <name>EC 2.3.1.1</name>
  |       <name>N-acetylglutamate synthase</name>
  |       <name>AGS</name>
  |     </domain>
  |     <component>
  |       <name>Arginine biosynthesis bifunctional protein argJ alpha chain</name>
  |     </component>
  |     <component>
  |       <name>Arginine biosynthesis bifunctional protein argJ beta chain</name>
  |     </component>
  |   </protein>" = ?

