(*******************************************************************************)
(* The Harmony Project                                                         *)
(* harmony@lists.seas.upenn.edu                                                *)
(*******************************************************************************)
(* Copyright (C) 2007 J. Nathan Foster and Benjamin C. Pierce                  *)
(*                                                                             *)
(* This library is free software; you can redistribute it and/or               *)
(* modify it under the terms of the GNU Lesser General Public                  *)
(* License as published by the Free Software Foundation; either                *)
(* version 2.1 of the License, or (at your option) any later version.          *)
(*                                                                             *)
(* This library is distributed in the hope that it will be useful,             *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of              *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *)
(* Lesser General Public License for more details.                             *)
(*******************************************************************************)
(* /boomerang/examples/uniProtV2.boom                                          *)
(* UniProtKB <-> SwissProt lens                                                *)
(* $Id$ *)
(*******************************************************************************)

module UniProtV2 = 

(* [bracket s] encloses [s] in bracket. *) 
let bracket (s:string) : string = "[" . s . "]" 

let cn : canonizer = columnize [a-z0-9 ]+ " " "\n"
let l : lens = 
  let ANY : regexp = [^]* in
  ([a-z0-9 ]+ (* - (ANY . [a-z0-9]{81} . ANY) *) )

test (right_quot l cn get 
  "alpha bravo charlie delta echo foxtrot golf hotel india juliet kilo lima mike november oscar papa quebec romeo sierra tango unicorn victor whiskey xray yankee zulu zero one two tree four five six seven eight niner 12345678901234567890123456789012345678901234567890123456789012345678901234567890123")
= 
  "alpha bravo charlie delta echo foxtrot golf hotel india juliet kilo lima mike
  |november oscar papa quebec romeo sierra tango unicorn victor whiskey xray yankee
  |zulu zero one two tree four five six seven eight niner
  |12345678901234567890123456789012345678901234567890123456789012345678901234567890123"
  
(* --------------------------------------------------------------------------- *)
(* GENERIC HELPER FUNCTIONS *)

(* booleans / conditionals *)
type bool = True | False

let cond (b:bool) (l1:lens) (l2:lens) = match b with True -> l1 | False -> l2

(* sorting *)
let sort2 (R1:regexp) (R2:regexp) : lens = 
  ( R1 . R2
  | R2 ~ R1)

test sort2 "a" "b" get "ab" = "ab"
test sort2 "a" "b" get "ba" = "ab"

let sort3 (R1:regexp) (R2:regexp) (R3:regexp) : lens = 
  let s23 : lens = sort2 R2 R3 in 
  ( R1 . s23
  | (R2 ~ R1) . R3
  | R3 ~ (R1 . R2)
  | s23 ~ R1 )

test sort3 "a" "b" "c" get "abc" = "abc"
test sort3 "a" "b" "c" get "acb" = "abc"
test sort3 "a" "b" "c" get "bac" = "abc"
test sort3 "a" "b" "c" get "bca" = "abc"
test sort3 "a" "b" "c" get "cab" = "abc"
test sort3 "a" "b" "c" get "cba" = "abc"

let sort4 (R1:regexp) (R2:regexp) (R3:regexp) (R4:regexp) : lens = 
  let s12 : lens = sort2 R1 R2 in 
  let s23 : lens = sort2 R2 R3 in 
  let s34 : lens = sort2 R3 R4 in 
  let s123 : lens = sort3 R1 R2 R3 in 
  let s234 : lens = sort3 R2 R3 R4 in 
  let f1324 : lens = R1 . (R3 ~ R2) . R4 in 
  ( R1 . s234 
  | s234 ~ R1
  | ((R2 . R3) ~ R1) . R4
  | (R2 ~ R1) . s34 
  | (R3 ~ s12) . R4
  | R4 ~ (R1 . s23)
  | R4 ~ ((R2 ~ R1) . R3)
  | R4 ~ (R3 ~ (R1 . R2))
  | (R3 . R4) ~ (R1 . R2) 
  | ( (R2 . R4) ~ (R1 . R3); f1324 )
  | ( (R3 ~ R1) . (R4 ~ R2); f1324 ) )

test sort4 "a" "b" "c" "d" get "abcd" = "abcd"
test sort4 "a" "b" "c" "d" get "abdc" = "abcd"
test sort4 "a" "b" "c" "d" get "acbd" = "abcd"
test sort4 "a" "b" "c" "d" get "acdb" = "abcd"
test sort4 "a" "b" "c" "d" get "adbc" = "abcd"
test sort4 "a" "b" "c" "d" get "adcb" = "abcd"
test sort4 "a" "b" "c" "d" get "bacd" = "abcd"
test sort4 "a" "b" "c" "d" get "badc" = "abcd"
test sort4 "a" "b" "c" "d" get "bcad" = "abcd"
test sort4 "a" "b" "c" "d" get "bcda" = "abcd"
test sort4 "a" "b" "c" "d" get "bdac" = "abcd"
test sort4 "a" "b" "c" "d" get "bdca" = "abcd"
test sort4 "a" "b" "c" "d" get "cabd" = "abcd"
test sort4 "a" "b" "c" "d" get "cadb" = "abcd"
test sort4 "a" "b" "c" "d" get "cbad" = "abcd"
test sort4 "a" "b" "c" "d" get "cbda" = "abcd"
test sort4 "a" "b" "c" "d" get "cdab" = "abcd"
test sort4 "a" "b" "c" "d" get "cdba" = "abcd"
test sort4 "a" "b" "c" "d" get "dabc" = "abcd"
test sort4 "a" "b" "c" "d" get "dacb" = "abcd"
test sort4 "a" "b" "c" "d" get "dbac" = "abcd"
test sort4 "a" "b" "c" "d" get "dbca" = "abcd"
test sort4 "a" "b" "c" "d" get "dcab" = "abcd"
test sort4 "a" "b" "c" "d" get "dcba" = "abcd"

(* [qconst C A a c]: is like [const C a c], but accepts all of [A] in
   the PUT/CREATE direction. *)
let qconst (C:regexp) (A:regexp) (a:string) (c:string) : lens = 
  right_quot     
    (const C a c)
    (canonizer_of_lens (const A a a))

(* [qins E e] is like [ins e], but accepts all of [E] in the
   PUT/CREATE direction *)
let qins (E:regexp) (e:string) : { "" <-> E } = 
  qconst "" E e "" 

(* [qdel E e] is like [del E] but canonizes to [e] in the PUT/CREATE
   direction. *)
let qdel (E:regexp) (e:string) : { E <-> "" } = 
  left_quot 
    (canonizer_of_lens (default (del E) e))
    ""

(* unit tests *)
test bracket (qdel [A-Z]+ "ZZZ" get "ABC") = "[]"
test bracket (qdel [A-Z]+ "ZZZ" put "" into "ABC") = "[ZZZ]"
  
(* --------------------------------------------------------------------------- *)
(* CONSTANTS *)

(* [NL] newline *)
let NL :string = "\n"

(* [WS] whitespace *)
let WS : regexp = [ \n]*

(* [WSP] positive whitespace *)
let WSP : regexp = [ \n]+

(* [S] space *)
let S : regexp = [ ]*

(* [SP] positive space *)
let SP : regexp = [ ]+

(* [DIGIT] digit *)
let DIGIT : regexp = [0-9]

(* [nlX]: X^th amount of whitespace--used to canonize XML *)
let nl0 = "\n"
let nl1 = nl0 . "  "
let nl2 = nl1 . "  "
let nl3 = nl2 . "  "
let nl4 = nl3 . "  "

(* --------------------------------------------------------------------------- *)
(* XML helper functions *)

(* single_line_elt: helper for processing a single-line XML element
   o spaces: default whitespace before the element
   o tag: the element's tag
   o body: lens for handling the children
*)
let single_line_elt (spaces:string) (tag:string) (body:lens) : lens = 
  qdel WS spaces . 
  del ("<" . tag . ">") . 
  body . 
  del ("</" . tag .">") 

(* multi_line_elt_nl_nl: helper for processing a multi-line XML element 
   o spaces: default whitespace after the element
   o tag: the element's tag
   o body: lens for handling the children 
*)
let multi_line_elt (spaces:string) (tag:string) (body:lens) : lens = 
  qdel WS spaces . 
  del ("<" . tag . ">") .
  body . 
  qdel WS spaces . 
  del ("</" . tag .">") 

let tag (t:string) : lens = 
  qins (t . SP) (t . "  ")
    
(* --------------------------------------------------------------------------- *)
(* ID line *)
let id_tag : string = "ID"
let id_data : regexp = [A-Z0-9_]{1,12}
let id_xml : lens = 
  let STATUS : regexp = SP . ("Reviewed" | "Unreviewed") . ";" in 
  let LENGTH : regexp = SP . DIGIT+ . " AA" in 
  let def_sl : string = " Unreviewed; 000 AA" in 
  tag "ID" . 
  single_line_elt nl1 "name" 
    (key id_data .
     qins (STATUS . LENGTH) def_sl . 
     ins NL)
let id_line : lens = id_xml 

(* unit tests *)
test id_line get 
  "<name>Q56J06_HUMAN</name>" = 
  "ID  Q56J06_HUMAN Unreviewed; 000 AA\n"

test id_line create 
  "ID Q5JU06_HUMAN Reviewed; 280 AA\n" 
= "\n  <name>Q5JU06_HUMAN</name>"


(* --------------------------------------------------------------------------- *)
(* AC line *)
let ac_tag : string = "AC"
let ac_data : regexp = [A-Z0-9]{6} 
let ac_entry : regexp = ac_data . ";" 
let ac_xml : lens = (single_line_elt nl1 "accession" (ac_data . ins "; "))+
let ac_cn : canonizer =
  let aux : lens = 
    del (ac_tag . SP) . 
    (ac_entry . SP <-> " "){0,7} . 
    (ac_entry . S <-> " ") . 
    del NL in 
  (canonizer_of_lens aux)+
let ac_line : lens =
  right_quot ac_xml ac_cn

(* unit tests *)
test ac_line get "<accession>Q21234</accession>" = "AC Q21234;\n" 

let ac_9 = 
  "
  |  <accession>Q92892</accession>
  |  <accession>Q92893</accession>
  |  <accession>Q92894</accession>
  |  <accession>Q92895</accession>
  |  <accession>Q93053</accession>
  |  <accession>Q96KU9</accession>
  |  <accession>Q96KV0</accession>
  |  <accession>Q93053</accession>
  |  <accession>Q96KU9</accession>" 

test ac_line get ac_9
= 
  "AC Q92892; Q92893; Q92894; Q92895; Q93053; Q96KU9; Q96KV0; Q93053;
  |AC Q96KU9;
  |"

test ac_line create
  "AC Q92892; Q92893; Q92894;
  |AC    Q92895;   Q93053; Q96KU9; Q96KV0;  Q93053;
  |AC Q96KU9;  
  |"
= ac_9

test ac_line put
  "AC    Q21234; QJNF12;
  |"
into
  "<accession>Q92892</accession>
  |  <accession>Q92893</accession>
  |      <accession>Q92894</accession>
  | <accession>Q92895</accession>"
= 
  "
  |  <accession>Q21234</accession>
  |  <accession>QJNF12</accession>" 
 
(* --------------------------------------------------------------------------- *)
(* DT line *)

(* [date] maps between aphanumeric and numeric dates *)
let date : lens = 
  let day : regexp = DIGIT{2} in 
  let month : lens = 
    ( "01" <-> "JAN" 
    | "02" <-> "FEB" 
    | "03" <-> "MAR" 
    | "04" <-> "APR" 
    | "05" <-> "MAY" 
    | "06" <-> "JUN" 
    | "07" <-> "JUL" 
    | "08" <-> "AUG" 
    | "09" <-> "SEP" 
    | "10" <-> "OCT" 
    | "11" <-> "NOV" 
    | "12" <-> "DEC" ) in       
  let year : regexp = DIGIT{4} in 
    default
      (year ~ (("-" . month . "-") ~ day))        
      "1900-01-01"  

test date get "2009-01-20" = "20-JAN-2009"

let xml_attr_open (spaces:string) (tag:string) : lens = 
  del ("<" . tag) 

let xml_attr_close : lens = 
  del ("/>" | ">") 

let (entry_cn,entry_xml) : canonizer * lens = 
  let entry_tag : string = "entry" in 
  let DATE : regexp = ctype date in 
  let STRING : regexp = [A-Za-z\-]+ in 
  let NUMBER : regexp = [0-9]+ in 
  (* helpers *)
  let cp_ws (R:regexp) : lens = WS . R in 
  let del_ws (R:regexp) : lens = WS <-> " " . R in 
  let attr  (s:string) (R:regexp) : regexp = s . "=\"" . R . "\"" in 
  (* definitions *)
  let R1 = attr "created" DATE in 
  let R2 = attr "dataset" STRING in
  let R3 = attr "modified" DATE in
  let R4 = attr "version" NUMBER in 
  let cn = canonizer_of_lens (
    xml_attr_open nl1 entry_tag . 
    (sort4 (cp_ws R1) (cp_ws R2) (cp_ws R3) (cp_ws R4);
     del_ws R1 . del_ws R2 . del_ws R3 . del_ws R4 ) . 
    xml_attr_close) in 
  let dt1a = tag "DT" . date . ins ", " in
  let dt1b = ins "integrated into UniprotKB/" . [A-Za-z\-]+ . ins "." . ins NL in
  let dt3a = tag "DT" . date . ins ", " in
  let dt3b = ins "entry version" . qins S " " . [0-9]+ . ins ". " . ins NL in
  let xml_attr (name:string) (l:lens) = del (" " . name . "=\"") . l . del "\"" in 
  let xml = 
    xml_attr "created" dt1a . 
    xml_attr "dataset" dt1b .  
    xml_attr "modified" dt3a . 
    xml_attr "version" dt3b in 
  cn,xml

let entry_line = left_quot entry_cn entry_xml

test entry_line get "<entry created=\"2006-04-18\" version=\"15\"   dataset=\"Swiss-Prot\"   modified=\"2007-02-20\"/>" = ?

 
(* --------------------------------------------------------------------------- *)
(* DE line *)

let A: regexp = [A-Za-z0-9\-.] 
let ALPHA : regexp = A.(A | " ")*
let de_xml : lens = 
  let name2 : lens = single_line_elt nl2 "name" ALPHA in 
  let name3 : lens = single_line_elt nl3 "name" ALPHA in 
  let domain: lens = multi_line_elt nl2 "domain" (name3 . (ins " (". name3 . ins ")")* ) in 
  let component: lens = multi_line_elt nl2 "component" (name3 . (ins " (". name3 . ins ")")* ) in 
    tag "DE" .
    multi_line_elt nl1 "protein" 
    (name2 . 
     (ins " [Includes: " . domain. (ins "; " . domain)+ . ins "]")? . 
     (ins " [Contains: " . component. (ins "; " . component)+ . ins "]")? )
let de_cn : canonizer = columnize (atype de_xml) " " "\nDE  "

test right_quot de_xml de_cn get
  "<protein>
  |     <name>Arginine biosynthesis bifunctional protein argJ</name>
  |     <domain>
  |       <name>Glutamate N-acetyltransferase</name>
  |       <name>EC 2.3.1.35</name>
  |       <name>Ornithine acetyltransferase</name>
  |       <name>Ornithine transacetylase</name>
  |       <name>OATase</name>
  |     </domain>
  |     <domain>
  |       <name>Amino-acid acetyltransferase</name>
  |         <name>EC 2.3.1.1</name>
  |       <name>N-acetylglutamate synthase</name>
  |       <name>AGS</name>
  |     </domain>
  |     <component>
  |       <name>Arginine biosynthesis bifunctional protein argJ alpha chain</name>
  |     </component>
  |     <component>
  |       <name>Arginine biosynthesis bifunctional protein argJ beta chain</name>
  |     </component>
  |   </protein>" = ?

test right_quot de_xml de_cn create 
 "DE  Arginine biosynthesis bifunctional protein argJ [Includes: Glutamate
 |DE  N-acetyltransferase (EC 2.3.1.35) (Ornithine acetyltransferase) (Ornithine
 |DE  transacetylase) (OATase); Amino-acid acetyltransferase (EC 2.3.1.1)
 |DE  (N-acetylglutamate synthase) (AGS)] [Contains: Arginine biosynthesis bifunctional
 |DE  protein argJ alpha chain; Arginine biosynthesis bifunctional protein argJ beta
 |DE  chain]" = ?
