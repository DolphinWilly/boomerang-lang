module Story = 

(* Overall story:
      - illustrate lens combinators / types
      - motivate / illustrate abstraction / reuse
      - how do we design the type system of boomerang?
           - morally, they are dependent polymorphic refinement types
           - how do we implement it?
               - work (really) hard
               - or be less static  (but note that we still have a
                 "type system"  in the sense that we completely and 
                 "statically" prevent a certain class of errors)
      - imprecision of blame  (bc of "dynamic typechecking" of lenses)
          ==> contracts / casts  (be careful about terminology!)
          interesting interlude on what blame means (and slogans)
          (read papers on blame semantics!)
      - need for some kind of contract inference
          = implicit cast insertion
          interesting/tricky interactions with inference of type instantiation!
          (read flanagan paper on type reconstruction)
      - ass covering / buck passing (= polymorphism?  = inlining?)
          - note no need for sealing (core polymorphism = precise polymorphism)
      - quotienting
*)

let domain_type (l:lens) = ctype l
let codomain_type (l:lens) = atype l

(* Our first lens maps between invidual ASCII characters and
   appropriate escape sequences in XML. *)

let XML_ESC : regexp = "&lt;" | "&gt;" | "&amp;" | [^<>&]

let escape_xml_char : (lens in ANYCHAR <=> XML_ESC) = 
    '<' <=> "&lt;"
  | '>' <=> "&gt;"
  | '&' <=> "&amp;"
  | copy (ANYCHAR - [<>&])

(* Using [escape_xml_char], we can build a lens to escape entire strings. *)

let ANY : regexp = ANYCHAR*
let XML_ESC_STRING : regexp = XML_ESC*

let escape_xml : (lens in ANY <=> XML_ESC_STRING ) = 
  escape_xml_char*

test escape_xml.get
  <<
    <hello"world>
  >>
= 
  <<
    &lt;hello"world&gt;
  >> 

(* Next we build a lens that maps between individual ASCII characters,
   and their escapings in formats like CSV. (This lens is a little bit harder
   to read because we are escaping the quotation and escape symbol of 
   Boomerang itself!)*)

let ESC_SYMBOL : regexp = "\\\"" | "\\\\" | [^\\""]

let escape_quotes_char : (lens in ANYCHAR <=> ESC_SYMBOL) = 
    '"' <=> "\\\""
  | '\\' <=> "\\\\"
  | copy (ANYCHAR - [\\""]) 

(* Using [escape_quotes_char] we can build a lens that escapes entire
   strings. *)

let ESC_STRING : regexp = ESC_SYMBOL*
let escape_quotes_string : (lens in ANY <=> ESC_STRING ) = 
  escape_quotes_char*

test escape_quotes_string.get
  <<
    <hello"world>
  >>
= 
  <<
    <hello\"world>
  >> 
(* " *)


(* Now we can compose these lenses to build a lens that maps between
   strings escaped according to CSV and XML conventions. *)

let quotes_to_xml : (lens in ESC_STRING <=> XML_ESC_STRING) = 
  (invert escape_quotes_string) ; escape_xml

test quotes_to_xml.get
  <<
    <hello\"world>
  >>
= 
  <<
    &lt;hello"world&gt;
  >> 
(* " *)


(* Why do we need precise type system? Let's review the "real" types
   of the core lens combinators: dependent + refinement types. *)
let lens_splittable (l1:lens) (l2:lens) : bool = 
     (splittable l1.domain_type l2.domain_type) 
  && (splittable l1.codomain_type l2.codomain_type)

let lens_iterable (l1:lens) : bool = 
     (iterable l1.domain_type) 
  && (iterable l1.codomain_type)

let lens_disjoint (l1:lens) (l2:lens) : bool = 
     ((l1.domain_type & l2.domain_type) = empty) 
  && ((l1.codomain_type & l2.codomain_type) = empty)

let lens_concat (l1:lens) (l2:lens where lens_splittable l1 l2) : lens = 
  Native.Prelude.lens_concat l1 l2

let lens_union (l1:lens) (l2:lens where lens_disjoint l1 l2) : lens = 
  Native.Prelude.lens_union l1 l2

(* etc. *)

(* ------------------------------------------------------------ *)

(* Now let's write a generic lens. *)
let escape_char (raw:char) (esc:string) (R:regexp) 
   : (lens in (R | raw) <=> (R | esc))
 = 
   ( raw <=> esc 
   | copy R )

test escape_char '&' "&amp;" ANYCHAR = error
(* 
Test result: error
(copy R) did not have sort (l2:lens where
((land
   ((disjoint
      (ctype ((Core.rewrite (Native.Prelude.string_of_char raw)) esc)))
     (ctype l2)))
  ((disjoint
     (atype ((Core.rewrite (Native.Prelude.string_of_char raw)) esc)))
    (atype l2))))
<<File "./Story.boom", line 133, characters 5-11:true>> blamed!
*)

(* This is bad: not only do we get an error, we get an inscrutable
   error message that points us at a library function. 

   Since we call lens_union, we should "cover our ass" to ensure that it
   will be disjoint. *)

let escape_char (raw:char) (esc:string) 
    (R:regexp where not ((matches R raw) || (matches R esc)))
    : (lens in (R | raw) <=> (R | esc)) = 
  ( raw <=> esc
  | copy R )

(* Now if we try to instantiate [escape_char] with bogus arguments,
   Boomerang points the finger at the source of the problem *)

test escape_char '&' "&amp;" ANYCHAR = error
(* ANYCHAR did not have sort (R:regexp where
   (not ((Core.lor ((matches R) (Native.Prelude.string_of_char &)))
   ((matches R) "&amp;"))))
   <<File "./Story.boom", line 157, characters 32-42:true>> blamed! *)

let escape_xml_char : (lens in ANYCHAR <=> XML_ESC ) = 
  ( escape_char '&' "&amp;" [^&]
  ; escape_char '<' "&lt;"  ([^&<] | "&amp;")
  ; escape_char '>' "&gt;"  ([^&<>] | "&amp;" | "&lt;") )
     
let escape_xml : (lens in ANY <=> XML_ESC_STRING) = 
  escape_xml_char*

test escape_xml.get 
  <<
    <hello&world>
  >>
= 
  <<
    &lt;hello&amp;world&gt;
  >> 

(* ... or better... *)
let escape_xml : (lens in ANY <=> XML_ESC_STRING ) = 
  let l1 = escape_char '&' "&amp;" [^&] in
  let l2 = escape_char '<' "&lt;"  ((codomain_type l1) - "<") in 
  let l3 = escape_char '>' "&gt;"  ((codomain_type l2) - ">") in 
  (l1;l2;l3)*

(* ------------------------------------------------------------------------ *)
let mutually_distinct (strs : string List.t) : bool =
  let ok,_ = 
    List.fold_left{string}{bool * string List.t}
      (fun (p:bool * string List.t) (s:string) ->
         let ok,seen = p in 
           ((ok && not (List.member{string} s seen)), List.Cons{string}(s,seen)))
      (true,List.Nil{string})
      strs in 
  ok

let no_repeated_esc_codes (pairs : (char * string) List.t) : bool =
  mutually_distinct (List.map{char * string}{string} snd{char}{string} pairs)

let contains_esc_char (esc:char) (pairs:(char * string) List.t) : bool = 
  List.exists{char * string} (fun (p:char * string) -> fst{char}{string} p = esc) pairs

let char_or_escaped (esc:char) (pairs:(char * string) List.t) : regexp =
  List.fold_left{char * string}{regexp}
    (fun (r:regexp) (p:char * string) ->
       let f,t = p in 
       r | f | esc . t)
    [] pairs

test char_or_escaped '&' #{char*string}[('&',"amp;");('<',"lt;");('>',"gt;")] = 
  ("&" | "&amp;" | "<" | "&lt;" | ">" | "&gt;")

let escaped (esc:char) (pairs:(char * string) List.t) : regexp = 
  List.fold_left{char * string}{regexp}
    (fun (r:regexp) (p:char * string) -> 
       let f,t = p in 
       (r - f | esc . t))
    ANYCHAR pairs
       
let escape_chars 
      (esc:char) 
      (pairs: (char * string) List.t where
            contains_esc_char esc pairs
         && no_repeated_esc_codes pairs)
   : (lens in ANY <-> (escaped esc pairs)* ) = 
  let l : lens = 
    List.fold_left{char * string}{lens}
      (fun (li:lens) (p:char * string) -> 
         let cj,sj = p in 
         let lj = escape_char cj (esc . sj) ((codomain_type li) - cj) in 
         li;lj)
      (copy ANYCHAR) pairs in 
    l*
      
let escape_xml : lens = 
  escape_chars '&' #{char*string}[('&',"amp;");('<',"lt;");('>',"gt;")] 

test escape_xml.get
    <<
        <hello&world>
    >>
  =
    <<
        &lt;hello&amp;world&gt;
    >> 



(* and then use domain_type *)

(*

(* Add patterns on lambda-binders and tidy the following *)

(* TODO move this to lenses/list.boom at some point *)

let fst (p : 'a * 'b) = (match p with (x,y) -> x) : 'a
let snd (p : 'a * 'b) = (match p with (x,y) -> y) : 'b

let union_of_fsts (pairs : (regexp*regexp) List.t) = 
  List.fold_left {regexp} {regexp} regexp_union []
                (list_map {regexp*regexp} {regexp} fst pairs)

let escape (pairs : (string * string) List.t) : lens =
  let escape_char =
    List.fold_left {lens} {string*string} 
      (fun (l:lens) (p:string*string) -> 
         (match p with 
           (from,to) -> ((from <-> to) | l)) : lens)
      (copy (ANYCHAR - (unescaped pairs)))
      pairs
  in
    escape_char*



(* Rendering (do we really need this??) *)

let render_quotes =
    "" <-> "\""
  . copy ( ("\\\"" | "\\\\" | [^\\"])* )
  . "" <-> "\""

let render_xml_tag =
    "" <-> "<tag>"
  . copy ( ("&lt;" | "&gt;" | "&amp;" | [^<>&])* )
  . "" <-> "</tag>"

(* generic versions *)

let tagged R tag = [<] . (str tag) . [>] . R . (str ("</" . tag)) . [>]

let render_tag (R : regexp) (tag : string) 
  : (R <-> tagged R tag)
  = render R ("<" . tag . ">") ("</" . tag . ">")

let render_str (R : regexp) : (R <-> quoted R) = render R "\"" "\""



(*

(* FIRST TRY:

let unrender_quotes =
    "\"" <-> "" 
  . copy ANY
  . "\"" <-> "" 

let unescape_quotes_char =
    "\\\"" <-> "\""
  | "\\\\" <-> "\\"
  | copy (ANYCHAR - [\\"])

let unescape_quotes = unescape_quotes_char*

test unescape_quotes get 
    <<<
        <hello\"world>
    >>> 
  = 
    <<<
        <hello"world>
    >>> 

let tester = unrender_quotes ; unescape_quotes
(* DOESN'T WORK!! *)
*)

let unrender_quotes R =
    "\"" <-> "" 
  . copy R
  . "\"" <-> "" 

let unescape_quotes_char =
    "\\\"" <-> "\""
  | "\\\\" <-> "\\"
  | copy (ANYCHAR - [\\])

let unescape_quotes = unescape_quotes_char*

test unescape_quotes get 
    <<<
        <hello\"world>
    >>> 
  = 
    <<<
        <hello"world>
    >>> 

let test1 = unrender_quotes (domain_type unescape_quotes) ; unescape_quotes

(* Does this transformation work in general? *)

(* Making the example harder: Make the ASCII into a CSV... *)

let escape_xml_char = 
    "<" <-> "&lt;"
  | ">" <-> "&gt;"
  | "&" <-> "&amp;"
  | copy (ANYCHAR - [<>&])

let escape_xml = escape_xml_char*

let render_tag R = 
    "" <-> "<tag>"
  . copy R
  . "" <-> "</tag>"

let test2 = escape_xml; render_tag (domain_type escape_xml) 

test test2 get 
    <<<
        <hello"world>
    >>> 
  = 
    <<<
        <tag>&lt;hello"world&gt;</tag>
    >>> 
    
let l = test1 ; test2

test l get 
    <<<
        " <hello\"world> "
    >>> 
  = <<<
        <tag> &lt;hello"world&gt; </tag>
    >>>

(*************************************************)
(* That works.  So let's make it more generic... *)

(* regex -> str -> str -> lens
   no possibility of failure, can give complete return type
*)
let render (R : regexp) (before : string) (after : string) 
  : (R <-> (before.R.after)) = 
    "" <-> before
  . copy R
  . "" <-> after

let render_xml R = render R "<tag>" "</tag>"

(* safe, since render is safe; can we pass the buck without 
   repeating the contract? 

   in essence, can we instrument render_tag but not install blame on its 
   arguments?
*)
let tagged R tag = [<] . (str tag) . [>] . R . (str ("</" . tag)) . [>]

let render_tag (R : regexp) (tag : string) 
  : (R <-> tagged R tag)
  = render R ("<" . tag . ">") ("</" . tag . ">")

(* as above *)
let quoted R = ["] . R . ["]

let render_str (R : regexp) : (R <-> quoted R) = render R "\"" "\""

(* is bijectivity guaranteed?  yes, but we need buck-passing *)
let unrender_str (R : regexp) : (quoted R <-> R) = invert (render_str R)

(* this function already existed inside escape, but we had to 
   pull it out *)
let unescaped (pairs : (string * string) List.t) =
  List.fold_left
    (fun r p ->
       match p with
         (from,to) -> ((str from) | r))
    []
    pairs

(* this function didn't exist before, but we need it to 
   talk about the domain_type of the lens produced by escape *)
let escaped (pairs : (string * string) List.t) =
  List.fold_left
    (fun r p ->
       match p with
         (from,to) -> ((str to) | to))
    []
    pairs

(* it's an interesting exercise to start with "naive" ass-covering and lead up to
   this relatively concise and understandable contract

   1) escaped chars are arbitrary strings, contract is "hell on wheels"
   2) change to single characters
   3) observe that the iterability constraint on the domain is satisfied by construction
   4) rewrite the codomain, making it nice and concise
*)
type char = (s : string where length s = 1)

(* given a set of chars to be escaped and escape codes, valid escaped "bits" are:
     (a) an escape code, or
     (b) a character that didn't need to be escaped
*)
let char_or_escaped (pairs : (char * string) List.t) =
  escaped pairs || (ANYCHAR - (unescaped pairs))

(*
  any string goes to a sequence of char_or_escaped bits
*)
let escape 
  (pairs : (char * string) List.t where
             no_repeated_escape_codes pairs &&
             iterable (char_or_escaped pairs))
  : (ANY <-> (char_or_escaped pairs)* )
  =
  let escape_char =
    List.fold_left
      (fun l p -> 
         match p with 
           (from,to) -> ((from <-> to) || l))
      (copy (ANYCHAR - (unescaped pairs)))
      pairs
  in
    escape_char*

let char_or_escaped2 (esc : char) pairs =
  let escs = List.map (fun (from,to) -> (from,esc . to)) pairs in
  (escaped escs) || (ANYCHAR - (unescaped pairs))

let escape2
  (esc : char)
  (pairs : (char * string) List.t where
             List.exists (fun (c,_) -> c = esc) pairs &&
             no_repeated_escape_codes pairs)
  : (ANY <-> (char_or_escaped2 esc pairs))
  =
  let escape_char =
    List.fold_left
      (fun l p -> 
         match p with 
           (from,to) -> ((from <-> esc . to) || l))
      (copy (ANYCHAR - (unescaped pairs)))
      pairs
  in
    escape_char*

let xml_escs : (string * string) List.t =
  List.Cons((">","gt;"),
  List.Cons(("<","lt;"),
  List.Cons(("&","amp;"), 
  List.Nil)))

(* again, do we want lens, or can/should we somehow 
   say "specialize this"?  

   : ANY <-> (/&gt;/ | /&lt;/ | /&amp;/ | [^<>&])*
*)
let escape_xml : lens = escape2 xml_escs

let str_escs : (string * string) List.t =
  List.Cons(("\"","\""),
  List.Cons(("\\","\\"),
  List.Nil))

(* per above *)
let escape_str : lens = escape2 "\\" str_escs

(* ditto *)
let unescape_str : lens = invert escape_str

let l2 = 
  unrender_str (domain_type unescape_str) ; unescape_str ; 
  escape_xml ; render_xml (codomain_type escape_xml)

test l2 get 
    <<<
        " <hello\"world> "
    >>> 
  = <<<
        <tag> &lt;hello"world&gt; </tag>
    >>>

let concatable (lenses : lens List.t) (sep : lens) : bool =
  let concatted = List.fold_left 
    (fun l_acc l -> 
       match l_acc with
         | Prelude.None -> Some true
         | Prelude.Some acc -> 
           let can_sep = splittable acc sep in
             Some (can_sep && (splittable (acc . sep) l)))
    None lenses in
  match concatted with
    | Prelude.Some b -> b
    | Prelude.None -> true

(* to cover our asses, we need the concatable refinement

   do we want the specific return type?
*)
let concat_lenses 
      (lenses : lens List.t) 
      (sep : lens where concatable lenses sep) : lens =
  let concatted = List.fold_left 
    (fun l_acc l -> 
       match l_acc with
         | Prelude.None -> Some l
         | Prelude.Some acc -> Some (acc . sep . l)) None lenses in
  match concatted with
    | Prelude.Some l -> l
    | Prelude.None -> copy epsilon

let field_to_xml (field : string) : lens = 
  unrender_str (domain_type unescape_str) ; unescape_str ;
  escape_xml ; render_tag (codomain_type escape_xml) field

(* as above -- do we want the strict return type?  do we want to pass the buck? *)
let csv_to_xml (fields : string List.t where concatable fields (del ",")) = 
  concat_lenses (list_map field_to_xml fields) (del ",")

let l3 = csv_to_xml (List.Cons("first",List.Cons("last",List.Nil)))

test l3 get
    <<<
        "Michael \"The Autominator\"","Greenberg, Jr. &c"
    >>>
  = <<<
        <first>Michael "The Autominator"</first><last>Greenberg, Jr. &amp;c</last>
    >>>

*)
*)
