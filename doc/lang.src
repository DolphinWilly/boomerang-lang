\chapter{The Focal Language}

  The Focal language provides convienent concrete syntax for writing
  lenses programs along with names, trees, schemas, functions, and
  embedded unit tests.  The concrete syntax is based on the
  fully-annotated, monomorphic core of OCaml.

  \input{tmp/lexer}
  
  \input{tmp/parser}
  
  \section{Schemas} \label{sec:lang:schemas}
  
  When constructing schemas, the Focal compiler checks three
  well-formedness constraints:
  \begin{itemize}
  \item All schemas must be contractive. The compiler ensures that the
    schemas it produces are contractive using a syntactic check: all
    recursive uses of @schema@-bound variables must appear at least
    one level deeper in the schema. The compiler rejects
    non-contractive schemas such as @schema X = X + {}@ and 
    @schema Y = Y | { "n" = {} }@ but allows @schema X = { n = X } | {}@. 

  \item When concatenating two schemas, the sets of names that may
    appear as immediate children in the two schemas must be disjoint,
    except for the infinite sets generated by wildcards. For example, 
    the schemas @{"n" = {}} + {"n" = []}@ and @{"n" = {}} + {!=[]}@ 
    are both rejected because the name @n@ appears on both sides of 
    the concatenation. However, the schema @{! = {}} + {! = {}}@ is 
    allowed since the overlap is on every child.
  
  \item When forming a schema using union (or concatenation), for
    every name, the subschema below each name appearing on both sides
    of the union (or concatenation) must be equivalent. This
    restriction is analogous to the restriction on tree grammars
    embodied in W3C schema. The Focal compiler currently only supports
    a simple syntactic approximation of schema equivalence (e.g., it
    does not equate a recursive variable with its expansion or
    distribute unions). For example, the schemas @{"n" = {}} | {"n" = []}@
    and @{"n" = []} | {! = {}}@ are both rejected since the subschemas below 
    @n@, @{}@ and @{}@ are not equivalent.
  \end{itemize}

