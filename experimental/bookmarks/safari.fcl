module Safari =

(* note: mapName takes a predicate, but it *must* contain 
   a single name when we have variables in views; we should 
   change it so that it takes a name instead *)
let mapName (p:view) (l:lens) = fork p (map l) id
 
(* list helpers *)
let addAtomic = add "*" {}
let addEmptyTail = add "*t" {}; mapName {"*t"} (addAtomic)
let listifyHd = addAtomic; addEmptyTail

(* Schemas *)
let EmptyList = < {"*nil"} >
let EmptyView = < {} >
let SingletonList (X:type) = < {"*h"=X, "*t"=[]} >
let SingListSingList = SingletonList (SingletonList Any)
let StrangeSchema = < {"x1" = Any, "a1" = Any, "*" = Any} >

let myrename (m:name) (n:name) : lens = 
  probe "before xfork";
  xfork {m} {n} (probe "before acond"; acond EmptyView EmptyView id (probe "inside myrename"; hoist m; plunge n)) id

let groupby2 : lens =
  let tmp : name = "tmp" in
  let add_empty_tail : lens =
    add tl_tag {};
    wmap { tl_tag -> add nil_tag {} }
  in
    acond <[]> <[]>
      id
      ((* (1) save hd of the list under tmp *)
	rename hd_tag tmp;
	(* (2) bring the tail of the list up to the root level *)
	hoist_nonunique tl_tag list_tags;
	(* split on domain at the root level; two cases:
	   (a) tail was empty --> domain is { tmp, nil }
	   (b) tail was non-empty --> domain is { tmp, hd, tl }
	*)
	acond <{tmp=Any,nil_tag={}}> <[[Any]]>
	  ((* case (a) yeild [[tmp]] *)
	    xfork {nil_tag} {tl_tag} (plunge tl_tag) id;
            rename tmp hd_tag;
            plunge hd_tag;
	    add_empty_tail)	  
	  ((* case (b) produce [tmp,hd]::(groupby2 tl) *)
            xfork {tmp, hd_tag} {hd_tag}
              (rename hd_tag tl_tag;
	       wmap {tl_tag -> plunge hd_tag; add_empty_tail };
               rename tmp hd_tag;             
               plunge hd_tag)
              (wmap { tl_tag -> groupby2 })))
      
let plist_object_lens : lens =
  wmap { "dict" -> dict_lens,
         "array" -> array_lens,
         "string" -> leaf_lens }

and array_lens : lens =
  hoist "";
  list_map plist_object_lens

and dict_lens : lens =
  hoist "";
  groupby2;
  list_map (keypair_lens)

and keypair_lens : lens =
  wmap { "*h" -> hoist "key"; leaf_lens, 
         "*t" -> wmap {"*h" -> plist_object_lens } }

and leaf_lens : lens =
  hoist "";
  acond EmptyList < { "*t"=EmptyList, "*h"={"PCDATA" = {"BLANK"={}, *\"BLANK"=Any}}} >
   (const [{"PCDATA"="BLANK"}] {})
   id;
  hd [];
  hoist "PCDATA"

let plist_lens =
  hoist "";
  hd [];
  hoist "plist";
  focus "" {};
  hd [];
  plist_object_lens

let l = plist_lens

