module Safari =

open Plist

(* types *)
type Value = { ! = {} }
(* Safari bookmark abstract schema *)
type URIDict = { "BLANK" = Value, "title" = Value, *\"BLANK","title" = Any }
type Link = { "URIDictionary" = URIDict, "URLString" = Value, *\"URIDictionary","URLString" = Any }
type Folder = { "Children" = List.List Item, "Title" = Value, *\"Children","Title" = Any }
and Item = { "folder" = Folder } | { "link" = Link }
type SafAbstract = List.List Item

(* lenses *)
let flatten_dict =
  hoist "dict";
  List.map (
    pivot List.HD;
    map (focus List.TL {}; List.hd [])
  );
  flatten;
  map (List.hd [])

let root = 
  focus "Children" {}

let children : lens = 
  wmap { "array" -> List.map (item; 
			      pivot "WebBookmarkType";
(* 			      wmap { "WebBookmarkTypeLeaf" -> wmap { "URIDictionary" -> rename "title" "name"}, *)
(* 				"WebBookmarkTypeList" -> rename "Title" "name" *)
(* 				   }; *)
			      acond <{"WebBookmarkTypeLeaf" = Any}> <{"link"=Any}> 
			      (rename "WebBookmarkTypeLeaf" "link")
				(rename "WebBookmarkTypeList" "folder")
				) 
       };
  hoist "array"

and item : lens = 
  flatten_dict;
  wmap { "Children" -> children,
    "URIDictionary" -> item,
      "URLString" -> hoist "string",
	"WebBookmarkType" -> hoist "string",
	  "title" -> hoist "string",
	    "Title" -> hoist "string",
	      "BLANK" -> hoist "string"
       }
    
(* l is for homogeneous synchronization of safari bookmarks *)
let l =
  probe "AVANT / APRES PLIST";
  plist_lens;
  probe "ENTRE PLIST ET SAFARI";
  flatten_dict;
  root;
  children;
  (* checkpoint :) *)
  assert SafAbstract

(* l2 is for heterogeneous synchronization of safari bookmarks *)
let tidy : lens =
  let tidy_folder = 
    rename "Children" "contents"; wmap {"contents" -> tidy }; rename "Title" "name"; 
    filter {"name", "contents"} {} in
  let tidy_link =
    rename "URLString" "url";
    wmap { "URIDictionary" -> rename "title" "name"; filter {"BLANK", "name"} {}};
    hoist_nonunique "URIDictionary" {"name", "BLANK"};
    merge "url" "BLANK";
    filter {"name", "url"} {}
  in
  List.map (wmap {"folder" -> tidy_folder, "link" -> tidy_link})
    
let l2 =
  l;
  tidy;
  (* final checkpoint *)
  assert Schemas.Abstract
