module Mozilla_bookmark =
open Prelude
open Xml

type Dummy = Schemas.Abstract

(* definitions of types for conditionals *)
(* in the get way *)
type Dd = { "dd" = Any }
type Ddavech3 = { "dd" = { "" = [{"h3" = Any}] } }
type Ddsansh3 = { "dd" = { "" = ({"PCDATA" = Any } :: Any )} }
type Dt = { "dt" = Any }
      
type Item = List.List (Dd | Dt )
      
type ItemFolder = Dd :: Item
type ItemFolderDesc = Ddavech3 :: (Ddsansh3 :: Item)
type ItemLink = Dt :: Item
type ItemLinkDesc = Dt :: (Ddsansh3 :: Item)

(* and in the put way *)
type FullLink U = {"name" = U, "url" = U, "description" = U}
type FullFolder T U = {"name" = U, "contents" = T, "description" = U}

type Link = {"dt" = Schemas.Link } :: Item
type Folder = { "dd" = Schemas.Folder } :: Item
type LinkWithDesc =  {"dt" = FullLink Any } :: Item
type FolderWithDesc = { "dd" = FullFolder Any Any } :: Item

(* and for the asserts *)
type MLink = Schemas.Link | (FullLink Schemas.V)
(** this Any should be replaced by MozAbstract because FullFolder uses its first *)
(** argument under a name so it's ok for recursion...                            *)
type MFolder = Schemas.Folder | (FullFolder Any Schemas.V)
and MozAbstract = List.List ({ "folder" =  MFolder } | { "link" = MLink })

type MozConcrete = Any
      
(* lenses *)

(* this lens keeps stuff like descriptions for eventual    *)
(* sync with another mozilla bookmark. To syn with another *)
(* type of bookmark, the lens l2 should be applied instead *)
let l =
  let no_descr_tag : view  =
    { List.HD = { "dd" = { "" = [ {"PCDATA"= {"No description"}} ] }}} in
  let no_descr : view =
    { List.HD = { "PCDATA" = {"No description"}}} in
  
  let hoist_hd (p : view) =
    hoist_nonunique List.HD p;
    hoist_nonunique List.TL List.tags  in
  
  let link : lens = 
    wmap {"dt"->
      wmap { "" ->
	List.hd [];
	hoist "a";
	filter {"", "href", "add_date"} {};
	rename "" "name";
	rename "href" "url";
	prune "add_date" {"01/01/1970"};
	wmap { "name" -> (List.hd []; hoist "PCDATA") }
	   };
      hoist_nonunique "" {"name", "url"}
	 }
      
  and folder : lens =
    wmap { "dd" ->
      wmap { "" ->
	hoist_hd {"h3"};
	fork {"h3"} id (hoist_nonunique List.HD {"dl"});
	prune List.TL [];
	rename_if_present "h3" "name";
	rename_if_present "dl" "contents";
	wmap {"name" -> (filter {""} {}; hoist ""; List.hd []; hoist "PCDATA"),
	  "contents" -> (hoist ""; item_list)}
	   };
      hoist_nonunique  "" {"name", "contents"}
	 }
      
      
  and item_list : lens =
    let itemfolderdesc2 =
      List.tl {}; wmap {List.TL ->item_list}; List.tl {} in
    let itemfolderdesc = 
      (* that's the tricky part.. will comment it later *)
      wmap { List.HD -> (hoist	"dd"; hoist ""; List.hd []),
	List.TL -> 
	  wmap {List.HD -> hoist "dd"; hoist ""; 
	    hoist_nonunique List.HD {"PCDATA"}; rename "PCDATA" "description";
	    rename List.TL "myTail"
	       };
	  hoist_nonunique List.HD {"myTail", "description"}
	   };
      hoist_nonunique List.TL {List.TL, "myTail", "description"};
      hoist_nonunique List.HD {"h3"};
      plunge List.HD;
      wmap { List.HD -> 
	xfork {"myTail", "h3", "description"} {List.HD} 
	  (xfork {"h3", "myTail"} {""} (rename "myTail" List.TL; xfork {"h3"} {List.HD} (plunge List.HD) id; plunge "") id; plunge "dd"; plunge List.HD) 
	  id 
	   }; 
      hoist List.HD;
      wmap { List.HD -> folder, List.TL -> item_list }
    in
    let itemfolder =
      wmap { List.HD -> folder, List.TL -> item_list } 
    in
    let itemlink =
      wmap { List.HD -> link, List.TL -> item_list } 
    in
    let itemlinkdesc =
      (* pretty much the same strategy as in itemfolderdesc, but EZer here *)
      wmap { List.HD -> hoist "dt",
	List.TL -> wmap { List.HD -> hoist "dd"; hoist ""; List.hd []; rename "PCDATA" "description" };
	  hoist_nonunique List.HD {"description"}
	   };
      hoist_nonunique List.HD {""};
      hoist_nonunique List.TL {"description", List.TL};
      xfork {"", "description"} {List.HD} (plunge "dt"; plunge List.HD) id;
      wmap { List.HD -> link, List.TL -> item_list }
	
    in
    acond <ItemFolderDesc> <FolderWithDesc> itemfolderdesc
      (acond <ItemFolder> <Folder> itemfolder
	 (acond <ItemLinkDesc> <LinkWithDesc> itemlinkdesc
	    (acond <ItemLink> <Link> itemlink
	       (* then it must be Nil *) id
	       )
	    )
	 );
    List.map (rename_if_present "dd" "folder"; rename_if_present "dt" "link") in
  
  let bookmarks : lens =
    assert <MozConcrete>;
    hoist "";
    List.hd [];
    hoist "html";
    focus "" {"xmlns" = { "http://www.w3.org/1999/xhtml"}};
    List.tl { "head" = { "" = [{"title" = {""= [{ "PCDATA" = {"Bookmarks"}}]}}]}};
    List.hd [];
    hoist "body";
    hoist "";
    List.tl { "h1" = { "" = [{ "PCDATA" = {"Bookmarks"} }]}};
    List.hd [];
    hoist "dl";
    hoist "";
    item_list;
    assert <Any>
      
  in
  bookmarks
    
(* see l *)
let l2 =
  let disc_desc : lens =
    List.map (map (wmap {"contents" -> disc_desc }; filter {"name", "contents", "url"} {}))
  in
  (l;  disc_desc; assert <Schemas.Abstract>)
