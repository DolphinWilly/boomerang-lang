module Mozilla_bookmark =
open Prelude

(* definitions of types for conditionals *)
type Dd = { "dd" = Any }
type Ddavech3 = { "dd" = { "" = [{"h3" = Any}] } }
type Ddsansh3 = { "dd" = { "" = ({"PCDATA" = Any } :: Any )} }
type Dt = { "dt" = Any }

type Item = List.List (Dd | Dt )

type ItemFolder = Dd :: Item
type ItemFolderDesc = Ddavech3 :: (Ddsansh3 :: Item)
type ItemLink = Dt :: Item
type ItemLinkDesc = Dt :: (Ddsansh3 :: Item)

(* lens *)
let l =
  let no_descr_tag : view  =
    { List.HD = { "dd" = { "" = [ {"PCDATA"= {"No description"}} ] }}} in
  let no_descr : view =
    { List.HD = { "PCDATA" = {"No description"}}} in
  
  let hoist_hd (p : view) =
    hoist_nonunique List.HD p;
    hoist_nonunique List.TL List.tags  in

  let link : lens = 
    trace "LINK >>>\n";
    hoist "dt";
    wmap { "" ->
      List.hd [];
      trace "1\n";
      hoist "a";
      filter {"", "href", "add_date"} {};
      trace "2\n";
      rename "" "name";
      trace "3\n";
      rename "href" "url";
      trace "4\n";
      prune "add_date" {"01/01/1970"};
      trace "5\n";
      wmap { "name" -> (List.hd []; hoist "PCDATA") }
	 };
    trace "6\n";
    hoist_nonunique "" {"name", "url"};
    trace "\n<<< LINK\n"
      
  and folder : lens =
    hoist "dd";
    wmap { "" ->
      hoist_hd {"h3"};
      fork {"h3"} id (hoist_hd {"dl"});
      prune List.NIL {}; prune List.HD {}; prune List.TL {};
      rename "h3" "name";
      rename "dl" "contents";
      wmap {"name" -> (filter {""} {}; hoist ""; List.hd []; hoist "PCDATA"),
	"contents" -> (hoist ""; item_list)}
	 };
    hoist_nonunique  "" {"name", "contents"}
      
      
  and item_list : lens =
    let itemfolderdesc2 =
      List.tl {}; wmap {List.TL ->item_list}; List.tl {} in
    let itemfolderdesc = 
      (* that's the tricky part.. will comment it later *)
      wmap { List.HD -> (hoist	"dd"; hoist ""; List.hd []),
	List.TL -> 
	  wmap {List.HD -> hoist "dd"; hoist ""; 
	    hoist_nonunique List.HD {"PCDATA"}; rename "PCDATA" "description";
	    rename List.TL "myTail"
	       };
	  hoist_nonunique List.HD {"myTail", "description"}
	   };
      hoist_nonunique List.TL {List.TL, "myTail", "description"};
      hoist_nonunique List.HD {"h3"};
      plunge List.HD;
      wmap { List.HD -> 
	xfork {"myTail", "h3", "description"} {List.HD} 
	  (xfork {"h3", "myTail"} {""} (rename "myTail" List.TL; xfork {"h3"} {List.HD} (plunge List.HD) id; plunge "") id; plunge "dd"; plunge List.HD) 
	  id 
	   }; 
      hoist List.HD;
      wmap { List.HD -> folder, List.TL -> item_list }
    in
    let itemfolder =
      wmap { List.HD -> folder, List.TL -> item_list } 
    in
    let itemlink =
      wmap { List.HD -> link, List.TL -> item_list } 
    in
    let itemlinkdesc =
      trace "\nITEMLINKDESC >>>\n";
      (* pretty much the same strategy as in itemfolderdesc, but EZer here *)
      wmap { List.HD -> hoist "dt",
	List.TL -> wmap { List.HD -> hoist "dd"; hoist ""; List.hd []; rename "PCDATA" "description" };
	  hoist_nonunique List.HD {"description"}
	   };
      trace "-1\n";
      hoist_nonunique List.HD {""};
      trace "-2\n";
      hoist_nonunique List.TL {"description", List.TL};
      trace "-3\n";
      xfork {"", "description"} {List.HD} (plunge "dt"; plunge List.HD) id;
      trace "-5\n";
      wmap { List.HD -> link, List.TL -> item_list } ;
      trace "\n<<< ITEMLINKDESC\n"
	
    in
    ccond <ItemFolderDesc> itemfolderdesc
      (ccond <ItemFolder> itemfolder
	 (ccond <ItemLinkDesc> itemlinkdesc
	    (ccond <ItemLink> itemlink
	       (* then it must be Nil *) id
	       )
	    )
	 );
    List.map (rename_if_present "dd" "folder"; rename_if_present "dt" "link") in
      
  let bookmarks : lens =
    hoist "";
    List.hd [];
    hoist "html";
    focus "" {"xmlns" = { "http://www.w3.org/1999/xhtml"}};
    List.tl { "head" = { "" = [{"title" = {""= [{ "PCDATA" = {"Bookmarks"}}]}}]}};
    List.hd [];
    hoist "body";
    hoist "";
    List.tl { "h1" = { "" = [{ "PCDATA" = {"Bookmarks"} }]}};
    List.hd [];
    hoist "dl";
    hoist "";
    item_list

  in
  bookmarks
    
