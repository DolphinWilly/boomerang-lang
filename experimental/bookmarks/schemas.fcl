module Schemas =
open Prelude
  
(* type for values *)
type V = { !={} }     

(* the abstract schema for heterogeneous synchronization, as described in the paper *)
type Link = { "name" = `V, "url" = `V }

type Folder  = { "name" = `V, "contents" = `Contents }     
and Contents  = List.T ({ "folder" = `Folder} | {"link" =  `Link})

type Abstract = Contents

(* A flattened abstract bookmark schema for synchronization with easy alignment *)
type Item = { "folders" = { * = `(List.T Item) }, "links" = { * = `V } }
and Twig = List.T { "folders" = { * = `(List.T Twig) }, "links" = { * = `V } }

type BushAbstract = Item
      
(* the lens to flatten the abstract tree into a bush *)
let flatten_to_bush : lens =

  (* recursively applies the lens to the folder contents, and pivots the links *)
  List.map (
  wmap {"folder" -> (pivot "name"; map (hoist "contents"; flatten_to_bush)) , 
    "link" -> pivot "url"; map (hoist "name")}
    );

  (* this flatten regroups all links and folders in two lists *)
  flatten;

  (* now we flatten these lists, and keep only the heads for links, since *)
  (* different links at the same location never have the same urls        *)
  wmap {"folder" -> flatten,
    "link" -> (flatten; map (List.hd []))
       };
  
  (* we also rename the two lists in a more consistent way *)
  rename_if_present "folder" "folders";
  rename_if_present "link" "links";
  
  (* the following conditionals adds empty folders and links if needed *)
  acond <{}> <{"folders"={}, "links"={}}>
  ( add "links" {}; add "folders" {} )
    (acond <{"links"=`Any}> <{"folders"={}, "links" = `Any}>
     (add "folders" {})
       (acond <{"folders"=`Any}> <{"folders" = `Any, "links" = {}}>
	(add "links" {})
	  id
	  )
       )    
    
let flatten_bookmarks =
  assert Abstract;
  flatten_to_bush;
  assert BushAbstract
