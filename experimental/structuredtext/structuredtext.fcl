module Structuredtext = 

(* Called when the first element does not satisfy the predicate.  Adds the first element
   to the first sublist (i.e., the head of the tail). *)
let continue =
  rename List.HD "temp";
  hoist_nonunique List.TL { `List.HD, `List.TL };
  xfork {temp,`List.HD} {`List.HD}
    (rename List.HD List.TL; rename "temp" List.HD; plunge List.HD)
    id
test continue / \ [x, [y], [z]] = [[x,y], [z]]
test continue / \ [x, []] = [[x]]

(* Called when the first element satisfies the predicate.  Starts a new "head list". *) 
let start_fresh = wmap { `List.HD -> plunge List.HD; add List.TL [] }
test start_fresh / \ [x, [y], [z]] = [[x], [y], [z]]
test start_fresh / \ [x,[]] = [[x],[]]

type Char = Value   (* Should be just single characters *)

type Element = List Char  
type Incomplete H = List Any  (* Bogus: Should be List Char \ H *)
type Complete H = Cons H (Incomplete H)
type MaybeComplete H = Complete H | Incomplete H
type ParsedList H = Cons (MaybeComplete H) (List (Complete H))

type TailComplete H = Cons Any (Cons (Cons H Any) Any)
type HeadSingletonAndTailNonempty = Cons (Cons Any Nil) (Cons Any Any)

let process_elt (H:type) =
    (acond <TailComplete H> <HeadSingletonAndTailNonempty> 
       start_fresh
       continue)

type T = NonEmptyList ({X}|{A}|{B}|{C})
test process_elt T / \ [[X], []] = [[[X]]]
test process_elt T / \ [[X], [[A],[b]], [[C]]] = [[[X]], [[A],[b]], [[C]]]
test process_elt T / \ [[X], [[a],[b]], [[C]]] = [[[X],[a],[b]], [[C]]]

let parse_list_with_headers (H:type) =
  List.fold_right [] (process_elt H)

(******************************************************************************)
(* Some specific useful instances... *)

(* The top-level structured text lens.  Maps from lists of values to lists of lists of values, where the
   first element of each of the resulting sublists (except possibly the first) is a "header".  The parameter
   H specifies the type of headers in "exploded" form -- i.e., H should be a type of lists of characters. *)
let l (H:type) = List.map explode; parse_list_with_headers H; List.map (List.map implode)

type CapLetter = {A}|{B}|{C}|{D}|{E}|{F}|{G}|{H}|{I}|{J}|{K}|{L}|{M}|{N}|{O}|{P}|{Q}|{R}|{S}|{T}|{U}|{V}|{W}|{X}|{Y}|{Z}
type AllCapsList = NonEmptyList (CapLetter|{" "})

let caps_headers = l AllCapsList

test caps_headers / \ [] = [[]]
test caps_headers / \ [X] = [[X]]
test caps_headers / \ [x] = [[x]]
test caps_headers / \ [X,y,Z] = [[X,y],[Z]]
test caps_headers / \ [x,y,Z] = [[x,y],[Z]]

(******)

type StarHeader1 = Cons {"*"} (Cons {" "} (NonEmptyList Char))
type StarHeader2 = Cons {"*"} StarHeader1

let star_headers = l StarHeader1; List.map (wmap {`List.TL -> (l StarHeader2)})

test star_headers / \ ["* Foo", bar] = [["* Foo", [bar]]]
test star_headers / \ ["* Foo", "** bar", "** baz"] = [["* Foo", ["** bar"],["** baz"]]]
test star_headers / \ ["* Foo", "** bar", glorf, "** baz", urg] = [["* Foo", ["** bar", glorf],["** baz",urg]]]
test star_headers / \ ["* Foo", "* Bar", baz] = [["* Foo", []], ["* Bar", [baz]]]

(* Some degenerate ones *)
test star_headers / \ [] = [[]]
test star_headers / \ [foo] = [[foo, []]]
test star_headers / \ [foo, "* Bar"] = [[foo, []], ["* Bar", []]]
test star_headers / \ [foo, "** Bar"] = [[foo, ["** Bar"]]]
                                                  
sync with caps_headers at (List Any)
  { O = [X,y,z],
    A = [X,a,z],
    B = [X,y,b] }
  =
    [X,a,b]

(* Doesn't work because of bogus contractiveness check... 
     type NestedListOfValues = List (Value | NestedListOfValues)
   ...so for now we do: *)   
(*
type NestedListOfValues = Nil | { `List.HD=`(Value | NestedListOfValues), `List.TL=`NestedListOfValues}
type NestedListOfValues = Any
*)

(******************************************************************************)
(* Some useful instances packaged for invoking from the command line... *)

let file_with_all_caps_headers = split; caps_headers

