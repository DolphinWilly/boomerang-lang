== FIX AS SOON AS POSSIBLE ==
* Lens printing is currently deficient

** using clobber as our implementation primitive means that we can't
   print useful lens representations for const, ins, etc.

** we _have_ enough information to print canonizer_of_lens well, but
   the two types are currently defined separately in different modules...

* have toplevel sync command use a lens

== SUMMER AGENDA ==

* toplevel

** -e argument

** Arg module containing non-Boomerang flags

** default to "main" lens if only a module is given

* Configuration management

** Boomerang only

** Whole document with Unison

*** Bsync

*** unison interface

* coqsplit

* unit testing

** programmatic blame

*** more specific "this code raises blame" tests

** desugar test syntax into DLet, eliminate DTest

* MediaWiki

** annotated regexps

** safe bijections

* diffy matching

* nested words and recursion

** string <-> tree

* grammars

== BUILD == 

* add target for bytecode compilation (Nate)

== SYSTEM ==

* -check-only flag: don't compile and run, just check that base sorts
  line up.

* re-do lens printing entirely

* better error messages on bad overloading resolution (usually caused by a type issue elsewhere)

* optimization and speedups (profiling indicates lots of GC activity)

* functions to process command-line arguments from boomerang (e.g., set solutions mode for coqsplit)

* match tags are currently static: <LIDENT:qid> is the parsing rule.
  we should relax this to <aexp:qid> and allow for dynamically
  generated match tags.  this is necessary, e.g., for pdict.

** expose dictionary typing rules and add to contracts?  right now
   dictionary typing errors are runtime errors about static tagging.
   if we make the tags dynamic, it will be harder to debug, e.g.

   let l1,l2 = copy "a",copy "b"
   let l (tag:string) = <"x":l1> . <tag:l2>

   will produce an error message saying that the tag "x" is used with
   two different lenses if it ever gets "x" in the tag...

== LIBRARIES == 

* Investigate other options for the contract on sorting.

* Work out standardized WS/WSP/NL* regexps

* Fix contract on q-lenses using crel/arel/cnrel.

* Various ISO formats, e.g. ISO8601 dates 
** http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=40874

* Encodings and numbes: Base64, hex, scientific notation
** can we write a lens in hex <-> decimal?  which primitives must we add, if any?

== DOCUMENTATION ==

* Polish intro of manual.

* Add examples using q-lenses to QuickStart.

* Add description of sync.

* Fiat description is not very clear (need a simple example; why is it useful?)

* Maybe warn the user to use regexp as long as possible and only write lenses
  when he can not continue using regexp.  Example:
  (del R)*  and  del (R*)   where R:regexp
